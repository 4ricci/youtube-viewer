#!/usr/bin/perl

# Copyright (C) 2010-2015 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#-------------------------------------------------------
#  GTK Youtube Viewer
#  Created on: 12 September 2010
#  Latest edit on: 28 March 2015
#  Website: http://trizen.googlecode.com
#-------------------------------------------------------

use utf8;
use 5.010;
use strict;

#use lib qw(../lib);    # devel only
#use warnings;          # debug only

no if $] >= 5.018, warnings => 'experimental::smartmatch';

use Gtk2 qw(-init);
use File::ShareDir qw(dist_dir);
use File::Spec::Functions qw(
  rel2abs
  catdir
  catfile
  curdir
  updir
  path
  tmpdir
  );

my $appname  = 'GTK Youtube Viewer';
my $version  = '3.1.2';
my $execname = 'gtk-youtube-viewer';

# Developer key
my $key = 'eTj9NtCyOsGMliTTwz-T85muGT-ARAwVREslfB_giHP3X339Jkpn5Xf71pQXY96xWtFY1oFHt530ct5uZZJk5YTghbNm2IrwZ4';

# Configuration dir/file
my $xdg_config_home = $ENV{XDG_CONFIG_HOME}
  || catdir(($ENV{HOME} || $ENV{LOGDIR} || (getpwuid($<))[7] || `echo -n ~`), '.config');

# Configuration dir/file
my $config_dir = catdir($xdg_config_home, 'youtube-viewer');
my $config_file         = catfile($config_dir, "$execname.conf");
my $youtube_users_file  = catfile($config_dir, 'youtube_users.txt');
my $authentication_file = catfile($config_dir, 'reg.dat');

# Create the configuration directory
foreach my $dir ($config_dir) {
    if (not -d $dir) {
        require File::Path;
        File::Path::make_path($dir)
          or warn "[!] Can't create the configuration directory `$dir': $!";
    }
}

## Backwards compatibility for moving the configuration files in the new directory
{
    my $old_config_dir = catdir($xdg_config_home, $execname);
    my $old_config_file        = catfile($old_config_dir, "$execname.conf");
    my $old_youtube_users_file = catfile($old_config_dir, 'youtube_users.txt');

    if (-e $old_config_file and not -e $config_file) {
        require File::Copy;
        File::Copy::move($old_config_file, $config_file)
          or warn "[!] Can't move the configuration file `$old_config_file' to `$config_file': $!";
    }

    if (-e $old_youtube_users_file and not -e $youtube_users_file) {
        require File::Copy;
        File::Copy::move($old_youtube_users_file, $youtube_users_file)
          or warn "[!] Can't move the youtube users file `$old_youtube_users_file' to `$youtube_users_file': $!";
    }
}
## end of compatibility

# Share directory
my $share_dir = dist_dir('WWW-YoutubeViewer');

sub which_command {
    my ($cmd) = @_;
    state $paths = [path()];
    foreach my $path (@{$paths}) {
        if (-e (my $cmd_path = catfile($path, $cmd))) {
            return $cmd_path;
        }
    }
    return;
}

my %symbols = (
               up_arrow    => '↑',
               down_arrow  => '↓',
               category    => '❖',
               face        => '☺',
               average     => 'x̄',
               play        => '▶',
               views       => '◈',
               heart       => '❤',
               right_arrow => '→',
               crazy_arrow => '↬',
              );

# Main configuration
my %CONFIG = (

    # Combobox values
    active_sort_by_combobox      => 0,
    active_time_sort_by_combobox => 0,
    active_resolution_combobox   => 0,
    active_search_for            => 0,
    active_hd_combobox           => 0,
    active_caption_combobox      => 0,
    active_duration_combobox     => 0,
    active_safe_search_combobox  => 1,
    active_more_options_expander => 0,

    video_players => {
                      mplayer => {
                                  cmd   => q{mplayer},
                                  srt   => q{-sub *SUB*},
                                  audio => q{-audiofile *AUDIO*},
                                  fs    => q{-fs},
                                  arg   => q{-prefer-ipv4 -really-quiet -cache %d -cache-min %d},
                                 },
                      vlc => {
                              cmd   => q{vlc},
                              srt   => q{--sub-file *SUB*},
                              audio => q{--input-slave *AUDIO*},
                              fs    => q{--fullscreen},
                              arg   => q{--quiet --play-and-exit --no-video-title-show},
                             },
                      mpv => {
                              cmd   => q{mpv},
                              srt   => q{--sub-file *SUB*},
                              audio => q{--audio-file *AUDIO*},
                              fs    => q{--fullscreen},
                              arg   => q{--really-quiet},
                             },
                     },
    video_player_selected => undef,    # autodetect it later

    # MPlayer options
    cache           => 30000,
    cache_min       => 5,
    lower_cache     => 1000,
    lower_cache_min => 3,

    # GUI options
    clean_text_entries_on_click => 1,
    show_thumbs                 => 1,
    clear_list                  => 1,
    default_notebook_page       => 1,
    mainw_size                  => '700x400',
    mainw_maximized             => 0,
    mainw_fullscreen            => 0,

    # Youtube options
    prefer_https        => 0,
    dash_support        => 1,
    results             => 10,
    resolution          => 'original',
    hd                  => undef,
    safe_search         => undef,
    caption             => undef,
    duration            => undef,
    time                => undef,
    orderby             => undef,
    categories_language => 'en-US',

    # URI options
    thumb_url           => 'http://i1.ytimg.com/vi/%s/%s.jpg',
    youtube_video_url   => 'http://www.youtube.com/watch?v=%s',
    playlists_url       => 'http://www.youtube.com/playlist?list=%s',
    youtube_profile_url => 'http://www.youtube.com/user/%s',

    # Subtitle options
    srt_languages => ['en', 'es'],
    captions_dir  => tmpdir(),
    get_captions  => 1,

    # Others
    http_proxy      => undef,
    page            => 1,
    debug           => 0,
    fullscreen      => 0,
    use_lower_cache => 0,

    use_threads            => 0,
    use_threads_for_thumbs => 0,    # not very stable

    hpaned_position    => 420,
    search_channels    => 0,
    search_playlists   => 0,
    thousand_separator => q{,},
    default_thumb      => 'mqdefault',
    downloads_folder   => curdir(),
    browser            => undef,
    terminal           => undef,                 # autodetect it later
    terminal_exec      => q{-e '%s'},
    youtube_viewer     => undef,
    use_xml_fast       => 1,
    youtube_users_file => $youtube_users_file,
);

my %MPLAYER;

# MPlayer variable arguments
sub set_mplayer_arguments {
    my ($cache, $cache_min) = @_;
    $MPLAYER{mplayer_arguments} = sprintf($CONFIG{video_players}{$CONFIG{video_player_selected}}{arg}, $cache, $cache_min);
    $MPLAYER{fullscreen} = $CONFIG{fullscreen} ? $CONFIG{video_players}{$CONFIG{video_player_selected}}{fs} : q{};
    return 1;
}

{
    my $config_documentation = <<"EOD";
#!/usr/bin/perl

# $appname $version - configuration file

EOD

    # Save hash config to file
    sub dump_configuration {
        require Data::Dump;
        open my $config_fh, '>', $config_file
          or do { warn "[!] Can't open '${config_file}' for write: $!"; return };
        my $dumped_config = q{our $CONFIG = } . Data::Dump::pp(\%CONFIG) . "\n";
        print $config_fh $config_documentation, $dumped_config;
        close $config_fh;
    }
}

# Creating config unless it exists
if (not -e $config_file or -z _) {
    dump_configuration();
}

# SIG handlers
foreach my $sig (qw(HUP TERM INT KILL)) {
    $SIG{$sig} = \&on_mainw_destroy;
}

# Locating the .glade interface file and icons dir
my $glade_file = catfile($share_dir, "$execname.glade");
my $icons_path = catdir($share_dir, 'icons');

# Defining GUI
my $gui = 'Gtk2::Builder'->new;
$gui->add_from_file($glade_file);
$gui->connect_signals(undef);

# -------------  Get GUI objects ------------- #
my (
    $mainw,                 $users_list_window,     $help_window,          $prefernces_window,      $login_to_youtube,
    $errors_window,         $details_window,        $about_window,         $treeview,               $liststore,
    $config_view,           $statusbar,             $thumbs_column,        $textview_help,          $sort_combobox,
    $sort_by_time_combobox, $resolution_combobox,   $spin_results,         $users_treeview,         $users_liststore,
    $thumbs_checkbutton,    $search_for_combobox,   $spin_start_with_page, $fullscreen_checkbutton, $notebook,
    $search_entry,          $from_author_entry,     $gif_spinner,          $hbox2,                  $feeds_window,
    $feeds_treeview,        $feeds_liststore,       $feeds_statusbar,      $safesearch_combobox,    $hd_combobox,
    $caption_combobox,      $duration_combobox,     $warnings_window,      $warnings_textview,      $errors_textview,
    $category_id_entry,     $more_options_expander, $cat_treeview,         $cats_liststore,         $dash_checkbutton,
   );

sub get_objects {
    my %objects = (

        # Windows
        '__MAIN__'          => \$mainw,
        'users_list_window' => \$users_list_window,
        'help_window'       => \$help_window,
        'prefernces_window' => \$prefernces_window,
        'errors_window'     => \$errors_window,
        'login_to_youtube'  => \$login_to_youtube,
        'details_window'    => \$details_window,
        'aboutdialog1'      => \$about_window,
        'feeds_window'      => \$feeds_window,
        'warnings_window'   => \$warnings_window,

        # Others
        'treeview1'              => \$users_treeview,
        'feeds_statusbar'        => \$feeds_statusbar,
        'treeview2'              => \$treeview,
        'treeview3'              => \$cat_treeview,
        'feeds_treeview'         => \$feeds_treeview,
        'liststore1'             => \$liststore,
        'liststore2'             => \$users_liststore,
        'liststore4'             => \$cats_liststore,
        'liststore11'            => \$feeds_liststore,
        'textview3'              => \$config_view,
        'warnings_textview'      => \$warnings_textview,
        'errors_textview'        => \$errors_textview,
        'search_entry'           => \$search_entry,
        'statusbar1'             => \$statusbar,
        'treeviewcolumn2'        => \$thumbs_column,
        'textview2'              => \$textview_help,
        'from_author_entry'      => \$from_author_entry,
        'category_id_entry'      => \$category_id_entry,
        'more_options_expander'  => \$more_options_expander,
        'notebook1'              => \$notebook,
        'combobox1'              => \$sort_combobox,
        'combobox2'              => \$sort_by_time_combobox,
        'combobox3'              => \$resolution_combobox,
        'combobox4'              => \$duration_combobox,
        'combobox5'              => \$caption_combobox,
        'combobox6'              => \$hd_combobox,
        'combobox7'              => \$safesearch_combobox,
        'spinbutton1'            => \$spin_results,
        'spinbutton2'            => \$spin_start_with_page,
        'thumbs_checkbutton'     => \$thumbs_checkbutton,
        'search_for_combobox'    => \$search_for_combobox,
        'fullscreen_checkbutton' => \$fullscreen_checkbutton,
        'dash_checkbutton'       => \$dash_checkbutton,
        'gif_spinner'            => \$gif_spinner,
        'hbox2'                  => \$hbox2,
    );

    while (my ($key, $value) = each %objects) {
        ${$value} = $gui->get_object($key);
    }
}
get_objects();

# __WARN__ handle
local $SIG{__WARN__} = sub {
    my $warning = _strip_edge_spaces(join('', @_));
    return if $warning =~ m'\bunhandled exception in callback:';

    $warning = "[" . localtime(time) . "]: " . $warning . "\n";
    print STDERR $warning;

    set_text($warnings_textview, $warning, append => 1);
};

# __DIE__ handle
local $SIG{__DIE__} = sub {
    return if not [caller]->[0] ~~ [qw(main WWW::YoutubeViewer)];
    my $error = join('', @_);
    set_text(
        $errors_textview,
        $error . do {
            if ($error =~ m{^Can't locate (.+?)\.pm\b}) {
                my $module = $1;
                $module =~ s{[/\\]+}{::}g;
                return 1 if $module eq 'XML::Fast';
                "\nThe module $module is required!\n\nTo install the module, just type in terminal:\n\tsudo cpan $module\n";
            }
          }
          . "\n=>> Previous warnings:\n" . get_text($warnings_textview)
    );
    warn $error;
    $errors_window->show;
    return 1;
};

#---------------------- LOAD IMAGES ----------------------#
my $app_icon_pixbuf = 'Gtk2::Gdk::Pixbuf'->new_from_file(catfile($icons_path, "$execname.png"));
my $user_icon_pixbuf = 'Gtk2::Gdk::Pixbuf'->new_from_file_at_size(catfile($icons_path, "user.png"),          16,  16);
my $feed_icon_pixbuf = 'Gtk2::Gdk::Pixbuf'->new_from_file_at_size(catfile($icons_path, "feed_icon.png"),     16,  16);
my $default_thumb    = 'Gtk2::Gdk::Pixbuf'->new_from_file_at_size(catfile($icons_path, "default_thumb.jpg"), 120, 90);
my $animation = 'Gtk2::Gdk::PixbufAnimation'->new_from_file(catfile($icons_path, "spinner.gif"));

# Setting application title and icon
$mainw->set_title("$appname $version");
$mainw->set_icon($app_icon_pixbuf);

# Regular expressions
use WWW::YoutubeViewer::RegularExpressions;

our $CONFIG;
require $config_file;    # Load the configuration file

if (ref $CONFIG ne 'HASH') {
    die "ERROR: Invalid configuration file!\n\t\$CONFIG is not an HASH ref!";
}

# Add audio support to players
while (my ($player, $data) = each %{$CONFIG->{video_players}}) {
    if (not exists $data->{audio} and exists $CONFIG{video_players}{$player}) {
        $data->{audio} = $CONFIG{video_players}{$player}{audio};
    }
}

# Get valid config keys
my @valid_keys = grep { exists $CONFIG{$_} } keys %{$CONFIG};
@CONFIG{@valid_keys} = @{$CONFIG}{@valid_keys};

if (not \%CONFIG ~~ $CONFIG) {
    dump_configuration();
}

# Check for HTTPS support
if (not $CONFIG{prefer_https}) {
    eval { require LWP::Protocol::https };
    if (not $@) {
        $CONFIG{prefer_https} = 1;
    }
}

# Locating a video player
if (not defined $CONFIG{video_player_selected}) {
    foreach my $key (sort keys %{$CONFIG{video_players}}) {
        if (defined(my $abs_player_path = which_command($CONFIG{video_players}{$key}{cmd}))) {
            $CONFIG{video_players}{$key}{cmd} = $abs_player_path;
            $CONFIG{video_player_selected} = $key;
            dump_configuration();
            last;
        }
    }
}

# Locating a terminal
if (not defined $CONFIG{terminal}) {
    foreach my $term (
                      'gnome-terminal', 'lxterminal', 'terminal', 'xfce4-terminal',
                      'sakura',         'lilyterm',   'evilvte',  'superterm',
                      'terminator',     'kterm',      'mlterm',   'mrxvt',
                      'rxvt',           'urxvt',      'termit',   'fbterm',
                      'stjerm',         'yakuake',    'roxterm',  'xterm'
      ) {
        if (defined(my $abs_path = which_command($term))) {
            $CONFIG{terminal} = $abs_path;
            last;
        }
    }

    $CONFIG{terminal} //= $ENV{TERM} || 'xterm';
}

{
    my $i = length $key;
    $key =~ s/(.{$i})(.)/$2$1/g while $i--;
}

# Locating youtube-viewer
$CONFIG{youtube_viewer} //= which_command('youtube-viewer') // 'youtube-viewer';

require WWW::YoutubeViewer;
my $yv_obj = WWW::YoutubeViewer->new(
                                     escape_utf8         => 1,
                                     key                 => $key,
                                     config_dir          => $config_dir,
                                     authentication_file => $authentication_file,
                                    );

if (defined $yv_obj->get_access_token()) {
    show_user_panel();
}
else {
    $statusbar->push(1, 'Not logged');
}

{
    my $client_id     = '991455593101.apps.googleusercontent.com';
    my $client_secret = 'YcxxWCCbBwIr-IhUDCanrp41';
    my $redirect_uri  = 'urn:ietf:wg:oauth:2.0:oob';

    $yv_obj->set_client_id($client_id);
    $yv_obj->set_client_secret($client_secret);
    $yv_obj->set_redirect_uri($redirect_uri);
}

require WWW::YoutubeViewer::Utils;
my $yv_utils = WWW::YoutubeViewer::Utils->new(thousand_separator => $CONFIG{thousand_separator},
                                              youtube_url_format => $CONFIG{youtube_video_url},);

# Set config file to $CONFIG hash ref
sub apply_configuration {

    # Fullscreen mode
    $fullscreen_checkbutton->set_active($CONFIG{fullscreen});

    # DASH mode
    $dash_checkbutton->set_active($CONFIG{dash_support});

    # Others
    foreach my $option_name (
                             qw(
                             caption results duration
                             author orderby region category
                             categories_language safe_search
                             page debug time prefer_https http_proxy
                             )
      ) {
        if (defined $CONFIG{$option_name}) {
            my $code      = \&{"WWW::YoutubeViewer::set_$option_name"};
            my $value     = $CONFIG{$option_name};
            my $set_value = $yv_obj->$code($value);

            if (not defined($set_value) or $set_value ne $value) {
                warn "[!] Invalid value <$value> for option <$option_name>.\n";
            }
        }
    }

    if (defined $CONFIG{use_xml_fast}) {
        $yv_obj->set_use_internal_xml_parser(not $CONFIG{use_xml_fast});
    }

    # Spin button results setting config value
    $spin_results->set_value($CONFIG{results});

    # Spin button start with page
    $spin_start_with_page->set_value($CONFIG{page});

    # Checking thumbs button
    $thumbs_checkbutton->set_active($CONFIG{show_thumbs});

    # Setup threads
    if ($CONFIG{use_threads}) {
        set_threads();
    }

    # Set the "More options" expander
    $more_options_expander->set_expanded($CONFIG{active_more_options_expander});

    # Combo boxes setting config value
    $sort_combobox->set_active($CONFIG{active_sort_by_combobox});
    $sort_by_time_combobox->set_active($CONFIG{active_time_sort_by_combobox});
    $resolution_combobox->set_active($CONFIG{active_resolution_combobox});
    $search_for_combobox->set_active($CONFIG{active_search_for});
    $hd_combobox->set_active($CONFIG{active_hd_combobox});
    $caption_combobox->set_active($CONFIG{active_caption_combobox});
    $duration_combobox->set_active($CONFIG{active_duration_combobox});
    $safesearch_combobox->set_active($CONFIG{active_safe_search_combobox});

    # Resize the main window
    $mainw->set_default_size(split(/x/i, $CONFIG{mainw_size}, 2));
    $mainw->reshow_with_initial_size;

    if ($CONFIG{mainw_maximized}) {
        $mainw->maximize();
    }

    if ($CONFIG{mainw_fullscreen}) {
        maximize_unmaximize_mainw();
    }

    # Set HPaned position
    $hbox2->set_position($CONFIG{hpaned_position});

    # Select text from text entry
    $search_entry->select_region(0, -1);
}

# Apply the configuration file
apply_configuration();

# YouTube usernames
my %users_table = map { lc($_) => $_ } (
                        'KhanAcademy',  'VSauce',       'Gotbletu',      'ScienceChannel', 'SpaceRip',      'TEDtalksDirector',
                        'MIT',          'SixtySymbols', 'SciShow',       'NumberPhile',    'ComputerPhile', 'UCBerkeley',
                        'UCTelevision', 'BigThink',     'ProfessorFink', 'UCTVSeminars',   '1Veritasium',   'MinutePhysics'
                                       );
set_usernames();

sub donate {
    my $url = 'https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=75FUVBE6Q73T8';
    system "xdg-open \Q$url\E &";
}

# ---------------- Threads ---------------- #
my ($queue, $jobs);

sub set_threads {
    return 1 if defined $queue;

    $gif_spinner->set_from_animation($animation);
    warn "* Initializing threads...\n";

    require threads;
    require Thread::Queue;

    no warnings 'redefine';
    state $lwp_get = \&{WWW::YoutubeViewer::lwp_get};
    *{WWW::YoutubeViewer::lwp_get} = \&threads_lwp_get;

    $queue = 'Thread::Queue'->new;
    $jobs  = 'Thread::Queue'->new;
    threads->create(
        sub {
            while (defined(my $url = $jobs->dequeue)) {
                $queue->enqueue($yv_obj->$lwp_get($url) || q{});
            }
        }
    )->detach();
}

sub threads_lwp_get {
    my ($self, $url) = @_;

    set_threads() unless defined $queue;
    $gif_spinner->show;

    if (not defined $url) {
        $url = $self;
    }

    $jobs->enqueue($url);
    while ($queue->pending == 0) {
        'Gtk2'->main_iteration;
        if (defined(my $lwp_result = $queue->dequeue_nb)) {
            $gif_spinner->hide;
            return $lwp_result;
        }
    }

    undef $queue;
    undef $jobs;
}

# Set text to a 'textview' object
sub set_text {
    my ($object, $text, %args) = @_;
    my $object_buffer = $object->get_buffer;

    if ($args{append}) {
        my $iter = $object_buffer->get_end_iter;
        $object_buffer->insert($iter, $text);
    }
    else {
        $object_buffer->set_text($text);
    }
    $object->set_buffer($object_buffer);
    return 1;
}

# Get text from a 'textview' object
sub get_text {
    my ($object)      = @_;
    my $object_buffer = $object->get_buffer;
    my $start_iter    = $object_buffer->get_start_iter;
    my $end_iter      = $object_buffer->get_end_iter;
    return $object_buffer->get_text($start_iter, $end_iter, undef);
}

sub new_image_from_pixbuf {
    my ($object_name, $pixbuf) = @_;
    my $object = $gui->get_object($object_name) // return;
    return scalar($object->new_from_pixbuf($pixbuf));
}

# Setting application icons
{
    $gui->get_object('username_list')->set_image(new_image_from_pixbuf('icon_from_pixbuf', $user_icon_pixbuf));
    $gui->get_object('channels_button')->set_image(new_image_from_pixbuf('icon_from_pixbuf', $user_icon_pixbuf));
    $gui->get_object('button6')->set_image(new_image_from_pixbuf('icon_from_pixbuf', $feed_icon_pixbuf));
    $gui->get_object('button23')->set_image(new_image_from_pixbuf('icon_from_pixbuf', $feed_icon_pixbuf));
}

# Treeview signals
{
    $treeview->signal_connect('button_press_event', \&menu_popup);
    $users_treeview->signal_connect('button_press_event', \&users_menu_popup);
}

# Menu popup
sub menu_popup {
    my ($treeview, $event) = @_;

    #return 0 unless $treeview->get_selection->get_selected();

    if ($event->button != 3) {
        return 0;
    }
    my $menu = $gui->get_object('detailsmenu');
    $menu->popup(undef, undef, undef, undef, $event->button, $event->time);
    return 0;
}

sub users_menu_popup {
    my ($treeview, $event) = @_;
    if ($event->button != 3) {
        return 0;
    }
    my $menu = $gui->get_object('user_option_menu');
    $menu->popup(undef, undef, undef, undef, $event->button, $event->time);
    return 0;
}

# Setting help text
set_text(
    $textview_help, <<"HELP_TEXT"
* Links
    main website: https://code.google.com/p/trizen/
    development website: https://github.com/trizen/youtube-viewer
    developer's website: http://trizen.go.ro

* Developer
    Trizen <trizenx\@gmail.com>

* Contributor
    Ovidiu D. Ni\x{21b}an <nitanovidiu\@gmail.com>

* Config file
    $config_file

* Users list
    $CONFIG{youtube_users_file}

* Key binds

-Main window
CTRL+H : help window
CTRL+L : login window
CTRL+P : preferences window
CTRL+U : username list window
CTRL+Y : CLI youtube viewer
CTRL+D : video details window
CTRL+F : show feeds window
CTRL+W : show the warnings window
CTRL+G : show videos favorited by the author of a selected video
CTRL+R : show related videos for a selected video
CTRL+M : show videos from the author of a selected video
CTRL+K : show playlists from the author of a selected video
CTRL+S : add the author name of a selected video into the users list
CTRL+Q : close the application
DEL : remove the selected video from the list
F11 : minimize-maximize the main window

-Preferences window
CTRL+S : save the configuration

-Other windows
ESC : close the focused window

* Video tops

Valid categories are:
    @{[@{WWW::YoutubeViewer::categories_IDs}]}

Valid region IDs are:
    @{[@{WWW::YoutubeViewer::region_IDs}]}

* Configuration

use_threads
    1 to use threads when getting the XML content

use_threads_for_thumbs
    1 to use threads when getting the thumbnails (not recommended!)

cache & cache_min
    this cache values are used for resolutions higher than 480p

lower_cache & lower_cache_min
    this cache values are used for resolutions lower than 720p

use_lower_cache
    1 to always use the lower_cache (for slow connections)

show_thumbs
    1 to show YouTube video thumbnails (may be slow)

clear_list
    1 to clean the treeview list before each search

srt_languages
    a list with the preferred subtitle languages

captions_dir
    the directory where to store the closed captions from YouTube (.srt files)

* Knowledge:
    http://code.google.com/intl/ro/apis/youtube/2.0/developers_guide_protocol_api_query_parameters.html
HELP_TEXT
        );

# ------------------- Accels ------------------- #

# Main window
my $accel = Gtk2::AccelGroup->new;
$accel->connect(ord('h'), ['control-mask'], ['visible'], \&show_help_window);
$accel->connect(ord('l'), ['control-mask'], ['visible'], \&show_login_to_youtube_window);
$accel->connect(ord('p'), ['control-mask'], ['visible'], \&show_preferences_window);
$accel->connect(ord('q'), ['control-mask'], ['visible'], \&on_mainw_destroy);
$accel->connect(ord('u'), ['control-mask'], ['visible'], \&show_users_list_window);
$accel->connect(ord('y'), ['control-mask'], ['visible'], \&run_cli_youtube_viewer);
$accel->connect(ord('d'), ['control-mask'], ['visible'], \&show_details_window);
$accel->connect(ord('f'), ['control-mask'], ['visible'], \&show_feeds_window);
$accel->connect(ord('s'), ['control-mask'], ['visible'], \&add_user_to_favorites);
$accel->connect(ord('r'), ['control-mask'], ['visible'], \&show_related_videos);
$accel->connect(ord('g'), ['control-mask'], ['visible'], \&get_user_favorited_videos);
$accel->connect(ord('m'), ['control-mask'], ['visible'], \&show_more_videos_from_username);
$accel->connect(ord('k'), ['control-mask'], ['visible'], \&show_playlists_from_username);
$accel->connect(ord('w'), ['control-mask'], ['visible'], \&show_warnings_window);
$accel->connect(0xffff,   ['lock-mask'],    ['visible'], \&delete_selected_row);
$accel->connect(0xffc8,   ['lock-mask'],    ['visible'], \&maximize_unmaximize_mainw);
$mainw->add_accel_group($accel);

# Other windows (ESC key to close them)
$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b, ['lock-mask'], ['visible'], \&hide_users_list_window);
$users_list_window->add_accel_group($accel);

$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b, ['lock-mask'], ['visible'], \&hide_feeds_window);
$feeds_window->add_accel_group($accel);

$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b,   ['lock-mask'],    ['visible'], \&hide_preferences_window);
$accel->connect(ord('s'), ['control-mask'], ['visible'], \&save_configuration);
$prefernces_window->add_accel_group($accel);

$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b, ['lock-mask'], ['visible'], \&hide_help_window);
$help_window->add_accel_group($accel);

$accel = Gtk2::AccelGroup->new;
$accel->connect(0xff1b, ['lock-mask'], ['visible'], \&hide_details_window);
$details_window->add_accel_group($accel);

# ------------------ Authentication ------------------ #

sub show_user_panel {
    change_subscription_page(1);
    $statusbar->push(1, "Logged.");
    return 1;
}

{
    my $get_code_url = $yv_obj->get_accounts_oauth_url();

    # Setting the URL to get the authentication key
    $gui->get_object('get_auth_link_button')->set_uri($get_code_url);

    sub authenticate {
        my $code = $gui->get_object('auth_token_entry')->get_text;

        hide_login_to_youtube_window();

        if ($code ne q{}) {
            my $json_data = $yv_obj->oauth_login($code) // return;

            say $json_data if $yv_obj->get_debug;
            my $info = $yv_utils->basic_json_parser($json_data);

            if (defined $info->{access_token}) {

                $yv_obj->set_access_token($info->{access_token})   // return;
                $yv_obj->set_refresh_token($info->{refresh_token}) // return;

                if ($gui->get_object('login_check_button')->get_active) {
                    $yv_obj->set_authentication_file($authentication_file);
                    $yv_obj->save_authentication_tokens()
                      or warn "Can't store the authentication tokens: $!";
                }
                else {
                    $yv_obj->set_authentication_file();
                }

                show_user_panel();
                return 1;
            }
        }
        return;
    }
}

# ------------------ Showing/Hidding windows ------------------ #

# Main window
sub maximize_unmaximize_mainw {
    state $maximized = 0;
    $maximized++ % 2
      ? $mainw->unfullscreen
      : $mainw->fullscreen;
}

# Users list window
sub show_users_list_window {
    $users_list_window->show;
    return 1;
}

sub hide_users_list_window {
    $users_list_window->hide;
    return 1;
}

# Help window
sub show_help_window {
    $help_window->show;
    return 1;
}

sub hide_help_window {
    $help_window->hide;
    return 1;
}

# Warnings window

sub show_warnings_window {
    $warnings_window->show;
    return 1;
}

sub hide_warnings_window {
    $warnings_window->hide;
    return 1;
}

# About Window
sub show_about_window {
    $about_window->set_program_name("$appname $version");
    $about_window->set_logo($app_icon_pixbuf);
    $about_window->set_resizable(1);
    $about_window->show;
    return 1;
}

sub hide_about_window {
    $about_window->hide;
    return 1;
}

# Error window
sub hide_errors_window {
    $errors_window->hide;
    return 1;
}

# Login window
sub show_login_to_youtube_window {
    $login_to_youtube->show;
    return 1;
}

sub hide_login_to_youtube_window {
    $login_to_youtube->hide;
    return 1;
}

# Details window
sub show_details_window {
    my ($code, $iter) = get_selected_video_code() or return;

    #return unless $code =~ /$valid_video_id_re/;
    $details_window->show;
    set_video_details($code, $iter);
    return 1;
}

sub hide_details_window {
    $details_window->hide;
    return 1;
}

sub set_comments {
    my $videoID = get_selected_video_code() or return;

    return unless $videoID =~ /$valid_video_id_re/;

    $feeds_liststore->clear;
    print_comments($yv_obj->get_video_comments($videoID));
}

# Feeds window
sub show_feeds_window {
    my $videoID = get_selected_video_code() or return;

    return unless $videoID =~ /$valid_video_id_re/;

    $feeds_window->show;
    $feeds_statusbar->pop(0);

    print_comments($yv_obj->get_video_comments($videoID));

    return 1;
}

sub hide_feeds_window {
    $feeds_liststore->clear;
    $feeds_window->hide;
    return 1;
}

# Preferences window
sub show_preferences_window {
    require Data::Dump;
    get_main_window_size();
    my $config_view_buffer = $config_view->get_buffer;
    $config_view_buffer->set_text(Data::Dump::dump(\%CONFIG));
    $config_view->set_buffer($config_view_buffer);
    $prefernces_window->show;
    return 1;
}

sub hide_preferences_window {
    $prefernces_window->hide;
    return 1;
}

# Save plaintext config to file
sub save_configuration {
    my $config = get_text($config_view);

    my $hash_ref = eval $config;
    die $@ if $@;

    %CONFIG = %{$hash_ref};
    dump_configuration();

    apply_configuration();
    hide_preferences_window();
    return 1;
}

sub delete_selected_row {
    my (undef, $iter) = get_selected_video_code() or return;
    $liststore->remove($iter);
    return 1;
}

# Combo boxes changes
sub combobox_sort_by_changed {
    $CONFIG{active_sort_by_combobox} = $sort_combobox->get_active;
    $yv_obj->set_orderby($CONFIG{orderby} = $sort_combobox->get_active_text);
}

sub combobox_time_sort_by_changed {
    $CONFIG{active_time_sort_by_combobox} = $sort_by_time_combobox->get_active;
    $yv_obj->set_time($CONFIG{time_sort} = $sort_by_time_combobox->get_active_text);
}

sub combobox_resolution_changed {
    $CONFIG{active_resolution_combobox} = $resolution_combobox->get_active;
    my $res = $resolution_combobox->get_active_text;
    $CONFIG{resolution} = $res =~ /^(\d+)p\z/ ? $1 : $res;
}

sub combobox_search_for_changed {
    state $labels = [qw(videos playlists channels disco_videos)];
    $CONFIG{active_search_for} = $search_for_combobox->get_active;
    $CONFIG{"search_$_"} = 0 for @{$labels};
    $CONFIG{"search_" . $search_for_combobox->get_active_text} = 1;
}

sub combobox_safesearch_changed {
    $CONFIG{active_safe_search_combobox} = $safesearch_combobox->get_active;
    $yv_obj->set_safe_search($CONFIG{safe_search} = $safesearch_combobox->get_active_text);
}

sub combobox_duration_changed {
    my $text = $duration_combobox->get_active_text;
    $CONFIG{active_duration_combobox} = $duration_combobox->get_active;
    $yv_obj->set_duration($CONFIG{duration} = $text eq 'default' ? undef : $text);
}

sub combobox_caption_changed {
    my $text = $caption_combobox->get_active_text;
    $CONFIG{active_caption_combobox} = $caption_combobox->get_active;
    $yv_obj->set_caption($CONFIG{only_videos_with_caption} = $text eq 'default' ? undef : $text);
}

sub combobox_hd_changed {
    my $text = $hd_combobox->get_active_text;
    $CONFIG{active_hd_combobox} = $hd_combobox->get_active;
    $yv_obj->set_hd($CONFIG{only_hd_videos} = $text eq 'default' ? undef : $text);
}

# Spin buttons changes
sub spin_results_per_page_changed {
    $yv_obj->set_results($CONFIG{results} = $spin_results->get_value);
}

sub spin_start_with_page_changed {
    $yv_obj->set_page($CONFIG{page} = $spin_start_with_page->get_value);
}

# Fullscreen mode
sub toggled_mplayer_fullscreen {
    $CONFIG{fullscreen} = $fullscreen_checkbutton->get_active() || 0;
}

# DASH mode
sub toggled_dash_support {
    $CONFIG{dash_support} = $dash_checkbutton->get_active() || 0;
}

# Check buttons toggles
sub thumbs_checkbutton_toggled {
    $CONFIG{show_thumbs} = ($_[0]->get_active() || 0);
    $thumbs_column->set_visible($CONFIG{show_thumbs});
}

# "More options" expander
sub activate_more_options_expander {
    $CONFIG{active_more_options_expander} = $_[0]->get_expanded() ? 0 : 1;
}

# Get main window size
sub get_main_window_size {
    $CONFIG{mainw_size} = join('x', $mainw->get_size);
}

sub main_window_state_events {
    my (undef, $state) = @_;

    my $windowstate = $state->new_window_state();
    my @states = split(' ', $windowstate);

    $CONFIG{mainw_maximized}  = 'maximized'  ~~ \@states ? 1 : 0;
    $CONFIG{mainw_fullscreen} = 'fullscreen' ~~ \@states ? 1 : 0;

    return 1;
}

sub add_category_header {
    my ($text) = @_;
    my $iter = $cats_liststore->append;
    $cats_liststore->set($iter, 0, "<big><b>\t$text</b></big>");
    return 1;
}

sub append_categories {
    my ($categories, $type) = @_;

    return if ref $categories ne 'ARRAY';

    foreach my $category (@{$categories}) {
        my $label = $category->{label};
        my $term  = $category->{term};

        $label =~ s{&}{&amp;}g;

        my $iter = $cats_liststore->append;
        $cats_liststore->set($iter, 0, $label);
        $cats_liststore->set($iter, 1, $term);
        $cats_liststore->set($iter, 2, $feed_icon_pixbuf);
        $cats_liststore->set($iter, 3, $type);
    }
    return 1;
}

{
    # Standard categories:
    add_category_header("Categories");
    append_categories($yv_obj->get_categories(), 'cat');
    append_categories([{label => 'Movies', term => 'Movies'}, {label => 'Trailers', term => 'Trailers'}], 'cat');

    # EDU categories:
    add_category_header("EDU Categories");
    append_categories($yv_obj->get_educategories(), 'edu-cat');
}

my $tops_liststore = $gui->get_object('liststore6');
my $tops_treeview  = $gui->get_object('treeview4');

sub add_top_row {
    my ($top_name, $top_type) = @_;
    (my $top_label = ucfirst $top_name) =~ tr/_/ /;
    my $iter = $tops_liststore->append;
    $tops_liststore->set($iter, 0, $top_label);
    $tops_liststore->set($iter, 1, $feed_icon_pixbuf);
    $tops_liststore->set($iter, 2, $top_name);
    $tops_liststore->set($iter, 3, $top_type);
}

sub set_youtube_tops {
    my ($top_time, $main_label) = @_;

    my $iter = $tops_liststore->append;
    $tops_liststore->set($iter, 0, "<big><b>\t$main_label</b></big>");

    my $i = 0;
    foreach my $top_name (@{WWW::YoutubeViewer::feeds_IDs}) {

        my $top_time_copy = $top_time;
        if (++$i ~~ [3, 5, 8, 9]) {    # doesn't support the 'time' option
            $top_time_copy = $top_time eq 'today' ? q{} : next;
        }

        add_top_row($top_name, $top_time_copy);
    }
}

set_youtube_tops('today',    'Today tops');
set_youtube_tops('all_time', 'All time tops');

{
    my $iter = $tops_liststore->append;
    $tops_liststore->set($iter, 0, "<big><b>\tMovies</b></big>");
    foreach my $movie_top (@{WWW::YoutubeViewer::movie_IDs}) {
        add_top_row($movie_top, 'movies');
    }
}

# ------------ Usernames list window ------------ #
sub set_usernames {
    if (-e $CONFIG{youtube_users_file}) {
        if (open my $fh, '<', $CONFIG{youtube_users_file}) {
            while (defined(my $user = <$fh>)) {
                chomp $user;
                $users_table{lc $user} = $user;
            }
            close $fh;
        }
    }
    foreach my $user (sort { lc $a cmp lc $b } values %users_table) {
        my $iter = $users_liststore->append;
        $users_liststore->set($iter, 0, $user);
        $users_liststore->set($iter, 1, $user_icon_pixbuf);
    }
}

sub add_username {
    my $user = $gui->get_object('username_entry')->get_text;
    $users_table{lc $user} = $user;
    my $iter = $users_liststore->append;
    $users_liststore->set($iter, 0, $user);
    $users_liststore->set($iter, 1, $user_icon_pixbuf);
}

sub add_user_to_favorites {
    my $user = get_username_for_selected_video() or return;
    $gui->get_object('username_entry')->set_text($user);
    add_username();
    $feeds_statusbar->push(0, "Successfully added '${user}' into the username list (see: Menu->Users)");
}

sub remove_selected_user {
    my $iter = $users_treeview->get_selection->get_selected;
    my $selected_user = $users_liststore->get($iter, 0);
    delete $users_table{lc $selected_user};
    $users_liststore->remove($iter);
}

sub save_usernames_to_file {
    open my $fh, '>', $CONFIG{youtube_users_file} or return 0;
    local $, = "\n";
    print $fh sort { lc $a cmp lc $b } values %users_table;
    close $fh;
}

# ----- My panel settings ----- #
sub log_out {
    change_subscription_page(0);

    unlink $authentication_file
      or warn "Can't unlink: `$authentication_file' -> $!";

    $yv_obj->set_access_token();
    $yv_obj->set_refresh_token();

    $statusbar->push(1, "Not logged.");
    return 1;
}

sub change_subscription_page {
    my ($value) = @_;
    foreach my $object (qw(subsc_scrollwindow subsc_label)) {
        $value
          ? $gui->get_object($object)->show
          : $gui->get_object($object)->hide;
    }
    return 1;
}

{
    no strict 'refs';
    foreach my $feed_name (@{WWW::YoutubeViewer::feed_methods}) {
        *{__PACKAGE__ . '::' . $feed_name} = sub {
            my $user   = (@_ && !ref $_[0]) ? shift() : $gui->get_object('news_users')->get_text;
            my $code   = \&{"WWW::YoutubeViewer::get_$feed_name"};
            my $videos = $yv_obj->$code($user);

            if (defined $videos) {
                $liststore->clear if $CONFIG{clear_list};
                print_videos($videos);
            }
        };
    }
}

sub get_selected_video_code {
    my (%options) = @_;
    my $iter = $treeview->get_selection->get_selected or return;
    unless ($options{force}) {
        return unless defined $liststore->get($iter, 4);
    }
    my $code = $liststore->get($iter, 3);
    return wantarray ? ($code, $iter) : $code;
}

# Check if keywords are actually something else
sub check_keywords {
    given ($_[0]) {
        when (/$get_video_id_re/o) {
            my $info = $yv_obj->get_video_info($+{video_id});
            play_videos($info->{results});
        }
        when (/$get_playlist_id_re/o) {
            list_playlist($+{playlist_id});
        }
        when (/$get_course_id_re/) {
            print_videos($yv_obj->get_video_lectures_from_course($+{course_id}));
        }
        default {
            return;
        }
    }
    return 1;
}

sub search {
    my $keywords = $search_entry->get_text();

    return if check_keywords($keywords);

    $liststore->clear if $CONFIG{clear_list};
    $yv_obj->set_author($from_author_entry->get_text);
    $yv_obj->set_category($category_id_entry->get_text);

    if ($CONFIG{search_playlists}) {
        print_playlists($yv_obj->search_for_playlists($keywords));
    }
    elsif ($CONFIG{search_channels}) {
        print_channels($yv_obj->search_channels($keywords));
    }
    elsif ($CONFIG{search_disco_videos}) {
        if (defined(my $videos = $yv_obj->get_disco_videos([$keywords]))) {
            print_videos($videos);
        }
        else {
            die "[!] No disco video results!\n";
        }
    }
    else {
        print_videos($yv_obj->search($keywords));
    }

    return 1;
}

#---------------------- PRINT VIDEO RESULTS ----------------------#
sub encode_entities {
    my ($text) = @_;
    return q{} if not defined $text;
    $text =~ s/&/&amp;/g;
    $text =~ s/</&lt;/g;
    $text =~ s/>/&gt;/g;
    return $text;
}

sub decode_entities {
    require HTML::Entities;
    return HTML::Entities::decode_entities($_[0]);
}

sub get_next_page_spaces {
    $CONFIG{show_thumbs} ? "\t" x 10 : "\t" x 20;
}

sub get_code {
    my ($code, $iter) = get_selected_video_code(force => 1) or return;

    $code =~ /$valid_playlist_id_re/
      ? do { list_playlist($code) }
      : $code =~ m{^https?://} ? do {

        my $search_type = $liststore->get($iter, 5);

        if ($yv_obj->get_debug) {
            say "** SEARCH TYPE: $search_type" if defined $search_type;
        }

        my %args;
        if (defined $search_type and $search_type ne q{}) {
            $args{$search_type} = 1;
        }

        my $results = $yv_obj->next_page($code, %args);

        if (@{$results->{results}}) {
            $liststore->set(
                $iter, 0,
                get_next_page_spaces() . do {
                    $code =~ /[&?]start-index=(\d+)/;
                    '<big><b>Page: ' . ((($1 - 1) / $CONFIG{results}) + 2) . '</b></big>';
                  }
            );
            $liststore->set($iter, 3, q{});
        }
        else {
            $liststore->remove($iter);
            die "This is the last page!\n";
        }

            $args{playlists}           ? print_playlists($results)
          : $args{channels}            ? print_channels($results)
          : $args{channel_suggestions} ? print_channels($results)
          :                              print_videos($results);
      }
      : $code =~ /^username=(.+)/     ? videos_from_username($1)
      : $code =~ /$valid_video_id_re/ ? play_videos([{videoID => $code}])
      :                                 return;
}

sub _make_row_description {
    (my $row_description = join(q{ }, split(q{ }, $_[0]))) =~ s/(.)\1{3,}/$1/sg;
    return $row_description;
}

sub _append_next_page {
    my ($url, $search_type) = @_;
    my $iter = $liststore->append;
    $liststore->set($iter, 0, get_next_page_spaces() . "<big><b>NEXT PAGE</b></big>");
    $liststore->set($iter, 3, $url);
    $liststore->set($iter, 5, $search_type);
}

sub _get_pixbuf_thumbnail {
    my ($url) = @_;

    my $thumbnail =
      $CONFIG{use_threads_for_thumbs}
      ? threads_lwp_get($url)
      : $yv_obj->lwp_get($url);

    my $pixbuf;
    if ($thumbnail) {
        my $pixbufloader = 'Gtk2::Gdk::PixbufLoader'->new;
        $pixbufloader->set_size(120, 90);
        $pixbufloader->write($thumbnail);
        $pixbuf = $pixbufloader->get_pixbuf;
        $pixbufloader->close;
    }
    else {
        $pixbuf = $default_thumb;
    }

    return $pixbuf;
}

sub print_videos {
    my ($results) = @_;

    my $url    = $results->{url};
    my $videos = $results->{results};

    unless (@{$videos}) {
        die "No video results...\n";
    }

    hide_feeds_window();
    $search_for_combobox->set_active(0);

    foreach my $video (@{$videos}) {
        my $iter = $liststore->append;

        my $row_description = $video->{description} || 'No description available...';
        $liststore->set($iter, 4, $row_description);
        $liststore->set($iter, 6, $video->{author});
        $row_description = _make_row_description($row_description);

        $liststore->set($iter, 3, $video->{videoID});
        $liststore->set(
                        $iter,
                        0,
                        "<big><b>"
                          . encode_entities($video->{title} // 'Unknown')
                          . "</b></big>\n"
                          . "<b>$symbols{up_arrow}\t</b> "
                          . $yv_utils->set_thousands($video->{likes}) . "\n"
                          . "<b>$symbols{down_arrow}\t</b> "
                          . $yv_utils->set_thousands($video->{dislikes}) . "\n"
                          . "<b>$symbols{category}\t</b> "
                          . encode_entities($video->{category} // 'Unknown') . "\n"
                          . "<b>$symbols{face}\t</b> "
                          . $video->{author} . "\n" . "<i>"
                          . encode_entities($row_description) . "</i>"
                       );

        $liststore->set(
            $iter, 2,
            "<b>$symbols{play}\t</b> "
              . $yv_utils->format_time($video->{duration}) . "\n"
              . "<b>$symbols{average}\t</b> "
              . sprintf('%.2f', ($video->{rating} || 0)) . "\n"
              . "<b>$symbols{views}\t</b> "
              . $yv_utils->set_thousands($video->{views})
              . do {
                defined $video->{published}
                  ? "\n" . "<b>$symbols{right_arrow}\t </b>" . $yv_utils->format_date($video->{published})
                  : q{};
              }
        );

        if ($CONFIG{show_thumbs}) {
            my $thumb_url = sprintf($CONFIG{thumb_url}, $video->{videoID}, $CONFIG{default_thumb});
            my $pixbuf = _get_pixbuf_thumbnail($thumb_url);
            $liststore->set_value($iter, 1, $pixbuf);
        }
    }

    _append_next_page($url);
}

sub print_channel_suggestions {
    my $results = $yv_obj->get_channel_suggestions();
    $liststore->clear if $CONFIG{clear_list};
    print_channels($results, 'channel_suggestions');
}

sub print_channels {
    my ($results, $type) = @_;

    my $url      = $results->{url};
    my $channels = $results->{results};

    unless (@{$channels}) {
        die "No channel results...\n";
    }

    $search_for_combobox->set_active(1);

    foreach my $channel (@{$channels}) {
        my $iter = $liststore->append;
        my $row_description = $channel->{summary} || 'No description available...';

        $liststore->set($iter, 4, $row_description);
        $row_description = _make_row_description($row_description);

        $channel->{title} =~ s{<.*?>}{}sg;
        $channel->{title} = decode_entities($channel->{title})
          if $channel->{title} =~ /&#?\w/;

        $liststore->set($iter, 3, "username=$channel->{author}");
        $liststore->set(
                        $iter, 0,
                        '<big><b>'
                          . encode_entities($channel->{title})
                          . "</b></big>\n\n"
                          . "<b>$symbols{face}\t</b> "
                          . $channel->{name} . "\n"
                          . "<b>$symbols{heart}\t</b> "
                          . $yv_utils->set_thousands($channel->{subscribers}) . "\n"
                          . (
                             exists($channel->{views})
                             ? ("<b>$symbols{views}\t</b> " . $yv_utils->set_thousands($channel->{views}))
                             : ("<b>$symbols{play}\t</b> " . $yv_utils->set_thousands($channel->{videos}))
                            )
                          . "\n\n<i>"
                          . encode_entities($row_description) . '</i>'
                       );

        $liststore->set($iter, 2, "<b>$symbols{crazy_arrow}\t</b> " . $yv_utils->format_date($channel->{updated}) . "\n");

        if ($CONFIG{show_thumbs}) {
            my $pixbuf = _get_pixbuf_thumbnail($channel->{thumbnail});
            $liststore->set_value($iter, 1, $pixbuf);
        }
    }

    _append_next_page($url, $type // 'channels');
}

#---------------------- PRINT PLAYLISTS ----------------------#
sub print_playlists {
    my ($results) = @_;

    my $url       = $results->{url};
    my $playlists = $results->{results};

    unless (@{$playlists}) {
        die "No playlist results...\n";
    }

    hide_feeds_window();
    $search_for_combobox->set_active(2);

    foreach my $playlist (@{$playlists}) {

        next if $playlist->{count} == 0;

        my $iter = $liststore->append;
        my $row_description = $playlist->{summary} || 'No description available...';

        $liststore->set($iter, 4, $row_description);
        $row_description = _make_row_description($row_description);

        $liststore->set($iter, 6, $playlist->{author});
        $liststore->set($iter, 3, $playlist->{playlistID});
        $liststore->set(
                        $iter,
                        0,
                        '<big><b>'
                          . encode_entities($playlist->{'title'})
                          . "</b></big>\n\n"
                          . "<b>$symbols{face}\t</b> "
                          . $playlist->{name} . "\n"
                          . "<b>$symbols{right_arrow}\t</b> "
                          . $yv_utils->format_date($playlist->{published}) . "\n"
                          . "<b>$symbols{crazy_arrow}\t</b> "
                          . $yv_utils->format_date($playlist->{updated}) . "\n\n" . '<i>'
                          . encode_entities($row_description) . '</i>'
                       );

        $liststore->set($iter, 2, "<b>$symbols{play}\t</b> " . $yv_utils->set_thousands($playlist->{count}) . "\n");

        if ($CONFIG{show_thumbs}) {
            my $pixbuf = _get_pixbuf_thumbnail($playlist->{thumbnail});
            $liststore->set_value($iter, 1, $pixbuf);
        }
    }

    _append_next_page($url, 'playlists');
}

sub list_playlist {
    my ($playlistID) = @_;

    my $info = $yv_obj->get_videos_from_playlist($playlistID);
    if (@{$info->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($info);
        return 1;
    }
    else {
        die "[!] Inexistent playlist...\n";
    }
    return;
}

# Get playlists from username
sub playlists_from_selected_username {
    my $iter = $users_treeview->get_selection->get_selected;
    playlists_from_username($users_liststore->get($iter, 0));
}

sub videos_from_selected_username {
    my $iter = $users_treeview->get_selection->get_selected;
    my $username = $users_liststore->get($iter, 0);
    videos_from_username($username);
}

sub get_username_from_list {
    hide_users_list_window();
    videos_from_selected_username();
}

sub videos_from_text_entry_username {
    videos_from_username($_[0]->get_text);
}

# Get videos from username
sub videos_from_username {
    my ($username) = @_;
    is_valid_username($username) or return;

    my $videos = $yv_obj->get_videos_from_username($username);
    if (@{$videos->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($videos);
    }
    else {
        die "No video uploaded by: <$username>\n";
    }
    return 1;
}

sub favorited_videos_from_username {
    my $username = ref $_[0] ? $_[0]->get_text : $_[0];

    is_valid_username($username) or return;
    my $videos = $yv_obj->get_favorited_videos_from_username($username);
    if (@{$videos->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($videos);
    }
    else {
        die "No video favorited by username: <$username>\n";
    }
    return 1;
}

sub subscription_videos_from_username {
    my $username = ref $_[0] ? $_[0]->get_text : $_[0];
    is_valid_username($username) or return;
    newsubscriptionvideos($username);
}

sub is_valid_username {
    my ($username) = @_;
    die "Invalid username: <$username>\n"
      unless $username =~ /$valid_username_re/;
    return 1;
}

sub playlists_from_username {
    my $username = ref $_[0] ? $_[0]->get_text : $_[0];
    is_valid_username($username) or return;

    my $playlists = $yv_obj->get_playlists_from_username($username);
    if (@{$playlists->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_playlists($playlists);
    }
    else {
        die "No playlists found.\n";
    }
}

sub _strip_edge_spaces {
    my ($text) = @_;
    $text =~ s/^\s+//;
    return unpack 'A*', $text;
}

sub get_streaming_url {
    my ($video_id) = @_;

    my @info = $yv_obj->get_streaming_urls($video_id);

    my (@urls, @captions);
    foreach my $entry (@info) {
        if (exists $entry->{url} and exists $entry->{itag}) {
            push @urls, $entry;
        }
        elsif (exists $entry->{lc} and exists $entry->{u}) {
            push @captions, $entry;
        }
    }

    # Download the closed-captions
    my $srt_file;
    if (@captions and $CONFIG{get_captions}) {
        require WWW::YoutubeViewer::GetCaption;
        my $yv_cap = WWW::YoutubeViewer::GetCaption->new(
                                                         captions_dir => $CONFIG{captions_dir},
                                                         captions     => \@captions,
                                                         languages    => $CONFIG{srt_languages},
                                                        );
        $srt_file = $yv_cap->save_caption($video_id);
    }

    require WWW::YoutubeViewer::Itags;
    state $yv_itags = WWW::YoutubeViewer::Itags->new();

    # Include DASH itags
    my $dash = 1;

    # Exclude DASH itags if the support is disabled
    if (not $CONFIG{dash_support}) {
        $dash = 0;
    }

    my ($streaming, $resolution) = $yv_itags->find_streaming_url(\@urls, $CONFIG{resolution}, $dash);

    my $info = {};
    if (not @urls) {
        %{$info} = map { ref($_) eq 'HASH' ? %{$_} : () } @info;
    }

    return {
            streaming  => $streaming,
            srt_file   => $srt_file,
            info       => $info,
            resolution => $resolution,
           };
}

sub update_mplayer_arguments {
    my ($resolution) = @_;

    if (
        $CONFIG{use_lower_cache}
        or not $resolution ~~ [
            qw(
              original
              2160
              1440
              1080
              720
              )
        ]
      ) {
        set_mplayer_arguments($CONFIG{lower_cache}, $CONFIG{lower_cache_min});
    }
    else {
        set_mplayer_arguments($CONFIG{cache}, $CONFIG{cache_min});
    }
}

sub get_quotewords {
    require Text::ParseWords;
    return Text::ParseWords::quotewords(@_);
}

#---------------------- PLAY AN YOUTUBE VIDEO ----------------------#
sub get_player_command {
    my ($streaming, $video) = @_;

    update_mplayer_arguments($streaming->{resolution});

    my $cmd = join(
        q{ },
        (
            # Video player
            $CONFIG{video_players}{$CONFIG{video_player_selected}}{cmd},

            (    # Audio file (http://)
               ref($streaming->{streaming}{__AUDIO__}) eq 'HASH'
                 && exists($CONFIG{video_players}{$CONFIG{video_player_selected}}{audio})
               ? sprintf(
                         $CONFIG{video_players}{$CONFIG{video_player_selected}}{audio},
                         $streaming->{streaming}{__AUDIO__}{url}
                        )
               : ()
            ),

            (    # Caption file (.srt)
               defined($streaming->{srt_file})
                 && exists($CONFIG{video_players}{$CONFIG{video_player_selected}}{srt})
               ? sprintf($CONFIG{video_players}{$CONFIG{video_player_selected}}{srt}, $streaming->{srt_file})
               : ()
            ),

            # Rest of the arguments
            grep({ defined($_) and /\S/ } values %MPLAYER)
        )
    );

    my $has_video = $cmd =~ /\*VIDEO\*/;
    $cmd = $yv_utils->format_text($streaming, $video, $cmd, 1);
    $has_video ? $cmd : join(' ', $cmd, quotemeta($streaming->{streaming}{url}));
}

sub play_videos {
    my ($videos) = @_;

    foreach my $video (@{$videos}) {
        my $streaming = get_streaming_url($video->{videoID});

        if (defined $streaming->{info}{status} and $streaming->{info}{status} =~ /\bfail/i) {
            die "[x_x] Error on: " . sprintf($CONFIG{youtube_video_url}, $video->{videoID}) . "\n",
              "[x_x] Reason: " . $streaming->{info}{reason} =~ s/\+/ /gr . "\n";
        }

        if (ref($streaming->{streaming}) ne 'HASH') {
            next;
        }

        my $command = get_player_command($streaming, $video);

        if ($yv_obj->get_debug) {
            say "-> Resolution: $streaming->{resolution}";
            say "-> Video itag: $streaming->{streaming}{itag}";
            say "-> Audio itag: $streaming->{streaming}{__AUDIO__}{itag}" if exists $streaming->{streaming}{__AUDIO__};
            say "-> Video type: $streaming->{streaming}{type}";
            say "-> Audio type: $streaming->{streaming}{__AUDIO__}{type}" if exists $streaming->{streaming}{__AUDIO__};
            say "-> Command: $command";
        }

        my $code = execute_external_program(join(q{ }, $command, quotemeta($streaming->{streaming}{url})));
        warn "Can't play this video -- player exited with code: $code\n" if $code != 0;
    }

    return 1;
}

sub list_category {
    my $iter   = $cat_treeview->get_selection->get_selected;
    my $cat_id = $cats_liststore->get($iter, 1) // return;
    my $type   = $cats_liststore->get($iter, 3);

    my $videos =
        $type eq 'edu-cat'
      ? $yv_obj->get_video_lectures_from_category($cat_id)
      : $yv_obj->get_videos_from_category($cat_id);

    if (@{$videos->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($videos);
    }
    else {
        die "No video found for categoryID: <$cat_id>\n";
    }
}

sub list_tops {
    my $iter = $tops_treeview->get_selection->get_selected;

    my %top_opts;
    $top_opts{feed_id} = $tops_liststore->get($iter, 2) // return;
    my $top_type = $tops_liststore->get($iter, 3);

    if ($top_type ne q{}) {
        $top_opts{time_id} = $top_type;
    }

    if (length(my $region = $gui->get_object('region_entry')->get_text)) {
        $top_opts{region_id} = $region;
    }

    if (length(my $category = $gui->get_object('category_entry')->get_text)) {
        $top_opts{cat_id} = $category;
    }

    $liststore->clear if $CONFIG{clear_list};
    print_videos(
                   $top_type eq 'movies'
                 ? $yv_obj->get_movies($top_opts{feed_id})
                 : $yv_obj->get_video_tops(%top_opts)
                );
}

sub clear_text {
    $_[0]->set_text('') if $CONFIG{clean_text_entries_on_click};
    return 0;
}

sub run_cli_youtube_viewer {
    execute_cli_youtube_viewer('--interactive');
}

sub get_options_as_arguments {
    my @args;
    my %options = (
                   'no-interactive' => q{},
                   'orderby'        => $CONFIG{orderby},
                   'time'           => $CONFIG{time_sort},
                   'resolution'     => $CONFIG{resolution},
                   'download-dir'   => rel2abs($CONFIG{downloads_folder}),
                   'fullscreen'     => $CONFIG{fullscreen} ? q{} : undef,
                   'no-dash'        => $CONFIG{dash_support} ? undef : q{},
                  );

    while (my ($argv, $value) = each %options) {
        push(
            @args,
            do {
                $value             ? '--' . $argv . '=' . $value
                  : defined $value ? '--' . $argv
                  :                  next;
              }
            );
    }
    return @args;
}

sub execute_external_program {
    system $_[0] . ' &';
}

sub _make_youtube_url {

    my $format =
        $CONFIG{search_playlists} ? $CONFIG{playlists_url}
      : $CONFIG{search_channels}  ? $CONFIG{youtube_profile_url}
      :                             $CONFIG{youtube_video_url};

    my $value = $_[0] =~ /^username=(.+)/ ? $1 : shift;

    return sprintf($format, $value);
}

sub open_youtube_url {
    my $url = _make_youtube_url(get_selected_video_code() or return);
    my $code = execute_external_program(join(q{ }, $CONFIG{browser} // 'xdg-open', quotemeta($url)));

    warn "Can't open YouTube URL - exit code: $code\n" if $code != 0;
    return 1;
}

my @queue_codes;

sub queue_playback {
    my $code = get_selected_video_code() or return;
    print "[*] Added: <$code>\n" if $yv_obj->get_debug;
    push @queue_codes, $code;
    return 1;
}

sub play_videos_from_queue {
    if (@queue_codes) {
        execute_cli_youtube_viewer('--video-ids=' . join(q{,}, splice @queue_codes));
    }
    return 1;
}

sub play_all_video_results {
    my $model = $treeview->get_model;
    my $iter = $model->get_iter_first // return;

    my @ids;

    do {
        push @ids, $liststore->get($iter, 3);
    } while defined($iter = $model->iter_next($iter));

    execute_cli_youtube_viewer('--video-ids=' . join(q{,}, grep { /$valid_video_id_re/ } @ids));

    return 1;
}

sub play_selected_video_with_cli_youtube_viewer {
    my $code = get_selected_video_code() or return;
    execute_cli_youtube_viewer("--video-id=$code");
    return 1;
}

sub execute_cli_youtube_viewer {
    my @arguments = @_;

    my $command = join(
                       q{ },
                       $CONFIG{terminal},
                       sprintf(
                               $CONFIG{terminal_exec},
                               join(q{ }, $CONFIG{youtube_viewer}, get_options_as_arguments(), @arguments)
                              )
                      );
    my $code = execute_external_program($command);

    say $command if $yv_obj->get_debug;

    warn "youtube-viewer - exit code: $code\n" if $code != 0;
    return 1;
}

sub download_video {
    my $code = get_selected_video_code() or return;
    die "Unable to download a playlist!\n" if $CONFIG{search_playlists};
    execute_cli_youtube_viewer("--video-id=$code", '--download');
    return 1;
}

sub comments_row_activated {
    my $iter = $feeds_treeview->get_selection->get_selected() or return;
    my $value = $feeds_liststore->get($iter, 1);

    if (defined $value and $value =~ m{^https?://}) {
        $feeds_liststore->remove($iter);
        my $comments = $yv_obj->next_page($value, comments => 1);
        if (@{$comments->{results}}) {
            print_comments($comments);
        }
        else {
            die "This is the last page of comments.\n";
        }
    }

    return 1;
}

sub get_user_favorited_videos {
    my $username = get_username_for_selected_video() // return;
    favorited_videos_from_username($username);
}

sub get_username_for_selected_video {
    my $iter = $treeview->get_selection->get_selected() or return;
    return $liststore->get($iter, 6);
}

sub show_related_videos {
    my $code = get_selected_video_code() or return;

    my $videos = $yv_obj->get_related_videos($code);
    if (@{$videos->{results}}) {
        $liststore->clear if $CONFIG{clear_list};
        print_videos($videos);
    }
    else {
        die "No related video for videoID: <$code>\n";
    }
}

sub favorite_video {
    my $code = get_selected_video_code() or return;

    $feeds_statusbar->push(
                           0, $yv_obj->favorite_video($code)
                           ? 'Video favorited.'
                           : 'Error!'
                          );
}

sub subscribe_channel {
    my $user = get_username_for_selected_video();
    $feeds_statusbar->push(
                           0, $yv_obj->subscribe_channel($user)
                           ? "Successfully subscribed to channel: $user."
                           : 'Error!'
                          );
}

sub like_selected_video {
    my $code = get_selected_video_code() or return;
    $feeds_statusbar->push(
                           0, $yv_obj->send_rating_to_video($code, 'like')
                           ? 'Video liked.'
                           : 'Error!'
                          );
}

sub dislike_selected_video {
    my $code = get_selected_video_code() or return;
    $feeds_statusbar->push(
                           0, $yv_obj->send_rating_to_video($code, 'dislike')
                           ? 'Video disliked.'
                           : 'Error!'
                          );
}

sub send_comment_to_video {
    my $videoID = get_selected_video_code() or return;
    my $comment = get_text($gui->get_object('comment_textview'));

    $feeds_statusbar->push(0,
                           length($comment) && $yv_obj->send_comment_to_video($videoID, $comment)
                           ? 'Video comment has been posted!'
                           : 'Error!');
}

sub print_comments {
    my ($results, %options) = @_;

    my $url      = $results->{url};
    my $comments = $results->{results};

    if (not @{$comments}) {
        return;
    }

    my $i = 0;
    foreach my $comment (@{$comments}) {

        my $iter = $feeds_liststore->append;
        $feeds_liststore->set(
                              $iter,
                              0,
                              "<big><b>$comment->{name}</b> ("
                                . $yv_utils->format_date($comment->{published})
                                . ") said:</big>\n\t"
                                . encode_entities($comment->{content})
                             );
    }

    my $iter = $feeds_liststore->append;
    $feeds_liststore->set($iter, 0, "\n<big><b>=&gt;&gt; NEXT PAGE</b></big>\n");
    $feeds_liststore->set($iter, 1, $url);
    return 1;
}

sub show_more_videos_from_username {
    videos_from_username(get_username_for_selected_video() or return);
}

sub show_playlists_from_username {
    playlists_from_username(get_username_for_selected_video() or return);
}

# Setting details to details_window
sub set_video_details {
    my ($code, $iter) = @_;
    my $main_details = $liststore->get($iter, 0);

    # Setting title
    my $title = substr($main_details, 0, index($main_details, '</big>') + 6, '');
    $gui->get_object('video_title_label')->set_label("<big>$title</big>");

    # Setting video details
    $main_details =~ s/^\s+//;
    $main_details =~ s{\s*<i>.+</i>\s*}{\n};

    my $secondary_details = $liststore->get($iter, 2);
    $gui->get_object('video_details_label')->set_label($main_details . $secondary_details);

    # Setting the link button
    my $url        = _make_youtube_url($code);
    my $linkbutton = $gui->get_object('linkbutton1');
    $linkbutton->set_label($url);
    $linkbutton->set_uri($url);

    # Getting thumbs
    foreach my $nr (qw(1 2 3)) {
        if ($CONFIG{search_playlists} or $CONFIG{search_channels}) {
            $gui->get_object("image$nr")->set_from_pixbuf($default_thumb);
        }
        else {
            my $pixbuf = _get_pixbuf_thumbnail(sprintf($CONFIG{thumb_url}, $code, $nr));
            $gui->get_object("image$nr")->set_from_pixbuf($pixbuf);
        }
    }

    # Setting textview description
    set_text($gui->get_object('description_textview'), $liststore->get($iter, 4));
    return 1;
}

sub on_mainw_destroy {

    # Save hpaned position
    $CONFIG{hpaned_position} = $hbox2->get_position;

    get_main_window_size();
    dump_configuration();
    save_usernames_to_file();
    'Gtk2'->main_quit;
    exit 0;
}

$notebook->set_current_page($CONFIG{default_notebook_page});

'Gtk2'->main;
