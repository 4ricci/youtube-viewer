#!/usr/bin/perl

# Copyright (C) 2010-2011 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#-------------------------------------------------------
#  (C) 2010-2011 by Trizen
#  Created on: 02 Jun 2010
#  Latest edit on: 28 November 2011
#  Website: http://trizen.go.ro
#  Email: echo dHJpemVueEBnbWFpbC5jb20K | base64 -d
#-------------------------------------------------------
#
# [?] What is this script for?
#  - This script is useful to search and watch YouTube videos with MPlayer...
#  - Have fun!
#
# [!] The most important changes are written in the changelog!
#
# [CHANGELOG]
# - Added support to list playlists created by a specific user (usage: -up <USERNAME>)         - NEW (v2.5.4)
# - Improved parsing support for arguments, including arguments specified via STDIN.           - NEW (v2.5.4)
# - Added support to search for videos uploaded by a particular YouTube user (-author=USER)    - NEW (v2.5.4)
# - Added support to get video results starting with a predefined page (ex: -page=4)           - NEW (v2.5.4)
# - Added support for previous page and support to list youtube usernames from a file          - (v2.5.2)
# - Added few options to control cache of MPlayer and lower cache for lower video resolutions  - (v2.5.1)
# - Added colours for text (--colours) or $colours = 1, 360p support (-3), playlist support    - (v2.5.0)
# - Added support for today and all time Youtube tops (usage: -t, --tops, -a, --all-time)      - (v2.4.*)
# - Re-added the support for the next page / Added support for download (-d, --download)       - (v2.4.*)
# - Added support for Youtube CCaptions. (Depends on: 'gcap' - http://gcap.googlecode.com)     - (v2.4.*)
# - First version with Windows support. Require SMPlayer to play videos. See MPlayer Line      - (v2.4.*)
# - Code has been changed in a proportion of ~60% and optimized for speed // --480 became -4   - (v2.4.*)
# - Added mega-powers of omnibox to the STDIN :)                                               - (v2.3.*)
# - Re-added the option to list and play youtube videos from a user profile. Usage: -u [user]  - (v2.3.*)
# - Added a new option to play only the audio track of a videoclip. Usage: [words] -n          - (v2.3.*)
# - Added option for fullscreen (-f, --fullscreen). Usage: youtube-viewer [words] -f           - (v2.3.*)
# - Added one new option '-c'. It shows available categories and will let you to choose one.   - (v2.3.*)
# - Added one new option '-m'. It shows 3 pages of youtube video results. Usage: [words] -m    - (v2.3.*)
# - For "-A" option has been added 3 pages of youtube video results (50 clips)                 - (v2.3.*)
# - Added "-prefer-ipv4" to the mplayer line (videoclips starts in no time now).               - (v2.3.*)
# - Search and play videos at 480p, 720p. Ex: [words] --480, [words] -A --480                  - (v2.3.*)
# - Added support to play a video at 480p even if it's resolution is higher. Ex: [url] --480   - (v2.2.*)
# - Added a nice feature which prints some informations about the current playing video        - (v2.2.*)
# - Added support to play videos by your order. Example: after search results, insert: 3 5 2 1 - (v2.1.*)
# - Added support for next pages of video results (press <ENTER> after search results)         - (v2.1.*)
# - Added support to continue playing searched videos, usage: "youtube-viewer [words] -A"      - (v2.1.*)
# - Added support to print counted videos and support to insert a number instead of video code - (v2.1.*)
# - Added support to search YouTube Videos in script (ex: youtube-viewer avatar trailer 2009)  - (v2.0.*)
# - Added support for script to choose automat quality if it is lower than 1080p               - (v2.0.*)
# - Added support to choose the quality only between 720p and 1080p (if it is available)       - (v2.0.*)
# - Added support for YouTube video codes (ex: youtube-viewer WVTWCPoUt8w)                     - (v1.0.*)
# - Added support for 720p and 1080p YouTube Videos...                                         - (v1.0.*)

# Special thanks to:
# - Army (for bugs reports and for his great ideas)
# - dhn (for adding youtube-viewer in freshports.org)

eval 'exec perl -wS $0 ${1+"$@"}'
  if 0;    #$running_under_some_shell;

use strict;
use autouse ('URI::Escape'    => 'uri_escape');
use autouse ('HTML::Entities' => 'decode_entities');

my $appname = 'youtube-viewer';
my $version = '2.5.5-git';

####################### MPLAYER OPTIONS #######################
my $cache                = 30000;                                                 # default MPlayer cache
my $cache_min            = 5;                                                     # default MPlayer cache-min
my $user_lower_cache     = 0;                                                     # 1 will set a lower cache for MPlayer
my $mplayer_settings     = "-prefer-ipv4 -cache $cache -cache-min $cache_min";    # MPlayer options
my $mplayer_srt_settings = '-unicode -utf8';                                      # subtitle options

####################### YOUTUBE OPTIONS #######################
my $start_index = 1;                                                              # index of the first matching result
my $results     = 20;                                                             # number of video results
my $order_by    = 'relevance';
my $time_p      = 'all_time';
my $region;         # show YouTube movies from a particular region (default: undefined)
my $from_author;    # search videos uploaded by a particular user  (default: undefined)

####################### OTHER OPTIONS #######################
my $colours         = 0;       # 1 for colored output of video results
my $debug           = 0;       # 1 will run in debug mode
my $download_video  = 0;       # 1 will run wget or LWP for downloading videos instead of streaming them
my $lwp_downloading = 0;       # 1 will always download videos with LWP (default: wget (if is available))
my $playback        = 0;       # 1 will stream all available video results, including videos from next pages
my $default_sub     = 'en';    # default language for subtitles (requires gcap to get YouTube CC's)
my $users_file = "$ENV{'HOME'}/.config/youtube_usernames.txt";

# Unchangeable variables
my %constant = ('dash_line' => '-' x 80,                                                   # used as a line separator
                'win32'     => $^O eq 'Win32' ? 1 : 0,                                     # true if running under Windows
                'tmp_dir'   => $ENV{'TEMP'} // $ENV{'TMP'} // $ENV{'TMPDIR'} // '/tmp',    # tmpdir is used to save srt files
               );

####################### TEMPORARY OPTIONS #######################
my $user_cache;                                                                #               ||
my $user_cache_min;                                                            #               ||
my $dont_exit;                                                                 #               \/
my $all_time;                                                                  # DON'T change this default values
my $lwp_is_set;                                                                # unless you know what you're doing
my $video_results;                                                             #               /\
my $user_resolution;                                                           #               ||
my $playlists;                                                                 #               ||
my $user_fullscreen;                                                           #               ||

####################### ASCII COLOURS #######################
my $bred    = '';
my $bgreen  = '';
my $reset   = '';
my $cblack  = "\e[40m";                                                        # background black
my $byellow = "\e[1;33m";                                                      # bold yellow
my $bpurle  = "\e[1;35m";                                                      # bold purple
my $bblue   = "\e[1;34m";                                                      # bold blue

unless ($constant{'win32'}) {                                                  # if not running under Windows
    $bred   = "\e[1;31m";                                                      # bold red
    $bgreen = "\e[1;32m";                                                      # bold green
    $reset  = "\e[0m";                                                         # reset color
}

####################### SUBROUTINE PROTOTYPES #######################
sub list_playlist($);
sub videos_from_username($);

####################### GLOBAL VARIABLES #######################
my $SEARCH = '';          # used to store search keywords for YoutTube
my $YOUTUBE_GDATA_URL;    # used to store the gdata URL with API query parameters
my $streaming;            # used to store a streaming video URL, and will be passed to mplayer as an argument
my $feeds_main_url = 'https://gdata.youtube.com/feeds/api';
my $get_video_info = 'https://www.youtube.com/get_video_info';

my (@Videos, @picks, %resolution, %streaming);    # other global variables

####################### REGEXP AREA #######################
my $quit_required       = qr/^(?:q|quit|exit)$/i;                              # exit if user's input is q, quit or exit
my $has_entities        = qr/&#?\w/;                                           # checks if a string contains HTML entities
my $get_youtube_code    = qr"(?:v|embed|youtu\.be)(?:%3D|[=/])([-\w]{11})";    # $1 will be the video code
my $valid_playlist_code = qr/^(?:PL)?([A-Z\d]{16})$/;                          # $1 will be the playlist code
my $contains_arguments  = qr/(?:\s|^)-+\w/;                                    # cheks if a string contains arguments

######################################### REGEXP: PLAYLIST ID FINDER #################################
## $1 will be the playlist code
my $get_playlist_code = qr"(?:(?:(?:playlist\?list|view_play_list\?p)=)|\w#p/c/)(?:PL)?([A-Z\d]{16})";
######################################################################################################

######################################### REGEXP: XML PARSER #########################################
# $1, $2 and sometimes $3 and $4 will be defined.
#

my $xml_parser = qr[<(?![?/])(?:([^ >/]+)[^>/]*>([^<]+)<|(?: *([^=><]+)='([^']+)')+/>)];

#
# Usage: while(/$xml_parser/og){
#           $hash{$1} = $2 if defined $1;
#           $hash{$3} = $4 if defined $3;
#        }
######################################################################################################

######################################################################################################
# The bellow regex will validate and url.
# If is valid, youtube-viewer will try to get
# an youtube video code from that website using /$get_youtube_code/
my $valid_url = qr<^

        ################# This regex will validate an HTTP URL #################
                                                               # Coded by Trizen

        # Valid urls #######################################
        #      http://9.Yz                                 #
        #      http://m.example.com/test.html              #
        #      https://mail.example.com/mail/?ver=1#inbox  #
        #      http://test-test.test-test.museum?id=2      #
        ####################################################

        # Invalid urls #####################################
        #     http://-test.com                             #
        #     http://test-.com                             #
        #     http://test-.com                             #
        #     http://test..com                             #
        #     http://test.-.com                            #
        #     http://test.-test.com                        #
        ####################################################

                https?://                # http, https followed by ://
                [a-zA-Z0-9]              # first character must be a-zA-Z0-9
                (?:(?:(?:\w*-+\w+|\w+)*  # words, dash, words OR only words
                \.(?=\w))+?              # point if followed by word char
                |                        # OR (validates http://x.yz)
                \.)                      # a single point
                \w{2,6}                  # domain (words between 2 and 6 chars)
                (?:[#/?!]                # characters after domain
                [\(\)/&\w#?=.,;:'+~\$\%\-\\]*)*  # rest characters of the string
$>x;

###########################################################

# itag => resolution
my %itags = (37 => 1080,
             22 => 720,
             35 => 480,
             43 => 210,
             34 => 360,
             5  => 240);

unless (grep((-e "$_/LWP/Protocol/https.pm"), @INC)) {    # checks if https support is available
    $feeds_main_url =~ s/s//;                             # changes https to http
    $get_video_info =~ s/s//;                             # ==//==
}

my $MPlayerLine;

if ($constant{'win32'}) {
    my $MPlayer_exe = $ENV{'ProgramFiles'} . '\\SMPlayer\\mplayer\\mplayer.exe';    # Windows SMPlayer path

    if (-e $MPlayer_exe) {
        $MPlayerLine = qq["$MPlayer_exe" $mplayer_settings];                        # Windows MPlayer line
    }
    else {
        warn "\n\n!!! Please install SMPlayer to stream Youtube videos.\n\n";
        $MPlayerLine = "mplayer $mplayer_settings";
    }
}
else {
    $MPlayerLine = "mplayer $mplayer_settings";                                     # *NIX MPlayer line
}

####################### MY PATH #######################
my @path = $constant{'win32'} ? split(/;/, $ENV{'PATH'}) : split(/:/, $ENV{'PATH'}); # split $PATH by ';' if running under Windows

####################### LOOKING FOR WGET #######################
my $wget_is_available;

sub locate_wget {
    if (-x '/usr/bin/wget'
        or grep(($constant{'win32'}
                 ? do { 1 if -e "$_\\wget.exe" or -e "$_\\wget" }
                 : -x "$_/wget"
                ),
                @path)
    ) {
        $wget_is_available = 1;
    }
}

####################### LOOKING FOR GCAP #######################
my $gcap = '/usr/bin/gcap';    # default gcap path
foreach my $path (@INC, @path) {
    if (-e "$path/gcap") {
        $gcap = "$path/gcap";
        last;
    }
}

####################### LWP::UserAgent #######################
my $lwp;

sub UserAgent {
    require LWP::UserAgent;
    $lwp = 'LWP::UserAgent'->new;
    $lwp->agent('Mozilla/5.0 (X11; U; Linux i686; en-US) Chrome/10.0.648.45');
    $lwp->env_proxy;
    $lwp->timeout(15);
    $lwp->show_progress(1) if $debug;
    $lwp_is_set = 1;
}

####################### GET THE NEXT ARGUMENT #######################
sub get_next_argument ($) {
    my $i = shift();
    if (defined $ARGV[$i] and chr ord $ARGV[$i] ne '-') {
        return splice(@ARGV, $i, 1);
    }
    else {
        die "error: option '$ARGV[$i-1]' requires an argument";
    }
}

####################### PARSING ARGUMENTS #######################
sub parse_arguments {
    my $i = 0;
    foreach my $arg (@_) {
        defined $arg ? ++$i : next;
        if (chr ord $arg eq '-') {    # if argument starts with '-'

            if ($arg =~ /^-+cache(?:=(\d+))?$/) {    # eg: -cache 1500, --cache=2000
                my $cache = $1 // get_next_argument($i);
                $MPlayerLine =~ s/-cache\s+\d+/-cache $cache/;
                $user_cache = 1;
            }
            elsif ($arg =~ /^-+cache.?min(?:=(\d+))?$/) {    # eg: --cache-min=2
                my $cache_min = $1 // get_next_argument($i);
                $MPlayerLine =~ s/-cache-min\s+\d+/-cache-min $cache_min/;
                $user_cache_min = 1;
            }
            elsif ($arg =~ /^-+(?:l|lower.?cache)$/) {       # eg: -l, --lower-cache
                $user_lower_cache = 1;
            }
            elsif ($arg =~ /^-+(?:n|no.?video)$/) {          # eg: -n, --no-video
                $constant{'win32'}
                  ? $MPlayerLine =~ s/mplayer\.exe"/mplayer.exe" -novideo/
                  : $MPlayerLine =~ s/mplayer /mplayer -novideo /;
                $resolution{'resolution'} = 480 unless $user_resolution;
            }
            elsif ($arg =~ /^-+time(?:=(.+))?$/) {           # eg: --time=this_week
                $time_p = $1 // get_next_argument($i);
            }
            elsif ($arg =~ /^-+page(?:=(\d+))?$/) {          # eg: --page=3
                $start_index = $results * do { $1 // get_next_argument($i) }
                  - $results + 1;
            }
            elsif ($arg =~ /^-+author(?:=(.+))?$/) {         # eg: --author=google
                $from_author = $1 // get_next_argument($i);
            }
            elsif ($arg =~ /^-+(?:T|tty|M|mplayer)=(.+)/) {    # eg: --mplayer='-vo xv'
                $MPlayerLine .= " $1";
            }
            elsif ($arg =~ /^-+(?:o|order.?by)(?:=(.+))?$/) {    # eg: -o rating, --order-by=published
                $order_by = $1 // get_next_argument($i);
            }
            elsif ($arg =~ /^-+(?:r|region)(?:=(.+))?$/) {       # eg: -r US, --region=US
                $region = $1 // get_next_argument($i);
            }
            elsif ($arg =~ /^-+(?:sub|lang)(?:=([\w]{2,5}))?$/) {    # eg: -sub ar, --lang=ar
                $default_sub = $1 // get_next_argument($i);
                $default_sub = lc $default_sub unless $default_sub =~ /_/;
            }
            elsif ($arg =~ /^-+(?:colou?rs?|C|cl)$/) {               # eg: -C, --colors
                $colours = 1 unless $constant{'win32'};
            }
            elsif ($arg =~ /^-+(?:(?^i:lwp).download(?:ing)?|L(?:WP)?|download.with.(?^i:lwp))$/) {
                $lwp_downloading = 1;
            }
            elsif ($arg =~ /^-+(?:d|download)$/) {                   # eg: -d, --download
                $download_video = 1;
                if (not $lwp_downloading and not $wget_is_available) {
                    locate_wget();
                }
            }
            elsif ($arg =~ /^-+(?:P|proxy)(?:=(.+))?$/) {            # eg: --proxy=123.442.122.32:80
                UserAgent unless $lwp_is_set;
                my $proxy = $1 // get_next_argument($i);
                $proxy = 'http://' . $proxy unless $proxy =~ /^https?:/;
                $lwp->proxy(['http', 'https'], $proxy);
            }
            elsif ($arg =~ /^-+(?:a|all.?time)$/) {                  # eg: --all-time
                $all_time = 1;
            }
            elsif ($arg eq '--debug') {                              # eg: --debug
                $debug = 1;
            }
            elsif ($arg =~ /^-+(?:A|(?:play.)?all)$/) {              # eg: -A, --play-all
                $playback = 1;
            }
            elsif ($arg =~ /^-+(?:m|more)$/) {                       # eg: -m, --more
                $results = 50;
            }
            elsif ($arg =~ /^-+(?:fs?|fullscreen)$/) {               # eg: -fs, --fullscreen
                set_fullscreen_mode();
                $user_fullscreen = 1;
            }
            elsif ($arg =~ /^-+(?:FS?|no.?fullscreen)$/) {           # eg: -F, --no-fullscreen
                disable_fullscreen_mode();
                $user_fullscreen = 1;
            }
            elsif ($arg =~ /^-+(?:1[862]0p?|3gp)$/) {                # eg: -3gp, --180p
                $resolution{'resolution'} = 180;
            }
            elsif ($arg =~ /^-+(?:2|240p?)$/) {                      # eg: -2, --240p
                $resolution{'resolution'} = 240;
            }
            elsif ($arg =~ /^-+(?:3|360p?)$/) {                      # eg: -3, --360p
                $resolution{'resolution'} = 360;
            }
            elsif ($arg =~ /^-+(?:4|480p?)$/) {                      # eg: -4, --480p
                $resolution{'resolution'} = 480;
            }
            elsif ($arg =~ /^-+(?:7|720p?)$/) {                      # eg: -7, --720p
                $resolution{'resolution'} = 720;
            }
            elsif ($arg =~ /^-+(?:1|1080p?)$/) {                     # eg: -1, --1080p
                $resolution{'resolution'} = 1080;
            }
        }
        else {
            $SEARCH .= "$arg ";                                      # appending a keyword to $SEARCH
        }
    }

    if (exists $resolution{'resolution'}) {
        $user_resolution = 1;
    }
    else {
        $resolution{'resolution'} = 0;
    }

    if ($playback and not $user_resolution) {
        $resolution{'resolution'} = 1080;    # set 1080p resolution if $playback is TRUE and not any other resolution is selected
    }

    parse_sub_calling_arguments(@_);
}
parse_arguments(@ARGV);

####################### PARSING ARGUMENTS WHICH CALLS A SUBROUTINE #######################
sub parse_sub_calling_arguments {
    my $i = 0;
    foreach my $arg (@_) {
        defined $arg ? ++$i : next;
        if (chr ord $arg eq '-') {

            if ($arg =~ /^-+(?:h|help|\?|usage)$/i) {
                help();
            }
            elsif ($arg =~ /^-+(?:v|version)$/i) {
                version();
            }
            elsif ($arg =~ /^-+pl?(?:playlists?)?$/) {
                search_playlists();
            }
            elsif ($arg =~ /^-+c(?:ategories)?$/) {
                categories_area();
            }
            elsif ($arg =~ /^-+(M|movies)$/) {
                youtube_movies();
            }
            elsif ($arg =~ /^-+(?:a|all[_-]?time|t|tops)$/) {
                youtube_tops();
            }
            elsif ($arg =~ /^-+u(?:sername)?(?:=(\w+))?$/) {
                videos_from_username($1 // get_next_argument($i));
            }
            elsif ($arg =~ /^-u(?:ser(?:name)?)?p(?:laylist)?(?:=(\w+))?$/) {
                playlists_from_username($1 // get_next_argument($i));
            }
            elsif ($arg =~ /^-+(?:U|user(?:name)?s)(?:=(.+))?$/) {
                if (defined $1 and -r $1) {
                    $users_file = $1;
                }
                list_user_names();
            }
        }
    }
}

####################### LOOKING FOR NON-ARGUMENTS #######################
my $non_argv = 0;
foreach my $arg (@ARGV) {
    if (not chr ord $arg eq '-' or length $arg == 11) {
        $non_argv = 1;
        last;
    }
}

####################### GO TO insert_url() IF $non_argv is FALSE #######################
sub insert_url () {
    print "\n$bred=>>$reset$bgreen Insert an YouTube URL or search something...\n$reset> ";

    chomp(my $stdin = <STDIN>);

    exit if $stdin =~ /$quit_required/o;

    if ($stdin =~ /$contains_arguments/o) {
        parse_arguments(grep((chr ord $_ eq '-'), split(/\s+/, $stdin, 0)));
    }

    if ($stdin =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
    elsif ($stdin =~ /$get_playlist_code/o) {
        list_playlist($1);
    }
    elsif ($stdin =~ /$valid_playlist_code/o) {
        list_playlist($1);
    }
    elsif ($stdin =~ m[^https?://] and $stdin =~ /$valid_url/o) {
        code_from_content($stdin);
    }
    elsif (defined($stdin) and length($stdin)) {
        search($stdin);
    }
    else {
        warn "\n$bred(x_x) Unable to continue...$reset\n\n";
        exit 0;
    }
}
insert_url() unless $non_argv;

####################### GET A VIDEO CODE FROM AN WEBSITE CONTENT #######################
sub code_from_content ($) {
    UserAgent unless $lwp_is_set;

    if ($lwp->get($_[0])->content =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
    else {
        search($_[0]);
    }
}

####################### PARSING VIDEO CODES SPECIFIED AS ARGUMENTS #######################
foreach my $code (@ARGV) {
    if (length($code) == 11 and $code =~ /^[\w\-]{11}$/ and $code =~ /[\d_A-Z\-]/o) {
        $dont_exit = 1;
        get_youtube($code);
    }
    elsif ($code =~ /$get_playlist_code/o) {
        list_playlist($1);
    }
    elsif ($code =~ /$valid_playlist_code/o) {
        list_playlist($1);
    }
    if ($code =~ /$get_youtube_code/o) {
        $code      = $1;
        $dont_exit = 1;
        get_youtube($code) if (length($code) == 11);
    }
    elsif ($code =~ m[^https?://] and $code =~ /$valid_url/o) {
        code_from_content($code);
    }
}

####################### YOUTUBE-VIEWER USAGE #######################
sub help {
    print "\n  " . '=' x 30 . " \U$appname\E " . '=' x 30 . "
\t\t\t\t\t\t by Trizen (trizenx\@gmail.com)
\nUsage: $appname [options] ([code] || [url] || [keywords])
\nBase Options:
   <url>                : play an YouTube video by URL
   <code>               : play an YouTube video by code
   <keywords>           : search and list YouTube videos
   <playlist_url>       : list a playlist of YouTube videos
\nYouTube options:
   -t, --tops           : shows today YouTube tops
   -a, --all-time       : shows all time YouTube tops
   -c, --categories     : shows available YouTube categories
   -m, --more           : shows more video results (50 clips)
   -p, --playlist       : search for YouTube playlists
   -M, --movies         : show YouTube movies categories
   --region=<ID>        : set a specific regionID (ex: US)
   -u  <username>       : list videos uploaded by a specific user
   -up <username>       : list playlists created by a specific user
   -author='USERNAME'   : search videos uploaded by a particular user
   -order-by='ORDER'    : order entries by: published, viewCount or rating
   -time='TIME'         : valid values are: today, this_week and this_month
   -page='PAGE_NR'      : show video results starting with page 'n'
   -2, -3, -4, -7, -1   : plays videos at 240p, 360p, 480p, 720p or 1080p
\nMPlayer options:
   -f, --fullscreen     : plays video(s) in fullscreen mode
   -F, --no-fullscreen  : disable fullscreen mode
   -n, --novideo        : plays only the audio track of video(s)
   -l, --lower-cache    : set a lower cache for MPlayer (for slow connections)
   -mplayer='SETTINGS'  : add some extra options to the MPlayer line
   -sub='LANG'          : subtitle language (default: en) (depends on gcap)
   -cache='VALUE'       : set cache for MPlayer (default: $cache)
   -cache-min='VALUE'   : set cache-min for MPlayer (default: $cache_min)
\nOther options:
   -d, --download       : downloads YouTube video(s) with LWP
   -A, --all            : plays all video results in order
   -C, --colors         : use colors for text output
   -U, --users=file.txt : list YouTube usernames from a file
   -P, --proxy=<PROXY>  : set proxy for LWP::UserAgent
   -L, --lwp-download   : download videos with LWP (default: wget)
   -v, --version        : prints version and exits
   -h, --help           : prints help and exits
\nTips and tricks:
  1. After search results, press <ENTER> for the next page
  2. After search results, insert 'back' for the previous page
  3. After search results, insert more numbers to play videos in your order
  4. After search results you can insert arguments via STDIN (eg: '-c')
  5. After search results you can insert 'reset' to set default settings
  6. Play all video results from a page: insert 'all' or insert '1..20'\n\n";
    exit 0;
}

####################### YOUTUBE-VIEWER VERSION #######################
sub version {
    print "Youtube Viewer $version\n";
    exit 0;
}

####################### LIST YOUTUBE USERNAMES FROM A FILE #######################
sub list_user_names {
    print "\n";

    if (-r $users_file) {
        open my $fh, '<:crlf', $users_file;

        my $n = 0;
        my %usernames_table;

        while (defined(my $username = <$fh>)) {
            next unless $username =~ /^\w+$/;
            chomp $username;
            ++$n;
            print do {
                ' ' if $n < 10;
            }, $bred, $n, $reset, ' - ', $bgreen, $username, $reset, "\n";
            $usernames_table{$n} = $username;
        }

        print "\n$bred=>>$reset ${bgreen}Pick an username number$reset\n> ";

        chomp(my $pick = <STDIN>);

        exit if $pick =~ /$quit_required/o;

        if ($pick =~ /$contains_arguments/o) {
            parse_arguments(grep((chr ord $_ eq '-'), split(/\s+/, $pick, 0)));
        }

        if (defined $usernames_table{$pick}) {
            chomp(my $user = $usernames_table{$pick});
            videos_from_username($user);
        }
        elsif ($pick =~ /^\w+$/) {
            videos_from_username($pick);
        }
        else {
            list_user_names();
        }
        close $fh;
    }
}

####################### GET VIDEOS FROM A SPECIFIC USER #######################
sub videos_from_username ($) {
    parse_url("$feeds_main_url/users/$_[0]/uploads");
}

####################### GET PLAYLISTS FROM A SPECIFIC USER #######################
my $playlist_index;

sub playlists_from_username {

    UserAgent unless $lwp_is_set;

    my @playlists;
    $playlists = 1;
    my $username = shift;
    $playlist_index = shift || $start_index;
    my $i = -1;

    parse_content(
                 "http://gdata.youtube.com/feeds/api/users/$username/playlists?max-results=$results&start-index=$playlist_index");

    unless (@Videos) {
        print "$bred(x_x) No playlist has been found...$reset\n";
        print "\n$bred=>>$bgreen Insert another username:$reset ";
        chomp(my $username = <STDIN>);
        exit if $username =~ /$quit_required/o;
        playlists_from_username($username);
    }

    # PlaylistID, Number, Title, Description, Author, VideosCount
    foreach my $playlist (@Videos) {
        $colours
          ? print $cblack, $bred, $$playlist[1], $reset, $cblack, ' - ', $byellow, $$playlist[2], ' ', $$playlist[3], $reset,
          $cblack,
          ' (', $bpurle, 'by ', $$playlist[4], $reset, $cblack, ') (', $bblue, $$playlist[5], $reset, $cblack, ')', $reset, "\n"
          : print $bred, $$playlist[1], $reset, ' - ', $$playlist[2], ' ', $$playlist[3], ' (by ', $$playlist[4], ') (',
          $$playlist[5], ")\n";
    }
    print "\n$bred=>>$bgreen Pick one playlist$reset\n> ";
    chomp(my $pick = <STDIN>);

    exit if $pick =~ /$quit_required/o;

    if ($pick =~ /$contains_arguments/o) {
        $playlists = 0;
        parse_arguments(grep((chr ord $_ eq '-'), split(/\s+/, $pick, 0)));
        $playlists = 1;
    }

    if ($pick =~ /^\s*$/ or $pick eq 'next') {
        playlists_from_username($username, $playlist_index + $results);
    }
    elsif ($pick eq 'back' and $playlist_index > $results) {
        playlists_from_username($username, $playlist_index - $results);
    }
    elsif ($pick =~ /^\d+$/) {
        $playlists = 0;
        list_playlist($Videos[$pick - 1][0]);
    }
    elsif ($pick =~ /^\w+$/) {
        playlists_from_username($pick, $start_index);
    }
}

####################### SEARCH FOR YOUTUBE PLAYLISTS #######################
sub search_playlists {
    $playlists = 1;
    UserAgent unless $lwp_is_set;

    my $url = shift() // "$feeds_main_url/playlists/snippets?q=$SEARCH&start-index=$start_index&max-results=$results&v=2";
    parse_content($url);

    my $n = -1;

    # PlaylistID, Number, Title, Description, Author, VideosCount
    foreach my $playlist (@Videos) {
        $colours
          ? print $cblack, $bred, $$playlist[1], $reset, $cblack, ' - ', $byellow, $$playlist[2], ' ', $$playlist[3], $reset,
          $cblack,
          ' (', $bpurle, 'by ', $$playlist[4], $reset, $cblack, ') (', $bblue, $$playlist[5], $reset, $cblack, ')', $reset, "\n"
          : print $bred, $$playlist[1], $reset, ' - ', $$playlist[2], ' ', $$playlist[3], ' (by ', $$playlist[4], ') (',
          $$playlist[5], ")\n";
    }

    print "\n$bred=>>$reset ${bgreen}Pick one playlist$reset\n> ";

    chomp(my $pick = <STDIN>);

    exit if $pick =~ /$quit_required/o;

    if ($pick =~ /$contains_arguments/o) {
        $playlists = 0;
        parse_arguments(grep((chr ord $_ eq '-'), split(/\s+/, $pick, 0)));
        $playlists = 1;
    }

    if (not $pick =~ /^\s*\d+\s*$/ and $pick =~ /^\s*$/ or $pick eq 'next') {

        if ($url =~ /start-index=(\d+)/) {
            $url =~ s/start-index=($1)/'start-index=' . ($1 + $results);/e;
            search_playlists($url);
        }
    }
    elsif (
        $pick eq 'back' and do {
            $url =~ /\bstart-index=(\d+)/;
            $1 > $results;
        }
      ) {

        if ($url =~ /start-index=(\d+)/) {
            $url =~ s/start-index=($1)/'start-index=' . ($1 - $results);/e;
            search_playlists($url);
        }
    }
    elsif ($pick =~ /^\D/ and not $pick =~ /^\s*\d/) {
        $SEARCH = $pick;
        search_playlists();
    }
    elsif ($pick =~ /^\s*(\d+)/) {
        $pick = $1;
    }

    $playlists = 0;
    list_playlist($Videos[$pick - 1][0]);
}

####################### LIST A YOUTUBE PLAYLIST #######################
sub list_playlist ($) {
    parse_url("$feeds_main_url/playlists/$_[0]");
}

####################### LIST YOUTUBE MOVIE CATEGORIES #######################
sub youtube_movies {
    print "\n";

    my $i = 0;
    my %movie_table;

    foreach $_ ('most_popular', 'most_recent', 'trending') {
        my $cat_name = ucfirst $_;
        $cat_name =~ tr/_/ /;
        print ' ' . $bred . ++$i . "$reset - $cat_name\n";
        $movie_table{$i} = $_;
    }

    print "\n$bred=>>$bgreen Pick one category$reset\n> ";

    chomp(my $pick = <STDIN>);

    exit if $pick =~ /$quit_required/o;

    if ($pick =~ /$contains_arguments/o) {
        parse_arguments(grep((chr ord $_ eq '-'), split(/\s+/, $pick, 0)));
    }

    if (defined $movie_table{$pick}) {
        parse_url("$feeds_main_url/charts/movies/$movie_table{$pick}");
    }
}

####################### LIST YOUTUBE TOP VIDEO CATEGORIES #######################
sub youtube_tops {
    my $n             = 0;
    my $today         = $all_time ? 0 : 1;
    my $standardfeeds = "$feeds_main_url/standardfeeds";
    my %tops_table;

    print "\n";

    foreach $_ ('top_rated',   'top_favorites',  'most_viewed',    'most_popular',
                'most_recent', 'most_discussed', 'most_responded', 'recently_featured'
      ) {
        ++$n;
        my $top_name = ucfirst $_;
        $top_name =~ tr/_/ /;
        print "$bred$n$reset - $top_name\n";
        $tops_table{$n} = $_;
    }

    print "\n$bred=>>$bgreen Pick one category$reset\n> ";

    chomp(my $pick = <STDIN>);

    exit if $pick =~ /$quit_required/o;

    if ($pick =~ /$contains_arguments/o) {
        parse_arguments(grep((chr ord $_ eq '-'), split(/\s+/, $pick, 0)));
    }

    if (defined $tops_table{$pick}) {
        my $url = $standardfeeds . '/' . $tops_table{$pick};

        if ($today) {

            unless ($url =~ /recent/) {
                $url .= '?time=today&v=2';
            }
        }
        parse_url($url);
    }
    else {
        youtube_tops();
    }
}

####################### LIST YOUTUBE VIDEO CATEGORIES #######################
sub categories_area {
    UserAgent unless $lwp_is_set;

    my $n = 0;
    my %categories_table;

    print "\n";

    foreach
      my $cat_line (split('<atom:category term=', $lwp->get('http://gdata.youtube.com/schemas/2007/categories.cat')->content, 0))
    {

        if (not $cat_line =~ /deprecated/ and $cat_line =~ /^'(.+?)'\s+label='(.+?)'/) {
            ++$n;
            my $cat_name  = $1;
            my $cat_label = $2;
            $cat_label =~ s/&amp;/&/;
            print do {
                ' ' if $n < 10;
            }, $bred, $n, $reset, ' - ', $cat_label, "\n";
            $categories_table{$n} = $cat_name;
        }
    }

    print "\n$bgreen=>> Insert a category number\n>$reset ";

    chomp(my $pick = <STDIN>);

    exit if $pick =~ /$quit_required/o;

    if ($pick =~ /$contains_arguments/o) {
        parse_arguments(grep((chr ord $_ eq '-'), split(/\s+/, $pick, 0)));
    }

    if (defined $categories_table{$pick}) {
        parse_url("$feeds_main_url/standardfeeds/recently_featured_$categories_table{$pick}");
    }
    else {
        categories_area();
    }
}

####################### PLAY OR DOWNLOAD AN YOUTUBE VIDEO #######################
sub MPlayer {

    print "** STREAMING: $streaming\n\n" if $debug;

    ## DOWNLOADING
    if ($download_video) {
        my $title = shift @_;
        $title =~ tr[/][|];    # replaces '/' with '|'

        if (not -e "$title.mp4") {
            if ($wget_is_available) {
                system "wget -nc '${streaming}' -O \Q$title\E.mp4";
            }
            else {
                print "** Saving to: '$title.mp4'\n";
                $lwp->show_progress(1);
                $lwp->mirror($streaming, "$title.mp4");
                $lwp->show_progress(0);
            }
        }
        else {
            warn "** '$title.mp4' already exists...\n";
        }
    }

    ## STREAMING
    else {
        print "** MPlayer Line: $MPlayerLine\n\n" if $debug;

        `$MPlayerLine '$streaming'` unless $debug;    # executing $MPlayerLine with '$streaming' as an argument

        chdir $constant{'cwd'} if exists $constant{'cwd'};    # change directory back to the main working directory
    }

    print "\n";

    disable_fullscreen_mode() unless $user_fullscreen;

    if (@picks) {
        foreach_pick();                                       # go to the next video if there are more videos selected to play
    }
    elsif ($playback) {
        next_page();
    }

    if ($video_results and not $dont_exit) {
        print_results();                                      # go back to the video results
    }

    exit unless $dont_exit;
}

####################### SEARCH YOUTUBE VIDEOS #######################
search() unless $dont_exit or $playlists;

sub search {
    $SEARCH = shift() // $SEARCH;
    $SEARCH = join(' ', grep((chr ord $_ ne '-'), split(/\s+/, $SEARCH, 0)));    # get words that doesn't start with '-'
    $SEARCH = uri_escape($SEARCH);
    $YOUTUBE_GDATA_URL =
        $feeds_main_url
      . '/videos?q='
      . $SEARCH
      . '&max-results='
      . $results
      . '&time='
      . $time_p
      . '&orderby='
      . $order_by
      . '&start-index='
      . $start_index . '&v=2';

    if (defined $from_author) {
        $YOUTUBE_GDATA_URL .= '&author=' . $from_author;
    }

    if (defined $region) {
        $YOUTUBE_GDATA_URL .= '&region=' . $region;
    }
    parse_content($YOUTUBE_GDATA_URL);
    print_results();
}

####################### PREPARE GDATA FEEDS URL #######################
sub parse_url {
    $YOUTUBE_GDATA_URL = shift() // $YOUTUBE_GDATA_URL;

    if ($YOUTUBE_GDATA_URL =~ /^$feeds_main_url/o) {

        if (not $YOUTUBE_GDATA_URL =~ /\?/) {
            $YOUTUBE_GDATA_URL .= "?start-index=$start_index";
        }
        else {
            $YOUTUBE_GDATA_URL .= "&start-index=$start_index";
        }

        $YOUTUBE_GDATA_URL .= "&max-results=$results&v=2";

        if (defined $region) {
            $YOUTUBE_GDATA_URL .= "&region=$region";
        }
        parse_content($YOUTUBE_GDATA_URL);
        print_results();
    }
    else {
        search $YOUTUBE_GDATA_URL;
    }
}

####################### GET AND PARSE GDATA CONTENT #######################
sub parse_content {

    UserAgent unless $lwp_is_set;

    undef @Videos;

    my ($author, $code, $title, $category, $published, $duration, $views, $description);
    my $number = 0;

    foreach my $entry (split(/<entry/, $lwp->get($_[0])->content, 0)) {

        my %gdata;
        while ($entry =~ /$xml_parser/og) {
            $gdata{$1} = $2 if defined $1;
            $gdata{$3} = $4 if defined $3;
        }

        $playlists
          ? do { next unless exists $gdata{'yt:playlistId'} }
          : do { next unless exists $gdata{'yt:videoid'} };

        ++$number;

        $playlists
          ?

          # PlaylistID, Number, Title, Description, Author, VideosCount
          push(
            @Videos,
            [$gdata{'yt:playlistId'},
             do { $number < 10 ? ' ' . $number : $number },
             do {
                 my $title = $gdata{'title'} // 'Unknown';
                 $title =~ /$has_entities/o ? ($title = decode_entities($title)) : $title;
             },
             do {
                 my $summary = $gdata{'summary'} // "\b";
                 $summary = join(' ', split(/\s+/, $summary));
                 $summary =~ /$has_entities/o
                   ? (length($summary) > 32)
                       ? (substr(decode_entities($summary), 0, 32))
                       : decode_entities($summary)
                   : (length($summary) > 32) ? (substr($summary, 0, 32))
                   :                           $summary;
             },
             $gdata{'name'},
             do { $gdata{'yt:countHint'} // $gdata{'countHint'} }
            ])
          :

          # VideoID, Title, Author, Duration, Views, Date, CategoryLabel, Description, Number
          push(
            @Videos,
            [$gdata{'yt:videoid'},
             do {
                 my $title = $gdata{'media:title'} // $gdata{'title'} // 'Unknown';
                 $title =~ /$has_entities/o ? decode_entities($title) : $title;
             },
             do { $gdata{'name'} // $gdata{'media:credit'} },
             format_time($gdata{'yt:duration seconds'}),
             $gdata{'viewCount'},
             do { $gdata{'yt:uploaded'} // $gdata{'published'} },
             $gdata{'label'},
             $gdata{'media:description'},
             do { $number < 10 ? ' ' . $number : $number }
            ]);

    }
    print "\n";
}

sub format_time {
    my $sec = shift @_;
    my $time = join(':', map((length $_ == 1 ? 0 . $_ : $_), $sec / 3600 % 24, $sec / 60 % 60, $sec % 60));
    $time =~ s/^00://;
    $time;
}

####################### PRINT RESULTS FROM @Videos #######################
sub print_results {

    if (not @Videos) {
        print "$bred(x_x) No video results!$reset\n";
        insert_url();
    }
    else {
        $video_results = 1;
    }

    foreach my $video (@Videos) {
        $colours
          ? print $cblack, $bred, $$video[8], $reset, $cblack, ' - ', $byellow, $$video[1], $reset, $cblack, ' (', $bpurle, 'by ',
          $$video[2], $reset, $cblack, ') (', $bblue, $$video[3], $reset, $cblack, ')', $reset, "\n"
          : print $bred, $$video[8], $reset, ' - ', $$video[1], ' (by ', $$video[2], ') (', $$video[3], ")\n";
    }

    if ($playback) {
        @picks = 1 .. scalar @Videos;
        foreach_pick();
    }

    print "\n$bred=>>$reset$bgreen Insert a number or search something else\n$reset> ";

    chomp(my $stdin = <STDIN>);

    exit if $stdin =~ /$quit_required/o;

    if ($stdin =~ /$contains_arguments/o) {
        parse_arguments(grep((chr ord $_ eq '-'), split(/\s+/, $stdin, 0)));
    }

    if ($stdin eq 'next' or $stdin =~ /^\s*$/) {
        next_page();
    }
    elsif ($stdin eq 'reset') {
        @ARGV = $SEARCH;
        do $0;
    }
    elsif (
        $stdin eq 'back' and do {
            $YOUTUBE_GDATA_URL =~ /\bstart-index=(\d+)/;
            $1 > $results;
        }
      ) {
        previous_page();
    }
    elsif ($stdin =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
    elsif ($stdin =~ /$get_playlist_code/o) {
        list_playlist $1;
    }
    elsif ($stdin =~ /$valid_playlist_code/o) {
        list_playlist $stdin;
    }
    elsif ($stdin =~ m[^https?://] and $stdin =~ /$valid_url/o) {
        code_from_content $stdin;
    }
    elsif ($stdin eq 'all') {
        parse_arguments('--1080p') unless $user_resolution;
        @picks = 1 .. scalar @Videos;
        foreach_pick();
    }
    elsif ($stdin =~ /\d/ and not $stdin =~ /(?:\s|^)[^\d-]/) {
        $stdin =~ s/(?:\D|^)-+\d+(?:\w+)?//g;                       # remove resolution arguments (e.g.: --360p);
        $stdin =~ s/(\d+)(?:-|\.\.)(\d+)/join ' ', $1 .. $2;/eg;    # '2..5' results in '2 3 4 5'
        @picks = grep({$_ > 0 and $_ <= scalar @Videos if /^\d+$/} split(/\D+/, $stdin, 0));
        foreach_pick() if scalar @picks or search($stdin);
    }
    else {
        search $stdin;
    }
}

####################### GO TO THE NEXT PAGE #######################
sub next_page {

    if ($YOUTUBE_GDATA_URL =~ /[&?]start-index=(\d+)/) {
        $YOUTUBE_GDATA_URL =~ s/index=($1)/'index=' . ($1 + $results);/e;
        parse_content $YOUTUBE_GDATA_URL;
        print_results();
    }
}

####################### GO TO THE PREVIOUS PAGE #######################
sub previous_page {

    if ($YOUTUBE_GDATA_URL =~ /[&?]start-index=(\d+)/) {
        $YOUTUBE_GDATA_URL =~ s/index=($1)/'index=' . ($1 - $results);/e;
        parse_content $YOUTUBE_GDATA_URL;
        print_results();
    }
}

sub foreach_pick {
    while (@picks) {
        get_youtube($Videos[shift(@picks) - 1]);
    }
}

sub set_fullscreen_mode {
    unless ($MPlayerLine =~ /-fs /) {
        $constant{'win32'}
          ? $MPlayerLine =~ s/mplayer\.exe"/mplayer.exe" -fs/
          : $MPlayerLine =~ s/mplayer /mplayer -fs /;
    }
}

sub disable_fullscreen_mode {
    $MPlayerLine =~ s/-fs //;
}

sub select_resolution {
    if ($resolution{'resolution'} == 1080) {
        if (exists $streaming{1080}) {
            $streaming = $streaming{1080};
            default_cache();
            set_fullscreen_mode() unless $user_fullscreen;
        }
        else {
            $streaming = lower_quality();
            lower_cache();
        }
    }
    elsif ($resolution{'resolution'} == 720) {
        if (exists $streaming{720}) {
            $streaming = $streaming{720};
            default_cache();
        }
        else {
            $streaming = lower_quality();
            lower_cache();
        }
    }
    elsif ($resolution{'resolution'} == 480) {
        $streaming = $streaming{480} // lower_quality();
        lower_cache();
    }
    elsif ($resolution{'resolution'} == 360) {
        $streaming = $streaming{360} // lower_quality();
        lower_cache();
    }
    elsif ($resolution{'resolution'} == 240) {
        $streaming = $streaming{240} // lower_quality();
        lower_cache();
    }
    else {
        if (exists $streaming{1080}) {
            pick();
        }
        elsif (exists $streaming{720}) {
            $streaming = $streaming{720};
            default_cache();
        }
        else {
            $streaming = lower_quality();
            lower_cache();
        }
    }
}

sub lower_quality {
    foreach my $itag (sort { $b <=> $a } values %itags) {
        if (exists($streaming{$itag})) {
            return $streaming{$itag};
        }
    }
}

sub format_itags {
    my @itags;

    foreach my $itag (@_) {
        if (exists($itags{$itag})) {
            push @itags, $itags{$itag};
        }
    }
    @itags;
}

sub get_youtube {

    # VideoID, Title, UploaderName, Duration, Views, Date, CategoryLabel, Description, Number
    my ($code, $title, $author, $duration, $views, $published, $category, $description) = ref $_[0] ? @{$_[0]} : @_;

    if (defined($description)) {
        $description = decode_entities($description) if $description =~ /$has_entities/o;
    }
    else {
        $description = 'No description available...';
    }

    UserAgent() unless $lwp_is_set;

    my $content = $lwp->get("$get_video_info?&video_id=$code&el=detailpage&ps=default&eurl=&gl=US&hl=en")->content;

    my $url = "http://www.youtube.com/watch?v=$code";

    $MPlayerLine =~ s/ *\Q$mplayer_srt_settings\E *-sub.*//;

    if (    -e $gcap
        and not $MPlayerLine =~ / -novideo/
        and $content =~ /&has_cc=True&/
        and not $download_video) {

        unless (exists $constant{'cwd'}) {
            require Cwd;
            $constant{'cwd'} = Cwd::getcwd();
        }

        chdir $constant{'tmp_dir'};    # change directory to 'tmp_dir' and get the .srt file

        unless (-e "${code}_$default_sub.srt") {
            system "perl $gcap '${url}'";
        }

        my @srt_files;
        my $dir_h;

        opendir $dir_h, $constant{'tmp_dir'};
        /\.srt$/ and push @srt_files, $_ while defined($_ = readdir $dir_h);
        closedir $dir_h;

        my $srt_file;

        foreach my $line (@srt_files) {
            if ($line =~ /${code}_$default_sub\.srt/) {
                $srt_file = "${code}_$default_sub.srt";
                $MPlayerLine .= " $mplayer_srt_settings -sub $srt_file";
            }
        }

        unless (defined $srt_file) {
            foreach my $line (@srt_files) {
                if ($line =~ /$code(\w*)\.srt/) {
                    $srt_file = "$code$1.srt";
                    $MPlayerLine .= " $mplayer_srt_settings -sub $srt_file";
                }
            }
        }
    }

    if ($content =~ /url_encoded_fmt_stream_map=(.+?)&/) {
        $streaming = $1;
        $streaming =~ s/%253A/:/gi;
        $streaming =~ s[%252F][/]gi;
        $streaming =~ s/%2526/&/g;
        $streaming =~ s/%253D/=/gi;
        $streaming =~ s/%253F/?/gi;
        $streaming =~ s/%25252C/,/gi;

        undef %streaming;

        my @streaming_urls = grep(/^https?:/, split(/url%3D(.+?)%26/, $streaming));
        @streaming{format_itags(map(/&itag=(\d+)&/, @streaming_urls))} =
          grep((
             exists $itags{
                 do { /&itag=(\d+)&/; $1 }
               }
            ),
            @streaming_urls);

        if ($debug) {
            while (my ($key, $value) = each %streaming) {
                print "KEY = $key\nVALUE = $value\n\n";
            }
        }

        print "\n";

        my $rating = sprintf('%.2f', ($content =~ /avg_rating=([^&]+)/));

        if (not defined $title) {
            parse_content("$feeds_main_url/videos/$code?v=2");
            ($code, $title, $author, $duration, $views, $published, $category, $description) = @{$Videos[0]};
        }

        $category =~ s/&amp;/&/;
        $published = "$3.$2.$1" if $published =~ /^(\d\d\d\d)-(\d\d)-(\d\d)/;

        if (length $views > 3) {
            my $l = length($views) - 3;
            my $i = ($l - 1) % 3 + 1;
            my $x = substr($views, 0, $i) . ',';
            while ($i < $l) {
                $x .= substr($views, $i, 3) . ',';
                $i += 3;
            }
            $views = $x . substr($views, $i);
        }

        print "$bred=>> $bgreen$title$reset\n",
          "$constant{'dash_line'}\n",
          "$description\n$constant{'dash_line'}\n",
          "$bred=>> ${bgreen}View & Download$reset\n",
          "$constant{'dash_line'}";

        my ($get) = $streaming_urls[0];
        print "\n* URL ";
        print STDOUT $url;
        print "\n* GET $get\n$constant{'dash_line'}\n",
          ' ' x ((length($constant{'dash_line'}) - length($title)) / 2 - 4),    # centring video title on terminal
          "$bred=>> $bgreen$title$reset$bred <<=\n$reset\n",
          "** Author    : $author\n",
          "** Category  : $category\n",
          "** Duration  : $duration\n",
          "** Rating    : $rating\n",
          "** Views     : $views\n",
          "** Published : $published\n",
          "$constant{'dash_line'}\n\n";

        select_resolution();
        MPlayer($title);
    }
    else {
        warn "\n$bred(x_x) Something went wrong...$reset\n\n$bred(x_x) Unable to stream: $reset$url\n\n";

        if ($video_results and not $dont_exit) {

            unless (@picks) {
                sleep 1;
                print_results();
            }
        }
        else {

            unless ($video_results or $dont_exit) {
                exit;
            }
        }
    }
}

sub pick {
    print "$bred=>>$reset $bgreen Please choose a video resolution (default: 1)$reset\n
$bred 1$reset - 1280x720  (720p)
$bred 2$reset - 1920x1080 (1080p)\n", '=' x 23, "\n\n$bgreen=>> Pick format:$reset ";

    chomp(my $pick = <STDIN>);

    exit if $pick =~ /$quit_required/o;

    print "$constant{'dash_line'}\n\n";

    if ($pick eq '2') {
        $streaming = $streaming{1080};
        $resolution{'resolution'} = 1080;
        default_cache();
        set_fullscreen_mode() unless $user_fullscreen;
    }
    else {
        $streaming = $streaming{720};
        $resolution{'resolution'} = 720;
        default_cache();
    }
}

sub lower_cache {    # set a lower cache if $user_lower_cache is TRUE
    $MPlayerLine =~ s/-cache\s+\d+/-cache 1000/      unless $user_cache;
    $MPlayerLine =~ s/-cache-min\s+\d+/-cache-min 3/ unless $user_cache_min;
}

sub default_cache {

    if (not $user_lower_cache) {
        $MPlayerLine =~ s/-cache\s+\d+/-cache $cache/             unless $user_cache;
        $MPlayerLine =~ s/-cache-min\s+\d+/-cache-min $cache_min/ unless $user_cache_min;
    }
    else {
        lower_cache();
    }
}
