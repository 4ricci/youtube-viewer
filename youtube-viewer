#!/usr/bin/perl

# Copyright (C) 2010-2011 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#-------------------------------------------------------
#  (C) 2010-2011 by Trizen
#  Created on: 02 Jun 2010
#  Latest edit on: 25 December 2011
#  Website: http://trizen.go.ro
#  Email: echo dHJpemVueEBnbWFpbC5jb20K | base64 -d
#-------------------------------------------------------
#
# [?] What is this script for?
#  - This script is useful to search and watch YouTube videos with MPlayer...
#  - Have fun!
#
# [!] The most important changes are written in the changelog!
#
# [CHANGELOG]
# - Added support for config file. Lines should be valid arguments (ex: 'arg=value'; '-arg')   - NEW (v2.5.5)
# - Switched to XML::Fast for parsing gdata XML, in consequence, youtube-viewer is faster!     - NEW (v2.5.5)
# - Switched to Getopt::Long, added SIGINT handler and a better way to execute mplayer         - NEW (v2.5.5)
# - Added support to list playlists created by a specific user (usage: -up <USERNAME>)         - NEW (v2.5.4)
# - Improved parsing support for arguments, including arguments specified via STDIN.           - NEW (v2.5.4)
# - Added support to search for videos uploaded by a particular YouTube user (-author=USER)    - NEW (v2.5.4)
# - Added support to get video results starting with a predefined page (ex: -page=4)           - NEW (v2.5.4)
# - Added support for previous page and support to list youtube usernames from a file          - (v2.5.2)
# - Added few options to control cache of MPlayer and lower cache for lower video resolutions  - (v2.5.1)
# - Added colours for text (--colours) or $colours = 1, 360p support (-3), playlist support    - (v2.5.0)
# - Added support for today and all time Youtube tops (usage: -t, --tops, -a, --all-time)      - (v2.4.*)
# - Re-added the support for the next page / Added support for download (-d, --download)       - (v2.4.*)
# - Added support for Youtube CCaptions. (Depends on: 'gcap' - http://gcap.googlecode.com)     - (v2.4.*)
# - First version with Windows support. Require SMPlayer to play videos. See MPlayer Line      - (v2.4.*)
# - Code has been changed in a proportion of ~60% and optimized for speed // --480 became -4   - (v2.4.*)
# - Added mega-powers of omnibox to the STDIN :)                                               - (v2.3.*)
# - Re-added the option to list and play youtube videos from a user profile. Usage: -u [user]  - (v2.3.*)
# - Added a new option to play only the audio track of a videoclip. Usage: [words] -n          - (v2.3.*)
# - Added option for fullscreen (-f, --fullscreen). Usage: youtube-viewer [words] -f           - (v2.3.*)
# - Added one new option '-c'. It shows available categories and will let you to choose one.   - (v2.3.*)
# - Added one new option '-m'. It shows 3 pages of youtube video results. Usage: [words] -m    - (v2.3.*)
# - For "-A" option has been added 3 pages of youtube video results (50 clips)                 - (v2.3.*)
# - Added "-prefer-ipv4" to the mplayer line (videoclips starts in no time now).               - (v2.3.*)
# - Search and play videos at 480p, 720p. Ex: [words] --480, [words] -A --480                  - (v2.3.*)
# - Added support to play a video at 480p even if it's resolution is higher. Ex: [url] --480   - (v2.2.*)
# - Added a nice feature which prints some informations about the current playing video        - (v2.2.*)
# - Added support to play videos by your order. Example: after search results, insert: 3 5 2 1 - (v2.1.*)
# - Added support for next pages of video results (press <ENTER> after search results)         - (v2.1.*)
# - Added support to continue playing searched videos, usage: "youtube-viewer [words] -A"      - (v2.1.*)
# - Added support to print counted videos and support to insert a number instead of video code - (v2.1.*)
# - Added support to search YouTube Videos in script (ex: youtube-viewer avatar trailer 2009)  - (v2.0.*)
# - Added support for script to choose automat quality if it is lower than 1080p               - (v2.0.*)
# - Added support to choose the quality only between 720p and 1080p (if it is available)       - (v2.0.*)
# - Added support for YouTube video codes (ex: youtube-viewer WVTWCPoUt8w)                     - (v1.0.*)
# - Added support for 720p and 1080p YouTube Videos...                                         - (v1.0.*)

# Special thanks to:
# - Army (for bugs reports and for his great ideas)
# - dhn (for adding youtube-viewer in freshports.org)

eval 'exec perl -S $0 ${1+"$@"}'
  if 0;    # not running under some shell

use strict;
use feature ('switch');
use autouse ('XML::Fast' => 'xml2hash');
use autouse ('URI::Escape' => 'uri_escape');
use autouse ('HTML::Entities' => 'decode_entities');

binmode *STDOUT, ":encoding(utf8)";

my $appname = 'youtube-viewer';
my $version = '2.5.5-git';

# Configuration file
#   ( in /home/user/.config/youtube-viewer/youtube-viewer.conf )
my $config_file = "$ENV{'XDG_CONFIG_HOME'}/$appname/$appname.conf";

#---------------------- MPLAYER OPTIONS ----------------------#
my $cache                = 30000;                                                           # default MPlayer cache
my $cache_min            = 5;                                                               # default MPlayer cache-min
my $user_lower_cache     = 0;                                                               # 1 will set a lower cache for MPlayer
my $mplayer_srt_settings = '-unicode -utf8';                                                # subtitle options
my $mplayer_settings     = "-prefer-ipv4 -cache $cache -cache-min $cache_min -really-quiet";

#---------------------- YOUTUBE OPTIONS ----------------------#
my $start_index = 1;                                                                        # index of the first matching result
my $results     = 20;                                                                       # number of video results
my $order_by    = 'relevance';
my $time_p      = 'all_time';
my $region;         # show YouTube movies from a particular region (default: undefined)
my $from_author;    # search videos uploaded by a particular user  (default: undefined)

#----------------------- OTHER OPTIONS -----------------------#
my $colours         = 0;       # 1 for colored output of video results
my $debug           = 0;       # 1 will run in debug mode
my $download_video  = 0;       # 1 will run wget or LWP for downloading videos instead of streaming them
my $lwp_downloading = 0;       # 1 will always download videos with LWP (default: wget (if is available))
my $playback        = 0;       # 1 will stream all available video results, including videos from next pages
my $default_sub     = 'en';    # default language for subtitles (requires gcap to get YouTube CC's)
my $users_file = "$ENV{'HOME'}/.config/youtube_usernames.txt";

# itag => resolution
my %itags = (
             37 => 1080,
             22 => 720,
             35 => 480,
             43 => 210,
             34 => 360,
             5  => 240
            );

# Unchangeable variables
my %constant = (
         'dash_line'          => q{-} x 80,                                                  # used as a line separator
         'win32'              => $^O eq 'MSWin32' ? 1 : 0,                                   # true if running under Windows
         'thousand_separator' => q{,},                                                       # thousand separator for views number
         'tmp_dir'            => $ENV{'TMP'} // $ENV{'TEMP'} // $ENV{'TMPDIR'} // '/tmp',    # tmpdir is used to save srt files
               );

#----------------------- ASCII COLOURS -----------------------#
my $bred    = q{};
my $bgreen  = q{};
my $reset   = q{};
my $cblack  = "\e[40m";                                                                 # background black
my $byellow = "\e[1;33m";                                                               # bold yellow
my $bpurle  = "\e[1;35m";                                                               # bold purple
my $bblue   = "\e[1;34m";                                                               # bold blue

unless ($constant{'win32'}) {                                                           # if not running under Windows
    $bred   = "\e[1;31m";                                                               # set bold red
    $bgreen = "\e[1;32m";                                                               # set bold green
    $reset  = "\e[0m";                                                                  # set reset color
}

#---------------------- GLOBAL VARIABLES ----------------------#
my $keywords = q{};       # used to store keywords for search
my $youtube_gdata_url;    # used to store the gdata URL with API query parameters
my $feeds_main_url = 'https://gdata.youtube.com/feeds/api';
my $get_video_info = 'https://www.youtube.com/get_video_info';

my (@results, @picks, %resolution, %streaming);    # other global variables

#------------------------ REGEXP AREA ------------------------#
my $has_entities        = qr/&#?\w/;                                               # checks if a string contains HTML entities
my $contains_arguments  = qr/(?:\s|^)-+\w/;                                        # checks if a string contains arguments
my $match_regexp        = qr{/((?:\\.|[^\\/])*)/};                                 # checks if the input looks like a regexp (//)
my $valid_playlist_code = qr/^(?:PL)?([0-9A-Z]{16})$/;                             # $1 will be the playlist code
my $get_youtube_code    = qr{\b(?:v|embed|youtu[.]be)(?:[=/]|%3D)([\w\-]{11})};    # $1 will be the video code

# $1 will be the playlist code
my $get_playlist_code = qr{(?:(?:(?:playlist[?]list|view_play_list[?]p)=)|\w#p/c/)(?:PL)?([A-Z0-9]{16})};

# $1 will be the Youtube username
my $get_username = qr{^https?://(?:www[.])?youtube[.]com/(?:user/)?(\w{2,})(?:[?].*)?$};

#-------------------------------------- REGEXP: URL VALIDATION --------------------------------------#
# The bellow regex will validate an HTTP url.
# If it is valid, youtube-viewer will try to get
# an youtube video code from that website using /$get_youtube_code/
my $valid_url = qr{^
        ################# This regex will validate an HTTP URL #################

                # Valid urls #######################################
                #      http://9.Yz                                 #
                #      http://m.example.com/test.html              #
                #      https://mail.example.com/mail/?ver=1#inbox  #
                #      http://test-test.test-test.museum?id=2      #
                ####################################################

                # Invalid urls #####################################
                #     http://-test.com                             #
                #     http://test-.com                             #
                #     http://test-.com                             #
                #     http://test..com                             #
                #     http://test.-.com                            #
                #     http://test.-test.com                        #
                ####################################################

                https?://                # http, https followed by ://
                [[:alnum:]]              # first character must be a-zA-Z0-9
                (?:(?:(?:\w*-+\w+|\w+)*  # words, dash, words OR only words
                \.(?=\w))+?              # point if followed by word char
                |                        # OR (validates http://x.yz)
                \.)                      # a single dot
                \w{2,6}                  # domain (words between 2 and 6 chars)
                (?:[#/?!]                # characters after domain
                [#-)+-;=?\\~\w]*)*       # the rest of characters of the string
$}x;

#---------------------- TEMPORARY OPTIONS ----------------------#
my $user_cache;         #               ||
my $user_cache_min;     #               ||
my $dont_exit;          #               \/
my $all_time;           # DON'T change this default values
my $lwp_is_set;         # unless you know what you're doing
my $video_results;      #               /\
my $user_resolution;    #               ||
my $playlists;          #               ||
my $user_fullscreen;    #               ||

#---------------------- PRE-CHECKS ----------------------#
# Check if https support is available
# If is not available, switch to http mode
unless (grep -e ("$_/LWP/Protocol/https.pm"), @INC) {
    $feeds_main_url =~ s/s//;
    $get_video_info =~ s/s//;
}

# Checking if config file exists
if (-e $config_file) {
    open my $fh, '<', $config_file;
    while (defined(my $line = <$fh>)) {
        next if chr ord $line eq '#';
        chomp $line;
        $line =~ s/\s*=\s*/=/;
        $line =~ s/^\s*-+//;
        next unless $line =~ /^\w/;
        unshift @ARGV, "-$line";
    }
    close $fh;
}

# Defining $mplayer_line
my $mplayer_line;
if ($constant{'win32'}) {
    my $smplayer = $ENV{'ProgramFiles'} . '\\SMPlayer\\mplayer\\mplayer.exe';    # Windows SMPlayer path
    if (-e $smplayer) {
        $mplayer_line = qq["$smplayer" $mplayer_settings];                       # Windows MPlayer line
    }
    else {
        warn "\n\n!!! Please install SMPlayer to stream Youtube videos.\n\n";
        $mplayer_line = "mplayer $mplayer_settings";
    }
}
else {
    $mplayer_line = "mplayer $mplayer_settings";                                 # *NIX MPlayer line
}

#---------------------- MY PATH ----------------------#
my @path =
  $constant{'win32'}
  ? split(/;/, $ENV{'PATH'})
  : split(/:/, $ENV{'PATH'});

#---------------------- LOOKING FOR WGET ----------------------#
my $wget_is_available;

sub locate_wget {
    if (-x '/usr/bin/wget'
        or grep { $constant{'win32'} ? -e "$_\\wget" : -x "$_/wget" } @path) {
        $wget_is_available = 1;
    }
}

#---------------------- LOOKING FOR GCAP ----------------------#
my $gcap = '/usr/bin/gcap';    # default gcap path
foreach my $path (@INC, @path) {
    if (-e "$path/gcap") {
        $gcap = "$path/gcap";
        last;
    }
}

#---------------------- LWP::UserAgent ----------------------#
my $lwp;

sub set_lwp_useragent {
    require LWP::UserAgent;
    $lwp = 'LWP::UserAgent'->new(
                                 'keep_alive' => 1,
                                 'env_proxy'  => 1,
                                 'timeout'    => 30
                                );
    $lwp->agent('Mozilla/5.0 (X11; U; Linux i686; en-US) Chrome/10.0.648.45');
    $lwp->show_progress(1) if $debug;
    $lwp_is_set = 1;
}

#---------------------- TRUE IF ARGUMENT LOOKS LIKE AN YOUTUBE CODE ----------------------#
sub is_code {
    return 1
      if length $_[0] == 11
          and $_[0] =~ /^[\w\-]{11}$/
          and $_[0] =~ /[\d[:upper:]_\-]/;
    return 0;
}

#---------------------- Convert args (of length of 11) to Youtube URLs ----------------------#
my @argv;
foreach my $arg (@ARGV) {
    if (is_code($arg)) {
        push @argv, "http://www.youtube.com/watch?v=$arg";
    }
    else {
        push @argv, $arg;
    }
}
@ARGV = @argv;

# Exit unless there are more videos selected to play
$SIG{'INT'} = sub {
    @picks > 1
      ? do {
        @picks    = ();
        $playback = 0;
      }
      : do {
        print "\n";
        exit;
      }
};

sub require_getopt_long {
    require Getopt::Long;
    Getopt::Long::Configure('no_auto_abbrev', 'no_ignore_case');
}

# Parsing arguments
if (@ARGV) {
    parse_arguments(@ARGV);
}

sub parse_arguments {
    require_getopt_long();
    Getopt::Long::GetOptionsFromArray(
        \@_,

        # Help and version
        'help|h|?'  => \&help,
        'tricks|T'  => \&tricks,
        'version|v' => \&version,

        # Categories
        'playlist|p!'  => \$playlists,
        'categories|c' => \&categories_area,
        'movies|M'     => \&youtube_movies,
        'today|t'      => \&youtube_tops,
        'username|u=s' => sub {
            videos_from_username(pop());
        },
        'user-playlists|up=s' => sub {
            playlists_from_username(pop());
        },
        'users|U:s' => sub {
            list_user_names(
                do {
                    length $_[1]
                      ? pop()
                      : $users_file;
                  }
            );
        },

        # Resolutions
        '240p|2' => sub {
            $resolution{'resolution'} = 240;
        },
        '360p|3' => sub {
            $resolution{'resolution'} = 360;
        },
        '480p|4' => sub {
            $resolution{'resolution'} = 480;
        },
        '720p|7' => sub {
            $resolution{'resolution'} = 720;
        },
        '1080p|1' => sub {
            $resolution{'resolution'} = 1080;
        },

        # YouTube options
        'time=s'   => \$time_p,
        'author=s' => \$from_author,
        'more|m'   => sub {
            $results = 50;
        },
        'order-by|o=s' => \$order_by,
        'region|r=s'   => \$region,
        'all-time|a'   => sub {
            $all_time = 1;
            youtube_tops();
        },
        'page=i' => sub {
            $start_index = $results * pop() - $results + 1;
        },

        # MPlayer options
        'fullscreen|fs|f' => sub {
            set_fullscreen_mode();
            $user_fullscreen = 1;
        },
        'no-fullscreen|F|FS' => sub {
            disable_fullscreen_mode();
            $user_fullscreen = 1;
        },
        'mplayer=s' => sub {
            $mplayer_line .= ' ' . pop();
        },
        'lower-cache|l' => \$user_lower_cache,
        'cache=i'       => sub {
            my $local_cache = pop();
            $mplayer_line =~ s/(?<=-cache) +\d+/ $local_cache/;
            $user_cache = 1;
        },
        'cache-min=i' => sub {
            my $local_cache_min = pop();
            $mplayer_line =~ s/(?<=-cache-min) +\d+/ $local_cache_min/;
            $user_cache_min = 1;
        },
        'novideo|n' => sub {
            $constant{'win32'}
              ? $mplayer_line =~ s/\b(?<=mplayer[.]exe")/ -novideo/
              : $mplayer_line =~ s/\b(?<=mplayer)\b/ -novideo/;
            $resolution{'resolution'} = 480 unless $user_resolution;
        },
        'gnome-mplayer|G' => sub {
            substr($mplayer_line, 0, 0, 'gnome-');
            $mplayer_line =~ s/\B-.+//;
        },

        # Other options
        'debug!'          => \$debug,
        'play-all|all|A!' => \$playback,
        'download|d'      => sub {
            $download_video = 1;
            if (    not $lwp_downloading
                and not $wget_is_available) {
                locate_wget();
            }
        },
        'quiet|q' => sub {
            close *STDOUT;
        },
        'lwp-download|L!' => \$lwp_downloading,
        'lang|sub=s'      => sub {
            $default_sub = pop();
            $default_sub = lc $default_sub
              unless $default_sub =~ /_/;
        },
        'proxy|P' => sub {
            my $proxy = pop();
            set_lwp_useragent() unless $lwp_is_set;
            $proxy = 'http://' . $proxy
              unless $proxy =~ m{^(?:ht|f)tps?://};
            $lwp->proxy(['http', 'https', 'ftp', 'ftps'], $proxy);
        },
        'colors|colours|C' => sub {
            $colours = 1 unless $constant{'win32'};
        },
    );

    #-------- END of GetOptionsFromArray --------#

    if (exists $resolution{'resolution'}) {
        $user_resolution = 1;
    }
    else {
        $resolution{'resolution'} = 0;
    }

    # Set 1080p resolution if $playback is 1
    # and not any other resolution is selected
    if ($playback and not $user_resolution) {
        $resolution{'resolution'} = 1080;
    }
    $keywords = join(q{ }, get_keywords_from_array(\@_))
      if @_;
    search_playlists()
      if $playlists;
}

#---------------------- PARSING VIDEO CODES SPECIFIED AS ARGUMENTS ----------------------#
foreach my $code (@ARGV) {
    given ($code) {
        when (/$get_playlist_code/o) {
            list_playlist($1);
        }
        when (/$valid_playlist_code/o) {
            list_playlist($1);
        }
        when (/$get_youtube_code/o) {
            $dont_exit = 1;
            get_youtube($1);
        }
        when (/$get_username/o) {
            videos_from_username($1);
        }
        when (m{^https?://} and /$valid_url/o) {
            code_from_content($_);
        }
    }
}

sub quit_required {
    return 1 if (   $_[0] eq 'q'
                 or $_[0] eq 'quit'
                 or $_[0] eq 'exit');
    return 0;
}

#---------------------- GO TO insert_url() IF $non_argv is FALSE ----------------------#
sub insert_url {
    print "\n$bred=>>$bgreen Insert an YouTube URL or search something...$reset\n> ";

    given (<STDIN>) {
        chomp;
        when (\&quit_required) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(get_arguments_from_string(\$_));
        }
        when (/$get_youtube_code/o) {
            get_youtube($1);
        }
        when (/$get_playlist_code/o) {
            list_playlist($1);
        }
        when (/$valid_playlist_code/o) {
            list_playlist($1);
        }
        when (\&is_code) {
            get_youtube($_);
        }
        when (/$get_username/o) {
            videos_from_username($1);
        }
        when (m{^https?://} and /$valid_url/o) {
            code_from_content($_);
        }
        when ($_ eq q{}) {
            warn "\n$bred(x_x) Unable to continue...$reset\n\n";
            exit;
        }
        default {
            search($_);
        }
    }
}
insert_url() unless length $keywords;

#---------------------- GET A VIDEO CODE FROM AN WEBSITE CONTENT ----------------------#
sub code_from_content {
    set_lwp_useragent() unless $lwp_is_set;

    if ($lwp->get($_[0])->content =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
    else {
        search($_[0]);
    }
}

#---------------------- YOUTUBE-VIEWER USAGE ----------------------#
sub help {
    print "\n  " . q{=} x 30 . " \U$appname\E " . q{=} x 30 . "
\t\t\t\t\t\t by Trizen (trizenx\@gmail.com)
\nUsage: $appname [options] ([code] || [url] || [keywords])
\nBase Options:
   <url>                : play an YouTube video by URL
   <code>               : play an YouTube video by code
   <keywords>           : search and list YouTube videos
   <playlist_url>       : list a playlist of YouTube videos
\nYouTube options:
   -t, --today          : shows today YouTube tops
   -a, --all-time       : shows all time YouTube tops
   -c, --categories     : shows available YouTube categories
   -m, --more           : shows more video results (50 clips)
   -p, --playlist       : search for YouTube playlists
   -M, --movies         : show YouTube movies categories
   --region=<ID>        : set a specific regionID (ex: US)
   -u  <username>       : list videos uploaded by a specific user
   -up <username>       : list playlists created by a specific user
   -author='USERNAME'   : search videos uploaded by a particular user
   -order-by='ORDER'    : order entries by: published, viewCount or rating
   -time='TIME'         : valid values are: today, this_week and this_month
   -page='PAGE_NR'      : show video results starting with page number 'n'
   -2, -3, -4, -7, -1   : plays videos at 240p, 360p, 480p, 720p or 1080p
\nMPlayer options:
   -f, --fullscreen     : plays video(s) in fullscreen mode
   -F, --no-fullscreen  : disable fullscreen mode
   -n, --novideo        : plays only the audio track of video(s)
   -l, --lower-cache    : set a lower cache for MPlayer (for slow connections)
   -mplayer='SETTINGS'  : add some extra options to the MPlayer line
   -sub='LANG'          : subtitle language (default: en) (depends on gcap)
   -cache='VALUE'       : set cache for MPlayer (default: $cache)
   -cache-min='VALUE'   : set cache-min for MPlayer (default: $cache_min)
\nOther options:
   -d, --download       : downloads YouTube video(s) with LWP
   -A, --all            : plays all video results in order
   -C, --colors         : use colors for text output
   -U, --users=file.txt : list YouTube usernames from a file
   -P, --proxy=<PROXY>  : set proxy for LWP::UserAgent
   -L, --lwp-download   : download videos with LWP (default: wget)
   -G, --gnome-mplayer  : use gnome-mplayer instead of mplayer
   -T, --tricks         : show more 'hidden' features of $appname
   -q, --quiet          : display no output
   -v, --version        : prints version and exits
   -h, --help           : prints help and exits
\nTips and tricks:
  1. After search results, press <ENTER> for the next page
  2. After search results, insert 'back' for the previous page
  3. View more tips and tricks by executing '$appname -T'\n\n";
    exit;
}

#---------------------- YOUTUBE-VIEWER TIPS AND TRICKS ----------------------#
sub tricks {
    print "
                        $bred>>$bgreen Tips and tricks $bred<<$reset

\n$bred*$bgreen After search results you can insert:$reset
    <ENTER>, next   : for the next page of video results
    back            : for the previous page of video results
    reset           : reset all arguments (application restarts)
    4 5 9 1         : play videos in a specific order
    2-6, 2..6       : same thing as 2 3 4 5 6
    2,5 -f          : play 2nd and 5th video in fullscreen mode $bred*$reset
    10 -d           : download 10th video with LWP or wget $bred*$reset
    /REGEXP/        : play videos matched by a regexp  (e.g.: /part [2-6]/)
    <YOUTUBE URL>   : play an YoutTube video specified by URL
    <UNKNOWN URL>   : connect to URL and get an YouTube code from it
    <ARGUMENTS>     : apply some arguments during the run-time
                      (example: -u=USERNAME, -p, -c, test --author=USERNAME)
\n$bred*$reset Arguments will remain activated!
\n$bred*$bgreen Did you know that...$reset
    -p as a STDIN argument, will return to playlists menu;\n
    -A option will play ALL video results, including videos from the next pages;\n
    $appname prints to STDOUT the current playing YouTube URL;\n
    /REGEXP/ will match case-insensitive (e.g.: 'test' matches 'TeSt');\n
    When multiple videos are selected to play, pressing CTRL+C
        will just empty the playlist and return to video results.
\n$bred*$bgreen Configuration file$reset
    Since 2.5.5 version, $appname supports a configuration file.
    Config file is: '$config_file'
    Valid lines are the same as available arguments (see --help)\n
    Example of configuration file:
        # $appname config
            --720p
            -colors
            cache = 1400
\n$bred*$bgreen Usage examples:$reset\n
 ** Show videos uploaded by 'MIT' that matches 'computer science',
    starting with page number 2, in fullscreen mode and 720p resolution.
    % $appname --author=MIT computer science --page=2 -fs --720p\n
 ** Show playlists created by a specific user
    % $appname -up khanacademy\n
 ** Show latest videos (50) uploaded by a specific user and a colourful output
    % $appname -m -C -u google\n\n";
    exit;
}

#---------------------- YOUTUBE-VIEWER VERSION ----------------------#
sub version {
    print "Youtube Viewer $version\n";
    exit;
}

#---------------------- LIST YOUTUBE USERNAMES FROM A FILE ----------------------#
sub list_user_names {

    my $users_file = shift();
    return unless -f $users_file;

    my $i = 0;
    my %usernames_table;
    print "\n";

    open my $fh, '<:crlf', $users_file or die $!;
    while (defined(my $username = <$fh>)) {
        next unless $username =~ /^\w+$/;
        chomp $username;
        ++$i;
        print do {
            q{ } if $i < 10;
        }, "$bred$i$reset - $bgreen$username$reset\n";
        $usernames_table{$i} = $username;
    }
    close $fh;
    print "\n$bred=>$bgreen Pick an username number$reset\n> ";
    given (<STDIN>) {
        chomp;
        when (\&quit_required or $_ eq q{}) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(get_arguments_from_string(\$_));
            continue;
        }
        when (exists $usernames_table{$_}) {
            videos_from_username($usernames_table{$_});
        }
        when (/^\w+$/) {
            videos_from_username($_);
        }
        when (/$match_regexp/o) {
            my $match = qr/$1/i;
            my @found = ();
            my $found = 0;
            print "\n";
            while (my ($number, $username) = each %usernames_table) {
                if ($username =~ /$match/o) {
                    print $bred, do {
                        q{ }
                          if ++$found < 10;
                    }, "$found$reset - $bgreen$username$reset\n";
                    push(@found, $found);
                    $usernames_table{$found} = $username;
                }
            }
            if (@found > 1) {
                print "\n$bred=>>$bgreen Pick an username number$reset\n> ";
                given (<STDIN>) {
                    chomp;
                    when (\&quit_required or $_ eq q{}) {
                        exit;
                    }
                    when (exists $usernames_table{$_}) {
                        videos_from_username($usernames_table{$_});
                    }
                    default {
                        list_user_names();
                    }
                }
            }
            elsif (@found) {
                videos_from_username($usernames_table{$found[0]});
            }
            continue;
        }
        default {
            list_user_names();
        }
    }
}

#---------------------- GET VIDEOS FROM A SPECIFIC USER ----------------------#
sub videos_from_username {
    parse_url("$feeds_main_url/users/$_[0]/uploads");
}

#---------------------- PRINT PLAYLISTS ----------------------#
sub print_playlists {
    my ($playlist, $num) = @_;

    # PlaylistID (0), Number (1), Title (2), Description (3), Author (4), VideosCount (5)
    $colours
      ? print($cblack, $bred, do { ' ' if $num < 10 }, $num,
              $reset,                $cblack, q{ - },                 $byellow,
              ${$playlist->{title}}, $reset,  $cblack,                ' (',
              $bpurle,               'by ',   ${$playlist->{author}}, $reset,
              $cblack,               ') (',   $bblue,                 ${$playlist->{count}},
              $reset,                $cblack, ')',                    $reset,
              "\n"
             )
      : print($bred, do { ' ' if $num < 10 }, $num, $reset, ' - ', ${$playlist->{title}},
              ' (by ', ${$playlist->{author}}, ') (', ${$playlist->{count}}, ")\n"
             );
}

#---------------------- GET PLAYLISTS FROM A SPECIFIC USER ----------------------#
my $playlist_index;

sub playlists_from_username {
    my @playlists;
    $playlists = 1;
    my $username = shift();
    $playlist_index = shift() || $start_index;

    parse_content(
             "http://gdata.youtube.com/feeds/api/users/$username/playlists?max-results=$results&start-index=$playlist_index&v=2");

    unless (@results) {
        print "$bred(x_x) No playlist has been found...$reset\n";
        print "\n$bred=>>$bgreen Insert another username:$reset ";
        given (<STDIN>) {
            chomp;
            when (\&quit_required or $_ eq q{}) {
                exit;
            }
            default {
                playlists_from_username($_);
            }
        }
    }

    # PlaylistID, Number, Title, Description, Author, VideosCount
    my $num = 0;
    foreach my $playlist (@results) {
        print_playlists($playlist, ++$num);
    }

    print "\n$bred=>>$bgreen Pick one playlist or insert another username$reset\n> ";

    given (<STDIN>) {
        chomp;
        when (\&quit_required) {
            exit;
        }
        when (/$contains_arguments/o) {
            $playlists = 0;
            parse_arguments(get_arguments_from_string(\$_));
            $playlists = 1;
            continue;
        }
        when (/^\s*$/ or $_ eq 'next') {
            playlists_from_username($username, $playlist_index + $results);
        }
        when ($_ eq 'back' and $playlist_index > $results) {
            playlists_from_username($username, $playlist_index - $results);
        }
        when (/^\d+$/) {
            $playlists = 0;
            list_playlist(${$results[$_ - 1]->{playlistID}});
        }
        when (/^\w+$/) {
            playlists_from_username($_, $start_index);
        }
        default {
            playlists_from_username($username);
        }
    }
}

#---------------------- SEARCH FOR YOUTUBE PLAYLISTS ----------------------#
sub search_playlists {
    my $url = shift();

    if ($keywords ne '') {
        $url //= "$feeds_main_url/playlists/snippets?q=$keywords&start-index=$start_index&max-results=$results&v=2";
        $playlists = 1;
        parse_content($url);
    }
    else {
        return;
    }

    my $num = 0;
    foreach my $playlist (@results) {
        print_playlists($playlist, ++$num);
    }

    print "\n$bred=>>$bgreen Pick one playlist or search others$reset\n> ";

    given (<STDIN>) {
        chomp;
        when (\&quit_required) {
            exit;
        }
        when (/$contains_arguments/o) {
            $playlists = 0;
            parse_arguments(get_arguments_from_string(\$_));
            $playlists = 1;
            continue;
        }
        when (/^\s*$/ or $_ eq 'next') {
            $url =~ s/(?<=[&?]start-index=)(\d+)/($1 + $results);/e;
            search_playlists($url);
        }
        when ($_ eq 'back') {
            if (
                do {
                    $url =~ /[&?]start-index=(\d+)/;
                    $1 > $results;
                }
              ) {
                $url =~ s/(?<=[&?]start-index=)(\d+)/($1 - $results);/e;
                search_playlists($url);
            }
            else {
                continue;
            }
        }
        when (/^\d+$/) {
            $playlists = 0;
            list_playlist(${$results[$_ - 1]->{playlistID}});
        }
        default {
            $keywords = $_;
            search_playlists();
        }
    }
}

#---------------------- LIST A YOUTUBE PLAYLIST ----------------------#
sub list_playlist {
    parse_url("$feeds_main_url/playlists/$_[0]");
}

#---------------------- LIST YOUTUBE MOVIE CATEGORIES ----------------------#
sub youtube_movies {
    print "\n";
    my $i = 0;
    my %movie_table;
    foreach my $movie_cat_name ('most_popular', 'most_recent', 'trending') {
        my $cat_name = ucfirst $movie_cat_name;
        $cat_name =~ tr/_/ /;
        print q{ }, $bred, ++$i, "$reset - $cat_name\n";
        $movie_table{$i} = $movie_cat_name;
    }
    print "\n$bred=>>$bgreen Pick one category$reset\n> ";
    given (<STDIN>) {
        chomp;
        when (\&quit_required or $_ eq q{}) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(get_arguments_from_string(\$_));
        }
        when (exists $movie_table{$_}) {
            parse_url("$feeds_main_url/charts/movies/$movie_table{$_}");
        }
    }
}

#---------------------- LIST YOUTUBE TOP VIDEO CATEGORIES ----------------------#
sub youtube_tops {
    my $i             = 0;
    my $today         = $all_time ? 0 : 1;
    my $standardfeeds = "$feeds_main_url/standardfeeds";
    my %tops_table;
    print "\n";
    foreach my $cat_top_name (
                              'top_rated',   'top_favorites',  'most_viewed',    'most_popular',
                              'most_recent', 'most_discussed', 'most_responded', 'recently_featured'
      ) {
        my $top_name = ucfirst $cat_top_name;
        $top_name =~ tr/_/ /;
        print q{ }, $bred, ++$i, "$reset - $top_name\n";
        $tops_table{$i} = $cat_top_name;
    }

    print "\n$bred=>>$bgreen Pick one category$reset\n> ";

    given (<STDIN>) {
        chomp;
        when (\&quit_required or $_ eq q{}) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(get_arguments_from_string(\$_));
        }
        when (exists $tops_table{$_}) {
            my $url = $standardfeeds . q{/} . $tops_table{$_};
            if ($today
                and not $url =~ /recent/) {
                $url .= '?time=today';
            }
            parse_url($url);
        }
        default {
            youtube_tops();
        }
    }
}

#---------------------- LIST YOUTUBE VIDEO CATEGORIES ----------------------#
sub categories_area {
    set_lwp_useragent() unless $lwp_is_set;
    my $n = 0;
    my %categories_table;
    print "\n";
    foreach my $line (split /<atom:category term=/, $lwp->get('http://gdata.youtube.com/schemas/2007/categories.cat')->content) {
        if (not $line =~ /deprecated/
            and $line =~ /^'(.+?)'\s+label='(.+?)'/) {
            ++$n;
            my $cat_name  = $1;
            my $cat_label = $2;
            $cat_label =~ s/&amp;/&/;
            print do {
                q{ }
                  if $n < 10;
            }, $bred, $n, $reset, ' - ', $cat_label, "\n";
            $categories_table{$n} = $cat_name;
        }
    }
    print "\n$bred=>>$bgreen Insert a category number$reset\n> ";
    given (<STDIN>) {
        chomp;
        when (\&quit_required or $_ eq q{}) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(get_arguments_from_string(\$_));
        }
        when (exists $categories_table{$_}) {
            parse_url("$feeds_main_url/standardfeeds/recently_featured_$categories_table{$_}");
        }
        default {
            categories_area();
        }
    }
}

#---------------------- PLAY OR DOWNLOAD AN YOUTUBE VIDEO ----------------------#
sub play_or_download {
    my $streaming = shift;

    print "** STREAMING: $streaming\n\n" if $debug;

    ## DOWNLOADING
    if ($download_video) {
        my $title = shift @_;

        # Replacing reserved characters with a space
        $title =~ tr{\\/:*?"< >|}{ }s;
        if (not -e "$title.mp4") {
            if ($wget_is_available) {

                # Downloading video with wget
                system 'wget', '-nc', $streaming, '-O', "$title.mp4";
            }
            else {

                # Downloading video with LWP
                print "** Saving to: '$title.mp4'\n";
                $lwp->show_progress(1);
                $lwp->mirror($streaming, "$title.mp4");
                $lwp->show_progress(0);
            }
        }
        else {
            warn "** '$title.mp4' already exists...\n";
        }
    }

    ## STREAMING
    else {
        print "** MPlayer Line: $mplayer_line\n\n"
          if $debug;

        # Executing $mplayer_line with '$streaming' as an argument
        system split(/\s+/, $mplayer_line), $streaming
          unless $debug;

        # Change directory back to the main working directory
        chdir $constant{'cwd'}
          if exists $constant{'cwd'};
    }
    print "\n";
    disable_fullscreen_mode()
      unless $user_fullscreen;
    if (@picks) {
        foreach_pick();    # play the next video
    }
    elsif ($playback) {
        next_page();
    }
    if ($video_results
        and not $dont_exit) {
        print_results();    # back to video results
    }
    exit
      unless $dont_exit;
}

#---------------------- SEARCH YOUTUBE VIDEOS ----------------------#
if (length($keywords)) {
    search()
      unless $dont_exit
          or $playlists;
}

sub search {
    $keywords = shift() // $keywords;

    # Get words which doesn't begins with a dash (-);
    $keywords = join(q{ }, get_keywords_from_string(\$keywords));
    $keywords = uri_escape($keywords);
    $youtube_gdata_url =
        $feeds_main_url
      . '/videos?q='
      . $keywords
      . '&max-results='
      . $results
      . '&time='
      . $time_p
      . '&orderby='
      . $order_by
      . '&start-index='
      . $start_index . '&v=2';
    if (defined $from_author) {
        $youtube_gdata_url .= '&author=' . $from_author;
    }
    if (defined $region) {
        $youtube_gdata_url .= '&region=' . $region;
    }
    parse_content($youtube_gdata_url);
    print_results();
}

#---------------------- PREPARE GDATA FEEDS URL ----------------------#
sub parse_url {
    ($youtube_gdata_url) = @_;
    if ($youtube_gdata_url =~ /^$feeds_main_url/o) {
        $youtube_gdata_url .=
          $youtube_gdata_url =~ /[?]/
          ? '&'
          : '?';
        $youtube_gdata_url .= "start-index=$start_index&max-results=$results&v=2";
        if (defined $region) {
            $youtube_gdata_url .= "&region=$region";
        }
        parse_content($youtube_gdata_url);
        print_results();
    }
    else {
        search $youtube_gdata_url;
    }
}

#---------------------- GET AND PARSE GDATA CONTENT ----------------------#
sub parse_content {
    set_lwp_useragent() unless $lwp_is_set;

    undef @results;
    my $number = 0;
    my $hash   = xml2hash($lwp->get($_[0])->content);

    if ($playlists) {
        while (
               my $gdata =
                 ref $hash->{'feed'}{'entry'} eq 'ARRAY' ? \$hash->{'feed'}{'entry'}[$number]
               : ref $hash->{'feed'}{'entry'} eq 'HASH'  ? \$hash->{'feed'}{'entry'}
               : \$hash->{'entry'}
          ) {
            last unless defined $$gdata;

            # PlaylistID, Number, Title, Description, Author, VideosCount
            push @results,
              {
                'playlistID' => \$$gdata->{'yt:playlistId'},
                'title'      => \$$gdata->{title},
                'author'     => \$$gdata->{author}{name},
                'count'      => \$$gdata->{'yt:countHint'}
              };
            ++$number;
            last unless ref $hash->{'feed'}{'entry'} eq 'ARRAY';
        }
    }
    else {
        while (
               my $gdata =
                 ref $hash->{'feed'}{'entry'} eq 'ARRAY' ? \$hash->{'feed'}{'entry'}[$number]
               : ref $hash->{'feed'}{'entry'} eq 'HASH'  ? \$hash->{'feed'}{'entry'}
               : \$hash->{'entry'}
          ) {
            last unless defined $$gdata;

            # VideoID, Title, Author, Duration, Views, Date, CategoryLabel, Description, Number
            push @results,
              {
                'code'        => \$$gdata->{'media:group'}{'yt:videoid'},
                'title'       => \$$gdata->{'media:group'}{'media:title'}{'#text'},
                'author'      => \$$gdata->{'author'}{'name'},
                'duration'    => \format_time(\$$gdata->{'media:group'}{'yt:duration'}{'-seconds'}),
                'views'       => \$$gdata->{'yt:statistics'}{'-viewCount'},
                'published'   => \$$gdata->{'published'},
                'category'    => \$$gdata->{'category'}[1]{'-label'},
                'description' => \$$gdata->{'media:group'}{'media:description'}{'#text'}
              };
            ++$number;

            last unless ref $hash->{'feed'}{'entry'} eq 'ARRAY';
        }
    }
    print "\n";
    return 1;
}

# Format seconds to HH:MM:SS
sub format_time {
    my $tmp_time;
    do {
        $tmp_time = ${$_[0]} / 3600 % 24;
        $tmp_time > 0
          ? $tmp_time > 9
              ? "$tmp_time:"
              : "0$tmp_time:"
          : q{};
      }
      . do {
        $tmp_time = ${$_[0]} / 60 % 60;
        $tmp_time > 9
          ? $tmp_time
          : "0$tmp_time";
      }
      . q{:}
      . do {
        $tmp_time = ${$_[0]} % 60;
        $tmp_time > 9
          ? $tmp_time
          : "0$tmp_time";
      };
}

# Returns a list of arguments (from string ref)
sub get_arguments_from_string {
    return grep { chr ord $_ eq q{-} }
      split(/\s+/, ${$_[0]});
}

# Returns a list of keywords (from string ref)
sub get_keywords_from_string {
    return grep { chr ord $_ ne q{-} }
      split(/\s+/, ${$_[0]});
}

# Returns a list of keywords (from array ref)
sub get_keywords_from_array {
    return grep { chr ord $_ ne q{-} } @{$_[0]};
}

#---------------------- PRINT VIDEO RESULTS ----------------------#
sub print_results {

    if (@results) {
        $video_results = 1;
    }
    else {
        print "$bred(x_x) No video results!$reset\n";
        insert_url();
    }

    my $num = 0;
    foreach my $video (@results) {
        ++$num;

        $colours

          # Colored output (when using --colors, -C)
          ? print $cblack, $bred, do { ' ' if $num < 10 }, $num, $reset,
          $cblack, q{ - }, $byellow, ${$video->{title}}, $reset, $cblack,
          ' (', $bpurle, 'by ', ${$video->{author}}, $reset, $cblack, ') (',
          $bblue, ${$video->{duration}}, $reset, $cblack, ')', $reset, "\n"

          # Normal output
          : print $bred, do { ' ' if $num < 10 }, $num, $reset,
          q{ - }, ${$video->{title}}, ' (by ', ${$video->{author}},
          ') (', ${$video->{duration}}, ")\n";
    }

    if ($playback) {
        @picks = 1 .. @results;
        foreach_pick();
    }

    {
        print "\n$bred=>>$bgreen Insert a number or search something else$reset\n> ";

        given (<STDIN>) {
            chomp;
            when (\&quit_required) {
                exit;
            }
            when (/$contains_arguments/o) {
                parse_arguments(get_arguments_from_string(\$_));
                continue;
            }
            when (['reset', 'reload']) {
                @ARGV = ();
                do $0;
            }
            when (/^\s*$/ or $_ eq 'next') {
                next_page();
            }
            when ($_ eq 'back') {
                if (
                    do {
                        $youtube_gdata_url =~ /[&?]start-index=(\d+)/;
                        $1 > $results;
                    }
                  ) {
                    previous_page();
                }
                else {
                    continue;
                }
            }
            when ($_ eq 'all') {
                parse_arguments('--1080p')
                  unless $user_resolution;
                @picks = 1 .. scalar @results;
                foreach_pick();
            }
            when (/$get_youtube_code/o) {
                get_youtube($1);
            }
            when (/$get_playlist_code/o) {
                list_playlist($1);
            }
            when (/$valid_playlist_code/o) {
                list_playlist($_);
            }
            when (m{^https?://} and /$valid_url/o) {
                code_from_content($_);
            }
            when (chr ord $_ eq q{/} and /$match_regexp/o) {
                my $match = qr/$1/i;
                @picks = grep { $results[$_ - 1][1] =~ /$match/ } 1 .. @results;
                if (@picks) {
                    foreach_pick();
                }
                else {
                    warn "\n${bred}(X_X) No video matched by the regexp: $bgreen/$match/$reset\n\n";
                    sleep 1;
                    print_results();
                }
            }
            when (\&is_code) {
                get_youtube($_);
            }
            when (/\d/ and not /(?:\s|^)[^\d-]/) {
                s/(?:\D|^)-+\d+(?:\w+)?//g;                          # remove resolution arguments (e.g.: --360p);
                s/(\d+)(?:-|[.][.])(\d+)/join q{ }, $1 .. $2;/eg;    # '2..5' or '2-5' to '2 3 4 5'
                @picks = grep { $_ > 0 and $_ <= scalar @results if /^\d+$/ } split /[\s[:punct:]]+/, $_;
                @picks
                  ? foreach_pick()
                  : continue;
            }
            default {
                search(join(q{ }, get_keywords_from_string(\$_)) or redo);
            }
        }
    }
}

sub foreach_pick {
    while (@picks) {
        get_youtube($results[shift(@picks) - 1]);
    }
}

#---------------------- NEXT PAGE ----------------------#
sub next_page {
    if ($youtube_gdata_url =~ s/(?<=[&?]start-index=)(\d+)/($1 + $results);/e) {
        parse_content($youtube_gdata_url);
        print_results();
    }
}

#---------------------- PREVIOUS PAGE ----------------------#
sub previous_page {
    if ($youtube_gdata_url =~ s/(?<=[&?]start-index=)(\d+)/($1 - $results);/e) {
        parse_content($youtube_gdata_url);
        print_results();
    }
}

sub set_fullscreen_mode {
    unless ($mplayer_line =~ /-fs /) {
        $constant{'win32'}
          ? $mplayer_line =~ s/mplayer\.exe"/mplayer.exe" -fs/
          : $mplayer_line =~ s/mplayer /mplayer -fs /;
    }
}

sub disable_fullscreen_mode {
    $mplayer_line =~ s/-fs //;
}

sub select_resolution {
    given ($resolution{'resolution'}) {
        when (1080) {
            if (exists $streaming{1080}) {
                default_cache();
                set_fullscreen_mode()
                  unless $user_fullscreen;
                return $streaming{1080};
            }
            else {
                exists $streaming{720}
                  ? default_cache()
                  : lower_cache();
                return lower_quality();
            }
        }
        when (720) {
            if (exists $streaming{720}) {
                default_cache();
                return $streaming{720};
            }
            else {
                lower_cache();
                return lower_quality();
            }
        }
        when (480) {
            lower_cache();
            return $streaming{480} // lower_quality();
        }
        when (360) {
            lower_cache();
            return $streaming{360} // lower_quality();
        }
        when (240) {
            lower_cache();
            return $streaming{240} // lower_quality();
        }
        default {
            if (exists $streaming{1080}) {
                pick();
            }
            elsif (exists $streaming{720}) {
                default_cache();
                return $streaming{720};
            }
            else {
                lower_cache();
                return lower_quality();
            }
        }
    }
}

sub lower_quality {
    foreach my $itag (sort { $b <=> $a } values %itags) {
        if (exists($streaming{$itag})) {
            return $streaming{$itag};
        }
    }
}

sub format_itags {
    my @itags;
    foreach my $itag (@_) {
        if (exists($itags{$itag})) {
            push @itags, $itags{$itag};
        }
    }
    @itags;
}

sub get_closed_caption {

    my $code = ${$_[0]};

    # Removing the previous subtitle (if any)
    $mplayer_line =~ s/ *\Q$mplayer_srt_settings\E *-sub.*//;

    # Getting YouTube closed captions with gcap

    unless (exists $constant{'cwd'}) {
        require Cwd;
        $constant{'cwd'} = Cwd::getcwd();
    }

    # Change dir to $TMP and get the SRT file
    chdir $constant{'tmp_dir'};
    unless (-e "${code}_$default_sub.srt") {
        system 'perl', $gcap, $code;
    }

    my $srt_file;
    if (-e "${code}_$default_sub.srt") {
        $srt_file = "${code}_$default_sub\.srt";
        $mplayer_line .= " $mplayer_srt_settings -sub $srt_file";
    }
    else {
        opendir(my $dir_h, $constant{'tmp_dir'});
        while (defined(my $line = readdir $dir_h)) {
            next unless $line =~ /[.]srt$/;
            if ($line =~ /^$code\w*[.]srt/p) {
                $srt_file = ${^MATCH};
                $mplayer_line .= " $mplayer_srt_settings -sub $srt_file";
                last;
            }
        }
        closedir $dir_h;
    }
    return 1;
}

sub get_youtube {
    my $info = shift();

    if (ref $info ne 'HASH') {
        parse_content("$feeds_main_url/videos/$info?v=2");
        $info = $results[0];
    }

    my $code = ${$info->{code}};

    set_lwp_useragent() unless $lwp_is_set;

    my $content = $lwp->get("$get_video_info?&video_id=$code&el=detailpage&ps=default&eurl=&gl=US&hl=en")->content;
    my $url     = "http://www.youtube.com/watch?v=$code";

    if (    not $download_video
        and -e $gcap
        and not $mplayer_line =~ / -novideo/
        and $content =~ /&has_cc=True&/) {

        # Get Youtube closed caption
        get_closed_caption(\$code);
    }

    if ($content =~ /url_encoded_fmt_stream_map=(.+?)&/) {
        my $streaming = $1;
        $streaming =~ s/%253A/:/gi;
        $streaming =~ s{%252F}{/}gi;
        $streaming =~ s/%2526/&/g;
        $streaming =~ s/%253D/=/gi;
        $streaming =~ s/%253F/?/gi;
        $streaming =~ s/%25252C/,/gi;

        undef %streaming;
        my (@streaming_urls) =
          grep (/^https?:/, split(/url%3D(.+?)%26/, $streaming));
        @streaming{format_itags(map (/&itag=(\d+)&/, @streaming_urls))} =
          grep ((
             exists $itags{
                 do { /&itag=(\d+)&/; $1 }
               }
            ),
            @streaming_urls);

        if ($debug) {
            while (my ($key, $value) = each %streaming) {
                print "KEY = $key\nVALUE = $value\n\n";
            }
        }
        my $rating = sprintf('%.2f', ($content =~ /avg_rating=([^&]+)/));
        if (defined ${$info->{description}}) {
            ${$info->{description}} = decode_entities(${$info->{description}})
              if ${$info->{description}} =~ /$has_entities/o;
        }
        else {
            ${$info->{description}} = 'No description available...';
        }
        ${$info->{category}} =~ s/&amp;/&/;
        ${$info->{published}} //= 0;
        ${$info->{published}} = "$3.$2.$1"
          if ${$info->{published}} =~ /^(\d\d\d\d)-(\d\d)-(\d\d)/;

        # Thousand separator
        if (length ${$info->{views}} > 3 and index(${$info->{views}}, $constant{thousand_separator}) < 0) {
            my $l = length(${$info->{views}}) - 3;
            my $i = ($l - 1) % 3 + 1;
            my $x = substr(${$info->{views}}, 0, $i) . $constant{thousand_separator};
            while ($i < $l) {
                $x .= substr(${$info->{views}}, $i, 3) . $constant{thousand_separator};
                $i += 3;
            }
            ${$info->{views}} = $x . substr(${$info->{views}}, $i);
        }

        print "\n$bred=>> $bgreen${$info->{title}}$reset\n",
          "$constant{'dash_line'}\n",
          "${$info->{description}}\n$constant{'dash_line'}\n",
          "$bred=>> ${bgreen}View & Download$reset\n",
          "$constant{'dash_line'}\n* URL ";

        print STDOUT $url;

        print "\n* GET $streaming_urls[0]\n$constant{'dash_line'}\n",
          q{ } x ((length($constant{'dash_line'}) - length(${$info->{title}})) / 2 - 4),    # centring video title on terminal
          "$bred=>> $bgreen${$info->{title}}$bred <<=$reset\n\n",
          "** Author    : ${$info->{author}}\n",
          "** Category  : ${$info->{category}}\n",
          "** Duration  : ${$info->{duration}}\n",
          "** Rating    : $rating\n",
          "** Views     : ${$info->{views}}\n",
          do { ${$info->{published}} ? "** Published : ${$info->{published}}\n" : '' },
          "$constant{'dash_line'}\n";

        # Select one resolution and play video
        play_or_download(select_resolution(), ${$info->{title}});

    }
    else {

        # This happens when video has been deleted or forbidden
        warn "\n$bred(x_x) Something went wrong...$reset\n\n", "$bred(x_x) Unable to stream: $reset$url\n\n";
        if ($video_results and not $dont_exit) {
            unless (@picks) {
                sleep 1;
                print_results();
            }
        }
        else {
            unless ($video_results or $dont_exit) {
                exit;
            }
        }
    }
}

sub pick {
    print "\n$bred=>> $bgreen Please choose a video resolution (default: 1)$reset\n\n",
      "$bred 1$reset - 1280x720  (720p)\n",
      "$bred 2$reset - 1920x1080 (1080p)\n", q{=} x 23, "\n\n$bgreen=>> Pick format:$reset ";

    given (<STDIN>) {
        chomp;
        when (\&quit_required) {
            exit;
        }
        when ($_ eq q{2}) {
            $resolution{'resolution'} = 1080;
            default_cache();
            set_fullscreen_mode() unless $user_fullscreen;
            return $streaming{1080};
        }
        default {
            $resolution{'resolution'} = 720;
            default_cache();
            return $streaming{720};
        }
    }
}

# Set a lower cache if $user_lower_cache is TRUE
sub lower_cache {
    $mplayer_line =~ s/-cache\s+\d+/-cache 1000/      unless $user_cache;
    $mplayer_line =~ s/-cache-min\s+\d+/-cache-min 3/ unless $user_cache_min;
}

# Set default cache for 720p and 1080p resolutions
sub default_cache {
    if (not $user_lower_cache) {
        $mplayer_line =~ s/-cache\s+\d+/-cache $cache/             unless $user_cache;
        $mplayer_line =~ s/-cache-min\s+\d+/-cache-min $cache_min/ unless $user_cache_min;
    }
    else {
        lower_cache();
    }
}
