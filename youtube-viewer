#!/usr/bin/perl

# Copyright (C) 2010-2011 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#-------------------------------------------------------
#  (C) 2010-2011 by Trizen
#  Created on: 02 Jun 2010
#  Latest edit on: 12 November 2011
#  Website: http://trizen.go.ro
#  Email: echo dHJpemVueEBnbWFpbC5jb20K | base64 -d
#-------------------------------------------------------
#
# [?] What is this script for?
#  - This script is useful to search and watch YouTube videos with MPlayer...
#  - Have fun!
#
# [!] The most important changes are written in the changelog!
#
# [CHANGELOG]
# - Improved parsing support for arguments, including arguments specified via STDIN.           - NEW (v2.5.4)
# - Added support to search for videos uploaded by a particular YouTube user (-author=USER)    - NEW (v2.5.4)
# - Added support to get video results starting with a predefined page (ex: -page=4)           - NEW (v2.5.4)
# - Added support for previous page and support to list youtube usernames from a file          - NEW (v2.5.2)
# - Added few options to control cache of MPlayer and lower cache for lower video resolutions  - NEW (v2.5.1)
# - Added colours for text (--colours) or $colours = 1, 360p support (-3), playlist support    - NEW (v2.5.0)
# - Added support for today and all time Youtube tops (usage: -t, --tops, -a, --all-time)      - (v2.4.*)
# - Re-added the support for the next page / Added support for download (-d, --download)       - (v2.4.*)
# - Added support for Youtube CCaptions. (Depends on: 'gcap' - http://gcap.googlecode.com)     - (v2.4.*)
# - First version with Windows support. Require SMPlayer to play videos. See MPlayer Line      - (v2.4.*)
# - Code has been changed in a proportion of ~60% and optimized for speed // --480 became -4   - (v2.4.*)
# - Added mega-powers of omnibox to the STDIN :)                                               - (v2.3.*)
# - Re-added the option to list and play youtube videos from a user profile. Usage: -u [user]  - (v2.3.*)
# - Added a new option to play only the audio track of a videoclip. Usage: [words] -n          - (v2.3.*)
# - Added option for fullscreen (-f, --fullscreen). Usage: youtube-viewer [words] -f           - (v2.3.*)
# - Added one new option '-c'. It shows available categories and will let you to choose one.   - (v2.3.*)
# - Added one new option '-m'. It shows 3 pages of youtube video results. Usage: [words] -m    - (v2.3.*)
# - For "-A" option has been added 3 pages of youtube video results (50 clips)                 - (v2.3.*)
# - Added "-prefer-ipv4" to the mplayer line (videoclips starts in no time now).               - (v2.3.*)
# - Search and play videos at 480p, 720p. Ex: [words] --480, [words] -A --480                  - (v2.3.*)
# - Added support to play a video at 480p even if it's resolution is higher. Ex: [url] --480   - (v2.2.*)
# - Added a nice feature which prints some informations about the current playing video        - (v2.2.*)
# - Added support to play videos by your order. Example: after search results, insert: 3 5 2 1 - (v2.1.*)
# - Added support for next pages of video results (press <ENTER> after search results)         - (v2.1.*)
# - Added support to continue playing searched videos, usage: "youtube-viewer [words] -A"      - (v2.1.*)
# - Added support to print counted videos and support to insert a number instead of video code - (v2.1.*)
# - Added support to search YouTube Videos in script (ex: youtube-viewer avatar trailer 2009)  - (v2.0.*)
# - Added support for script to choose automat quality if it is lower than 1080p               - (v2.0.*)
# - Added support to choose the quality only between 720p and 1080p (if it is available)       - (v2.0.*)
# - Added support for YouTube video codes (ex: youtube-viewer WVTWCPoUt8w)                     - (v1.0.*)
# - Added support for 720p and 1080p YouTube Videos...                                         - (v1.0.*)

# Special thanks to:
# - Army (for bugs reports and for his great ideas)
# - dhn (for adding youtube-viewer in freshports.org)

use Cwd            ('getcwd');
use URI::Escape    ('uri_escape');
use HTML::Entities ('decode_entities');
use strict;

my $appname = 'youtube-viewer';
my $version = '2.5.4-git';

####################### SUBROUTINE PROTOTYPES #######################
sub list_playlist($);
sub videos_from_username($);

####################### MPLAYER OPTIONS #######################
my $cache                = 30000;                                                 # default MPlayer cache
my $cache_min            = 5;                                                     # default MPlayer cache-min
my $user_lower_cache     = 0;                                                     # 1 will set a lower cache for MPlayer
my $mplayer_settings     = "-prefer-ipv4 -cache $cache -cache-min $cache_min";    # MPlayer options
my $mplayer_srt_settings = '-unicode -utf8';                                      # subtitle options

####################### YOUTUBE OPTIONS #######################
my $start_index      = 1;                                                         # index of the first matching result
my $results          = 20;                                                        # number video results
my $order_by         = 'relevance';
my $time_p           = 'all_time';
my $resolution_240p  = 0;
my $resolution_360p  = 0;
my $resolution_480p  = 0;
my $resolution_720p  = 0;
my $resolution_1080p = 0;
my $region;         # show YouTube movies from a particular region (default: undefined)
my $from_author;    # search videos uploaded by a particular users (default: undefined)

####################### OTHER OPTIONS #######################
my $colours        = 0;    # 1 for colored output of video results
my $debug          = 0;    # 1 will run in debug mode
my $download_video = 0;    # 1 will run MPlayer or LWP for downloading videos instead of streaming them
my $playback       = 0;    # 1 will stream all available video results, including videos from next pages
my $playlists      = 0;    # when is TRUE, will search for playlists intead of videos (works with -p argument)
my $all_time       = 0;    # when is TRUE, will show 'All time' YouTube tops (works with -a argument)
my $users_file = $ENV{'HOME'} . '/.config/youtube_usernames.txt';    # default username file
my $default_sub = 'en';    # default language for subtitles (requires gcap to get YouTube CC's)

####################### TEMPORARY OPTIONS #######################
my $picks_mode      = 0;   #               ||
my $user_cache      = 0;   #               ||
my $user_cache_min  = 0;   #               ||
my $dont_exit       = 0;   #               \/
my $playlist        = 0;   # DON'T change this default values
my $lwp_is_set      = 0;   # unless you know what you're doing
my $video_results   = 0;   #               /\
my $user_resolution = 0;   #               ||
my $user_fullscreen = 0;   #               ||

####################### COLOURS #######################
my $bred    = '';
my $bgreen  = '';
my $reset   = '';
my $bblue   = '';
my $cblack  = '';
my $bpurle  = '';
my $byellow = '';

####################### GLOBAL VARIABLES #######################
my $SEARCH = '';           # used to store search keywords for YoutTube
my $YOUTUBE_GDATA_URL;     # used to store the gdata URL with API query parameters
my $streaming;             # used to store a streaming video URL, and will be passed to mplayer as an argument
my $cwd                 = getcwd();                                                   # gets current working directory
my $win32               = $^O =~ /(?:win|dos)/i ? 1 : 0;                              # true if running under Windows
my $have_entities       = qr/&#?\w/;                                                  # checks if a string contains HTML entities
my $get_youtube_code    = qr"(?:embed|v|youtu\.be)(?:%3D|[=/])((?>[-\w]{11}))";       # $1 will be the video code
my $get_playlist_code   = qr/(?:view_play_list\?p|playlist\?list)=([A-Z\d]+)/;        # $1 will be the playlist code
my $valid_playlist_code = qr/^(?:PL)?[A-Z\d]{16}$/;                                   # validates a YouTube playlist
my $contains_arguments  = qr/(?:\s|^)-+\w+/;                                          # cheks if a string contains arguments
my $feeds_main_url      = 'https://gdata.youtube.com/feeds/api';
my $get_video_info      = 'https://www.youtube.com/get_video_info';
my $tmp_dir             = $ENV{'TEMP'} || $ENV{'TMP'} || $ENV{'TMPDIR'} || '/tmp';    # tmpdir is used to save srt files

my (@Videos, @picks, %resolution);                                                    # other global variables

eval 'require Crypt::SSLeay';                                                         # checks if Crypt::SSleay is available

if ($@) {    # if Crypt::SSleay is not avaiable ($@ contain the error from eval), then switch to http
    print "Crypt::SSLeay is not available. I'm going to use 'http' instead of 'https'\n" if $debug;
    $feeds_main_url =~ s/s//;    # changes https to http
    $get_video_info =~ s/s//;    # ==//==
}

my $MPlayerLine;

if ($win32) {
    my $MPlayer_exe = $ENV{'ProgramFiles'} . '\\SMPlayer\\mplayer\\mplayer.exe';    # Windows SMPlayer path

    if (-e $MPlayer_exe) {
        $MPlayerLine = qq["$MPlayer_exe" $mplayer_settings];                        # Windows MPlayer line
    }
    else {
        warn "\n\n!!! Please install SMPlayer to stream Youtube videos.\n\n";
        $MPlayerLine = "mplayer $mplayer_settings";
    }
}
else {
    $bred        = "\e[1;31m";                                                      # bold red
    $bgreen      = "\e[1;32m";                                                      # bold green
    $reset       = "\e[0m";                                                         # reset color
    $MPlayerLine = "mplayer $mplayer_settings";                                     # *NIX MPlayer line
}

sub win32_or_unix_paths {
    return split(/(??{$win32?';':':'})/, $ENV{'PATH'}, 0);    # if running under Win32 split $PATH by ';', else split by ':'
}

####################### LOOKING FOR GCAP #######################
my $gcap;
if ($ENV{'PATH'}) {
    foreach my $path (@INC, win32_or_unix_paths()) {
        if (-e "$path/gcap") {
            $gcap = "$path/gcap";
            last;
        }
    }
}
else {
    $gcap = '/usr/bin/gcap';
}

####################### LWP::UserAgent #######################
my $lwp;

sub UserAgent {
    require LWP::UserAgent;
    $lwp = 'LWP::UserAgent'->new;
    $lwp->agent('Mozilla/5.0 (X11; U; Linux i686; en-US) Chrome/10.0.648.45');
    $lwp->env_proxy;
    $lwp->timeout(15);
    $lwp->show_progress(1) if $debug;
    $lwp_is_set = 1;
}

####################### GET THE NEXT ARGUMENT #######################
sub get_next_argument ($) {
    my $wanted_argument = $ARGV[$_[0]] // return undef;
    if (substr($wanted_argument, 0, 1) ne '-') {
        return $wanted_argument;
    }
    else {
        return undef;
    }
}

####################### PARSING ARGUMENTS #######################
sub parse_arguments {
    my $i = 0;
    foreach my $arg (@_) {
        ++$i;
        if (substr($arg, 0, 1) eq '-') {    # if argument starts with '-'

            if ($arg =~ /^-+cache(?:=(\d+))?$/) {    # eg: -cache 1500, --cache=2000
                my $cache = $1 // get_next_argument($i);
                $MPlayerLine =~ s/-cache\s+\d+/-cache $cache/;
                $user_cache = 1;
            }
            elsif ($arg =~ /^-+cache.?min(?:=(\d+))?$/) {    # eg: --cache-min=2
                my $cache_min = $1 // get_next_argument($i);
                $MPlayerLine =~ s/-cache-min\s+\d+/-cache-min $cache_min/;
                $user_cache_min = 1;
            }
            elsif ($arg =~ /^-+(?:l|lower.?cache)$/) {       # eg: -l, --lower-cache
                $user_lower_cache = 1;
            }
            elsif ($arg =~ /^-+(?:n|no.?video)$/) {          # eg: -n, --no-video
                $MPlayerLine =~ s/mplayer /mplayer -novideo /;
                $MPlayerLine =~ s/mplayer\.exe"/mplayer.exe" -novideo/;
                $resolution_480p = 1 unless $user_resolution;
            }
            elsif ($arg =~ /^-+time(?:=(.+))?$/) {           # eg: --time=this_week
                $time_p = $1 // get_next_argument($i);
            }
            elsif ($arg =~ /^-+page(?:=(\d+))?$/) {          # eg: --page=3
                $start_index = $results * do { $1 // get_next_argument($i) }
                  - $results + 1;
            }
            elsif ($arg =~ /^-+author(?:=(.+))?$/) {         # eg: --author=google
                $from_author = $1 // get_next_argument($i);
            }
            elsif ($arg =~ /^-+(?:T|tty|M|mplayer)=(.+)/) {    # eg: --mplayer='-vo xv'
                $MPlayerLine .= " $1";
            }
            elsif ($arg =~ /^-+(?:o|order.?by)(?:=(.+))?$/) {    # eg: -o rating, --order-by=published
                $order_by = $1 // get_next_argument($i);
            }
            elsif ($arg =~ /^-+(?:r|region)(?:=(.+))?$/) {       # eg: -r US, --region=US
                $region = $1 // get_next_argument($i);
            }
            elsif ($arg =~ /^-+(?:sub|lang)(?:=([\w]{2,5}))?$/) {    # eg: -sub ar, --lang=ar
                $default_sub = $1 // get_next_argument($i);
                $default_sub = lc $default_sub unless $default_sub =~ /_/;
            }
            elsif ($arg =~ /^-+(?:colou?rs?|C|cl)$/) {               # eg: -C, --colors
                $colours = 1;
            }
            elsif ($arg =~ /^-+(?:d|download)$/) {                   # eg: -d, --download
                $download_video = 1;
            }
            elsif ($arg =~ /^-+(?:a|all.?time)$/) {                  # eg: --all-time
                $all_time = 1;
            }
            elsif ($arg eq '--debug') {                              # eg: --debug
                $debug = 1;
            }
            elsif ($arg =~ /^-+(?:A|(?:play.)?all)$/) {              # eg: -A, --play-all
                $playback = 1;
            }
            elsif ($arg =~ /^-+(?:m|more)$/) {                       # eg: -m, --more
                $results = 50;
            }
            elsif ($arg =~ /^-+(?:fs?|fullscreen)$/) {               # eg: -fs, --fullscreen
                set_fullscreen_mode();
                $user_fullscreen = 1;
            }
            elsif ($arg =~ /^-+(?:2|240p?)$/) {                      # eg: -2, --240p
                $resolution{'resolution'} = 240;
                $user_resolution = 1;
            }
            elsif ($arg =~ /^-+(?:3|360p?)$/) {                      # eg: -3, --360p
                $resolution{'resolution'} = 360;
                $user_resolution = 1;
            }
            elsif ($arg =~ /^-+(?:4|480p?)$/) {                      # eg: -4, --480p
                $resolution{'resolution'} = 480;
                $user_resolution = 1;
            }
            elsif ($arg =~ /^-+(?:7|720p?)$/) {                      # eg: -7, --720p
                $resolution{'resolution'} = 720;
                $user_resolution = 1;
            }
            elsif ($arg =~ /^-+(?:1|1080p?)$/) {                     # eg: -1, --1080p
                $resolution{'resolution'} = 1080;
                $user_resolution = 1;
            }
        }
        else {
            $SEARCH .= "$arg ";                                      # appending a keyword to $SEARCH
        }
    }

    $resolution{'resolution'} = 0 unless exists $resolution{'resolution'};

    if ($playback and not $user_resolution) {
        $resolution_1080p = 1;    # set 1080p resolution if $playback is TRUE and not any other resolution is selected
    }

####################### ASCII COLOURS #######################
    if ($colours and not $win32) {    # if $colours and not running under Windows
        $cblack  = "\e[40m";          # background black
        $byellow = "\e[1;33m";        # bold yellow
        $bpurle  = "\e[1;35m";        # bold purple
        $bblue   = "\e[1;34m";        # bold blue
    }
    parse_sub_calling_arguments(@_);
}
parse_arguments(@ARGV);

####################### PARSING ARGUMENTS WHICH CALLS A SUBROUTINE #######################
sub parse_sub_calling_arguments {
    my $i = 0;
    foreach my $arg (@_) {
        ++$i;
        if (substr($arg, 0, 1) eq '-') {

            if ($arg =~ /^-+(?:h|help|\?|usage)$/i) {
                help();
            }
            elsif ($arg =~ /^-+(?:v|version)$/i) {
                version();
            }
            elsif ($arg =~ /^-+pl?(?:playlists?)?$/) {
                search_playlists();
            }
            elsif ($arg =~ /^-+c(?:ategories)?$/) {
                categories_area();
            }
            elsif ($arg =~ /^-+(M|movies)$/) {
                youtube_movies();
            }
            elsif ($arg =~ /^-+(?:a|all[_-]?time|t|tops)$/) {
                youtube_tops();
            }
            elsif ($arg =~ /^-+u(?:sername)?(?:=(\w+))?$/) {
                videos_from_username(
                    do {
                        my $username = $1 // get_next_argument($i);
                        $username // get_next_argument($i - 2);
                      }
                );
            }
            elsif ($arg =~ /^-+(?:U|user(?:name)?s)(?:=(.+))$/) {
                if (defined $1 and -r $1) {
                    $users_file = $1;
                }
                else {
                    $users_file = get_next_argument($i) // $users_file;
                }
                list_user_names();
            }
        }
    }
}

####################### LOOKING FOR NON-ARGUMENTS #######################
my $non_argv = 0;
foreach my $arg (@ARGV) {
    if (not substr($arg, 0, 1) eq '-' or length $arg == 11) {
        $non_argv = 1;
        last;
    }
}

####################### GO TO insert_url() IF $non_argv is FALSE #######################
sub insert_url () {
    print "\n$bred=>>$reset$bgreen Insert an YouTube URL or search something...\n$reset> ";

    chomp(my $youtube = <STDIN>);

    if ($youtube =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
    elsif ($youtube =~ /$get_playlist_code/o) {
        $playlist = 1;
        list_playlist($1);
    }
    elsif ($youtube =~ /$valid_playlist_code/o) {
        list_playlist($youtube);
    }
    elsif ($youtube =~ m[^https?://]) {
        code_from_content($youtube);
    }
    elsif ($youtube) {
        parse_stdin_arguments(grep((substr($_, 0, 1) eq '-'), split(/\s+/, $youtube, 0))) if $youtube =~ /$contains_arguments/o;
        search($youtube);
    }
    else {
        warn "\n$bred(x_x) Unable to continue...$reset\n\n";
        exit;
    }
}
insert_url() unless $non_argv;

####################### GET A VIDEO CODE FROM AN WEBSITE CONTENT #######################
sub code_from_content ($) {
    UserAgent unless $lwp_is_set;

    if ($lwp->get($_[0])->content =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
}

####################### PARSING VIDEO CODES SPECIFIED AS ARGUMENTS #######################
foreach my $code (@ARGV) {
    if ($code =~ /^[\w-]{11}$/ and $code =~ /\d+|[A-Z]+|-/) {
        $dont_exit = 1;
        get_youtube($code);
    }
    elsif ($code =~ /$get_playlist_code/o) {
        $playlist = 1;
        list_playlist($1);
    }
    elsif ($code =~ /$valid_playlist_code/o) {
        $playlist = 1;
        list_playlist($code);
    }
    if ($code =~ /$get_youtube_code/o) {
        $code      = $1;
        $dont_exit = 1;
        get_youtube($code) if (length($code) == 11);
    }
    elsif ($code =~ m[^https?://]) {
        code_from_content($code);
    }
}

####################### YOUTUBE-VIEWER USAGE #######################
sub help {
    my $appname = uc $appname;

    print "\n  " . '=' x 30 . " $appname " . '=' x 30 . "
\t\t\t\t\t\t by Trizen (trizenx\@gmail.com)
\nUsage: youtube-viewer [<url> || <video_id> || <keywords>]
                      [-u <username>] [-categories] [-(a|t)]
                      [-(2|3|4|7|1)] [-fs] [-novideo] [-A] [-m]
\nBase Options: youtube-viewer [...]
   <url>                : play an YouTube video by URL
   <code>               : play an YouTube video by code
   <keywords>           : search and list YouTube videos
   <playlist_url>       : list a playlist of YouTube videos
\nYouTube options:
   -t, --tops           : shows today YouTube tops
   -a, --all-time       : shows all time YouTube tops
   -c, --categories     : shows available YouTube categories
   -m, --more           : shows more video results (50 clips)
   -p, --playlist       : search for YouTube playlists
   -M, --movies         : show YouTube movies categories
   --region=<ID>        : set a specific regionID (ex: US)
   -u <username>        : lists videos uploaded by a specific user
   -author='USERNAME'   : search videos uploaded by a particular user
   -order-by='ORDER'    : order entries by: published, viewCount or rating
   -time='TIME'         : valid values are: today, this_week and this_month
   -page='PAGE_NR'      : show video results starting with page 'n'
   -2, -3, -4, -7, -1   : plays videos at 240p, 360p, 480p, 720p or 1080p
\nMPlayer options:
   -f, --fullscreen     : plays video(s) in fullscreen mode
   -n, --novideo        : plays only the audio track of video(s)
   -l, --lower-cache    : set a lower cache for MPlayer (for slow connections)
   -mplayer='SETTINGS'  : add some extra options to the MPlayer line
   -sub='LANG'          : subtitle language (default: en) (depends on gcap)
   -cache='VALUE'       : set cache for MPlayer (default: $cache)
   -cache-min='VALUE'   : set cache-min for MPlayer (default: $cache_min)
\nOther options:
   -d, --download       : downloads YouTube video(s) with LWP
   -A, --all            : plays all video results in order
   -C, --colors         : use colors for text output
   -U, --users=file.txt : list YouTube usernames from a file
   -v, --version        : prints version and exits
   -h, --help           : prints help and exits
\nTips and tricks:
  1. After search results, press <ENTER> for the next page
  2. After search results, insert 'back' for the previous page
  3. After search results, insert more numbers to play videos in your order
  4. After search results you can insert arguments via STDIN (eg: 1 3 --720p)
  5. After search results you can insert 'reset' to set default settings
  6. Play all audio tracks of video results by using '-A -n' as arguments
  7. Play all video results from a page: insert 'all' or insert '1-20'\n\n";
    exit;
}

####################### YOUTUBE-VIEWER VERSION #######################
sub version {
    print "Youtube Viewer $version\n";
    exit 0;
}

####################### LIST YOUTUBE USERNAMES FROM A FILE #######################
sub list_user_names {
    print "\n";

    if (-r $users_file) {
        open my $fh, '<', $users_file;

        my $n = 0;
        my %usernames_table;

        while (defined($_ = <$fh>)) {
            chomp $_;

            next unless /^\w+$/;
            ++$n;
            print do {
                ' ' if $n < 10;
            }, "$bred$n$reset - $bgreen$_$reset\n";
            $usernames_table{$n} = $_;
        }

        print "\n$bred=>>$reset ${bgreen}Pick an username number$reset\n> ";

        chomp(my $pick = <STDIN>);

        exit if $pick =~ /^(?:q|quit|exit)$/i;

        if (defined $usernames_table{$pick}) {
            chomp(my $user = $usernames_table{$pick});
            videos_from_username($user);
        }
        else {
            list_user_names();
        }

        close $fh;
    }
}

####################### LISTS VIDEOS FROM A SPECIFIC USER #######################
sub videos_from_username ($) {
    parse_url("$feeds_main_url/users/$_[0]/uploads");
}

####################### SEARCH FOR YOUTUBE PLAYLISTS #######################
sub search_playlists {
    $playlists = 1;
    UserAgent unless $lwp_is_set;

    my $url = shift() || "$feeds_main_url/playlists/snippets?q=$SEARCH&start-index=1&max-results=$results&v=2";
    parse_content($url);

    my $n = -1;

    foreach my $playlist (@Videos) {
        print do {
            ' ' if $$playlist[0] < 10;
          }, $cblack, $bred, $$playlist[0], $reset, $cblack, ' - ', $byellow, $$playlist[3], ' ', $$playlist[8], $reset, $cblack,
          ' (', $bpurle, 'by ', $$playlist[1], $reset, $cblack, ') (', $bblue, $$playlist[7], $reset, $cblack, ')', $reset, "\n";
    }

    print "\n$bred=>>$reset ${bgreen}Pick one playlist$reset\n> ";

    chomp(my $pick = <STDIN>);

    if (not $pick =~ /^\s*\d+\s*$/ and $pick =~ /^\s*$/ or $pick eq 'next') {

        if ($url =~ /start-index=(\d+)/) {
            $url =~ s/start-index=($1)/'start-index=' . ($1 + $results);/e;
            search_playlists($url);
        }
    }
    elsif (
        $pick eq 'back' and do {
            $url =~ /\bstart-index=(\d+)/;
            $1 > 1;
        }
      ) {

        if ($url =~ /start-index=(\d+)/) {
            $url =~ s/start-index=($1)/'start-index=' . ($1 - $results);/e;
            search_playlists($url);
        }
    }
    elsif ($pick =~ /^\D/ and not $pick =~ /^\s*\d/) {
        $SEARCH = $pick;
        search_playlists();
    }
    elsif ($pick =~ /^\s*(\d+)/) {
        $pick = $1;
    }

    $playlists = 0;
    list_playlist($Videos[$pick - 1][2]);
}

####################### VALIDATES AND LIST A YOUTUBE PLAYLIST #######################
sub list_playlist ($) {
    if ($_[0] =~ /^([A-Z\d]+)$/) {
        my $pl = $1;
        $pl =~ s/PL// if length $pl > 16;
        parse_url("$feeds_main_url/playlists/$pl");
    }
}

####################### LIST YOUTUBE MOVIE CATEGORIES #######################
sub youtube_movies {
    print "\n";

    my $i = 0;
    my %movie_table;

    foreach $_ ('most_popular', 'most_recent', 'trending') {
        my $cat_name = ucfirst $_;
        $cat_name =~ tr/_/ /;
        print ' ' . $bred . ++$i . "$reset - $cat_name\n";
        $movie_table{$i} = $_;
    }

    print "\n$bred=>>$bgreen Pick one category$reset\n> ";

    chomp(my $pick = <STDIN>);

    if (defined $movie_table{$pick}) {
        parse_url("$feeds_main_url/charts/movies/$movie_table{$pick}");
    }
}

####################### LIST YOUTUBE TOP VIDEO CATEGORIES #######################
sub youtube_tops {
    my $n             = 0;
    my $today         = $all_time ? 0 : 1;
    my $standardfeeds = "$feeds_main_url/standardfeeds";
    my %tops_table;

    print "\n";

    foreach $_ ('top_rated',   'top_favorites',  'most_viewed',    'most_popular',
                'most_recent', 'most_discussed', 'most_responded', 'recently_featured'
      ) {
        ++$n;
        my $top_name = ucfirst $_;
        $top_name =~ tr/_/ /;
        print "$bred$n$reset - $top_name\n";
        $tops_table{$n} = $_;
    }

    print "\n$bred=>>$bgreen Pick one of$reset\n> ";

    chomp(my $pick = <STDIN>);

    if (defined $tops_table{$pick}) {
        my $url = $standardfeeds . '/' . $tops_table{$pick};

        if ($today) {

            unless ($url =~ /recent/) {
                $url .= '?time=today';
            }
        }
        parse_url($url);
    }
    else {
        youtube_tops();
    }
}

####################### LIST YOUTUBE VIDEO CATEGORIES #######################
sub categories_area {
    UserAgent unless $lwp_is_set;

    my $n = 0;
    my %categories_table;

    print "\n";

    foreach $_ (split(/category\s+term=/, $lwp->get('http://gdata.youtube.com/schemas/2007/categories.cat')->content, 0)) {

        if (/^'([^']+)'\s+label='([^']+)'/ and not /deprecated/) {
            ++$n;

            my $cat_name  = $1;
            my $cat_label = $2;
            $cat_label =~ s/&amp;/&/;
            print do {
                ' ' if $n < 10;
              }
              . "$bred$n$reset - $cat_label\n";
            $categories_table{$n} = $cat_name;
        }
    }

    print "\n$bgreen=>> Insert a category number\n>$reset ";

    chomp(my $pick = <STDIN>);

    if (defined $categories_table{$pick}) {
        parse_url("$feeds_main_url/standardfeeds/recently_featured_$categories_table{$pick}");
    }
    else {
        categories_area();
    }
}

####################### PLAY OR DOWNLOAD AN YOUTUBE VIDEO #######################
sub MPlayer {

    print "** STREAMING: $streaming\n\n" if $debug;

######### DOWNLOADING #########
    if ($download_video) {
        my $title = shift @_;
        $title =~ tr[/][|];    # replaces '/' with '|'

        if (not -e "$title.mp4") {
            if (-e '/usr/bin/wget') {
                system "wget -nc '${streaming}' -O \Q$title\E.mp4";
            }
            else {
                print "** Saving to: '$title.mp4'\n";
                $lwp->show_progress(1);
                $lwp->mirror($streaming, "$title.mp4");
                $lwp->show_progress(0);
            }
        }
        else {
            warn "** '$title.mp4' already exists...\n";
        }
    }

######### STREAMING #########
    else {
        print "** MPlayer Line: $MPlayerLine\n\n" if $debug;

        `$MPlayerLine '$streaming'`;    # executing $MPlayerLine with '$streaming' as an argument

        chdir $cwd;                     # change directory back to the main working directory
    }

    print "\n";

    if (@picks) {
        foreach_pick();                 # go to the next video if there are more videos selected to play
    }

    if ($video_results and not $dont_exit) {
        print_results();                # go back to the video results
    }

    exit unless $dont_exit;
}

####################### SEARCH YOUTUBE VIDEOS #######################
search() unless $dont_exit or $playlists;

sub search {
    use strict;
    $SEARCH = shift() || $SEARCH;
    $SEARCH = join(' ', grep((substr($_, 0, 1) ne '-'), split(/\s+/, $SEARCH, 0)));    # get words that doesn't start with '-'
    $SEARCH = uri_escape($SEARCH);
    $YOUTUBE_GDATA_URL =
        $feeds_main_url
      . '/videos?q='
      . $SEARCH
      . '&max-results='
      . $results
      . '&time='
      . $time_p
      . '&orderby='
      . $order_by
      . '&start-index='
      . $start_index . '&v=2';

    if (defined $from_author) {
        $YOUTUBE_GDATA_URL .= '&author=' . $from_author;
    }

    if (defined $region) {
        $YOUTUBE_GDATA_URL .= '&region=' . $region;
    }
    parse_content($YOUTUBE_GDATA_URL);
    print_results();
}

####################### PREPARE GDATA FEEDS URL #######################
sub parse_url {
    use strict;
    $YOUTUBE_GDATA_URL = shift() || $YOUTUBE_GDATA_URL;

    if ($YOUTUBE_GDATA_URL =~ /^$feeds_main_url/o) {

        if (not $YOUTUBE_GDATA_URL =~ /\?/) {
            $YOUTUBE_GDATA_URL .= "?start-index=$start_index";
        }
        else {
            $YOUTUBE_GDATA_URL .= "&start-index=$start_index";
        }

        $YOUTUBE_GDATA_URL .= "&max-results=$results&v=2";

        if (defined $region) {
            $YOUTUBE_GDATA_URL .= "&region=$region";
        }
        parse_content($YOUTUBE_GDATA_URL);
        print_results();
    }
    else {
        search $YOUTUBE_GDATA_URL;
    }
}

####################### GET AND PARSE GDATA CONTENT #######################
sub parse_content {
    use strict;
    UserAgent unless $lwp_is_set;
    print "\n";

    undef @Videos;

    my ($author, $code, $title, $category, $published, $duration, $views, $description);
    my $number = 0;

    foreach $_ (split(m[<title[^>/]*>], $lwp->get($_[0])->content, 0)) {

################ GETTING PLAYLIST VALUES ################
        if ($playlists) {

            if (m[<yt:playlistId>([^<]+)</yt:playlistId>]) {
                $code = $1;
            }
            else {
                next;
            }

            if (m[<yt:countHint>(\d+)</yt:countHint>]) {
                $views = $1;
            }
            else {
                $views = 0;
            }

            if (m[<summary>([^<]+)</summary>]) {
                $description = $1;
                $description =~ s/\s\s+/ /g;
                $description = substr($description, 0, 15) if length $description > 15;
                $description = decode_entities($description) if $description =~ /$have_entities/o;
            }
            else {
                $description = "\cH";
            }
        }
        else {
################ GETTING VIDEO VALUES ################
            if (/\bviewCount='(\d+)'/) {
                $views = $1;
            }
            else {
                $views = 0;
            }

            if (/([-\w]{11})&amp;feature=youtube_gdata/) {
                $code = $1;
            }
            else {
                next;
            }

            if (/<media:description type='plain'>([^<]+)/) {
                $description = $1;
            }
            else {
                $description = 'No description available...';
            }
        }
################ PARSING BOTH - VIDEO AND PLAYLIST VALUES ################
        if (m[<name>([^<]+)</name>]) {
            $author = $1;
        }
        else {
            $author = 'Unknown';
        }

        if (m[^([^<]+)</title>]) {
            $title = $1;
            $title = decode_entities($title) if $title =~ /$have_entities/o;
        }
        else {
            $title = 'Unknown';
        }

        if (/<media:category label='([^']+)'/) {
            $category = $1;
            $category =~ s/&amp;/&/;
        }
        else {
            $category = 'Unknown';
        }

        if (/<published>([\d-]+)/) {
            $published = $1;
        }
        else {
            $published = 'Unknown';
        }

        if (/\bduration[^']+'(\d+)'/) {
            $duration = format_time($1);
        }
        else {
            $duration = 0;
        }
        ++$number;
####### PUSH RESULTS TO @Videos #######
        push @Videos, [$number, $author, $code, $title, $category, $published, $duration, $views, $description];
    }
}

sub format_time {
    use strict;
    my $sec = shift @_ || return (0);
    my $time = join(':', map((length $_ == 1 ? "0$_" : $_), $sec / 3600 % 24, $sec / 60 % 60, $sec % 60));
    $time =~ s/^00://;
    $time;
}

sub format_date {
    use strict;
    my $date = shift();
    $date =~ tr/\-/./;
    $date =~ s/(.+)\.(.+)\.(.+)/$3.$2.$1/;
    $date;
}

####################### PRINT RESULTS FROM @Videos #######################
sub print_results {
    use strict;

    if (not @Videos) {
        print "$bred(x_x) No video results!$reset\n";
        insert_url();
    }
    else {
        $video_results = 1;
    }

    foreach my $video (@Videos) {
        print do {
            ' ' if $$video[0] < 10;
          }, $cblack, $bred, $$video[0], $reset, $cblack, ' - ', $byellow, $$video[3], $reset, $cblack, ' (', $bpurle, 'by ',
          $$video[1], $reset, $cblack, ') (', $bblue, $$video[6], $reset, $cblack, ')', $reset, "\n";
    }

    if ($playback) {
        @picks = 1 .. scalar @Videos;
        foreach_pick();
    }

    print "\n$bred=>>$reset$bgreen Insert a number or search something else\n$reset> ";

    chomp(my $stdin = <STDIN>);    # asks for user input

    if ($stdin =~ /$contains_arguments/o) {
        parse_stdin_arguments(grep((substr($_, 0, 1) eq '-'), split(/\s+/, $stdin, 0)));
    }

    if ($stdin =~ /^(?:q|quit|exit)$/) {
        exit;
    }
    elsif ($stdin =~ /^\s*$/ or $stdin eq 'next') {
        next_page();
    }
    elsif ($stdin eq 'reset') {
        do $0;
    }
    elsif (
        $stdin eq 'back' and do {
            $YOUTUBE_GDATA_URL =~ /\bstart-index=(\d+)/;
            $1 > 1;
        }
      ) {
        previous_page();
    }
    elsif ($stdin =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
    elsif ($stdin =~ /$get_playlist_code/o) {
        list_playlist $1;
    }
    elsif ($stdin =~ /$valid_playlist_code/o) {
        list_playlist $stdin;
    }
    elsif ($stdin =~ m[^https?://] and not $stdin =~ /youtube\.com/) {
        code_from_content $stdin;
    }
    elsif ($stdin eq 'all') {
        parse_stdin_arguments('--1080p') unless $user_resolution;
        @picks = 1 .. scalar @Videos;
        foreach_pick();
    }
    elsif ($stdin =~ /\d(?:\.\.|-|\s+|,)?/ and not $stdin =~ /(?:\s|^)[^-][A-Za-z]/) {
        $stdin =~ s/(?:\D|^)-\d+//g;
        $stdin =~ s/(\d+)(?:-|\.\.)(\d+)/join ' ', $1 .. $2;/eg;
        @picks = grep({$_ > 0 and $_ <= scalar @Videos if /^\d+$/;} split(/\D+/, $stdin, 0));
        foreach_pick() if scalar @picks or search($stdin);
    }
    else {
        search $stdin;
    }
}

####################### GO TO THE NEXT PAGE #######################
sub next_page {
    use strict;

    if ($YOUTUBE_GDATA_URL =~ /\bstart-index=(\d+)/) {
        $YOUTUBE_GDATA_URL =~ s/index=($1)/'index=' . ($1 + $results);/e;
        parse_content $YOUTUBE_GDATA_URL;
        print_results();
    }
}

####################### GO TO THE PREVIOUS PAGE #######################
sub previous_page {
    use strict;

    if ($YOUTUBE_GDATA_URL =~ /\bstart-index=(\d+)/) {
        $YOUTUBE_GDATA_URL =~ s/index=($1)/'index=' . ($1 - $results);/e;
        parse_content $YOUTUBE_GDATA_URL;
        print_results();
    }
}

sub foreach_pick {
    use strict;
    if (@picks) {
        foreach_code(shift(@picks));
    }
    elsif ($playback) {
        next_page();
    }
}

sub foreach_code {
    use strict;

    foreach my $video ($Videos[shift() - 1]) {
        my $description = $$video[8] =~ /$have_entities/o ? decode_entities($$video[8]) : $$video[8];
        get_youtube($$video[2], $$video[3], $$video[6], $$video[7], $$video[4], $$video[5], $description);
    }

    foreach_pick();
}

sub set_fullscreen_mode {
    $win32
      ? $MPlayerLine =~ s/mplayer\.exe"/mplayer.exe" -fs/
      : $MPlayerLine =~ s/mplayer /mplayer -fs /;
}

sub disable_fullscreen_mode {
    unless ($user_fullscreen) {
        $MPlayerLine =~ s/-fs //;
    }
}

sub select_resolution {
    use strict;
    $streaming =~ s/^[\w]*%[\w]*https?:/http:/;

    if (not $streaming =~ /itag=34/ and $streaming =~ /itag=(\d+)/) {
        my $itag = $1;
        $streaming =~ s/.*https?(.+)itag=$itag([^%]*).+/http$1itag=$itag$2/;
        $streaming =~ s/%.*//;

        disable_fullscreen_mode();
        lower_cache();
    }
    elsif ($resolution{'resolution'} == 1080) {
        print "Looking for 1080p resolution...\n" if $debug;

        if ($streaming =~ /itag=37/) {
            print "Selecting 1080p resolution\n" if $debug;
            $streaming =~ s/.*https?(.+)itag=37([^%]*).+/http$1itag=37$2/;
            set_fullscreen_mode();
        }
        elsif ($streaming =~ /itag=22/) {
            print "1080p resolution is not available, so I select 720p...\n" if $debug;
            $streaming =~ s/.*https?(.+)itag=22([^%]*).+/http$1itag=22$2/;
            set_fullscreen_mode();
        }
        else {
            print "1080p and 720p is not available...\n" if $debug;
            lower_quality();
        }
    }
    elsif ($resolution{'resolution'} == 720) {
        print "Looking for 720p resolution...\n" if $debug;

        if ($streaming =~ /itag=22/) {
            print "Selecting 720p resolution\n" if $debug;
            $streaming =~ s/.*https?(.+)itag=22([^%]*).+/http$1itag=22$2/;
            set_fullscreen_mode();
        }
        else {
            print "Resolution 720p is not available\n" if $debug;
            lower_quality();
        }
    }
    elsif ($resolution{'resolution'} == 480) {
        print "Selecting 480p resolution\n" if $debug;
        lower_quality();
    }
    elsif ($resolution{'resolution'} == 360) {
        print "Selecting 360p resolution\n" if $debug;
        lower_quality(34);
    }
    elsif ($resolution{'resolution'} == 240) {
        print "Selecting 240p resolution\n" if $debug;
        lower_quality(5);
    }
    else {
        check_resolution();
    }
}

sub check_resolution {
    use strict;

    if ($streaming =~ /itag=37/) {
        print "Detected 1080p resolution in check_resolution()\n" if $debug;
        pick();
    }
    elsif ($streaming =~ /itag=22/) {
        print "Selecting 720p resolution from check_resolution()\n" if $debug;
        $streaming =~ s/.*https?(.+)itag=22([^%]*).+/http$1itag=22$2/;
        default_cache();
        set_fullscreen_mode();
    }
    else {
        lower_quality();
    }
}

sub parse_stdin_arguments {
    if ($debug) {
        print "Parsing STDIN arguments: ", "@_";
    }
    parse_arguments(@_);    # parse and apply STDIN arguments
}

sub get_youtube {
    use strict;

    my ($code, $title, $duration, $views, $category, $published, $description) = @_;
    print "\nget_youtube()\n" . join("\n", @_) . "\nEOL\n\n" if $debug;

    my $youtube = "$get_video_info?&video_id=$code&el=detailpage&ps=default&eurl=&gl=US&hl=en";
    UserAgent unless $lwp_is_set;

    my $connect = $lwp->get($youtube);
    my $url     = "http://www.youtube.com/watch?v=$code";
    $MPlayerLine =~ s/ *\Q$mplayer_srt_settings\E *-sub.*//;

    if (    -e $gcap
        and not $MPlayerLine  =~ / -novideo/
        and $connect->content =~ /&has_cc=True&/
        and not $download_video) {
        chdir $tmp_dir;

        unless (-e "${code}_$default_sub.srt") {
            system "gcap $url";
        }

        my @srt_files;
        my $dir_h;

        opendir $dir_h, $tmp_dir;
        /\.srt$/ and push @srt_files, $_ while defined($_ = readdir $dir_h);
        closedir $dir_h;

        my $srt_file;

        foreach my $line (@srt_files) {

            if ($line =~ /${code}_$default_sub\.srt/) {
                $srt_file = "${code}_$default_sub.srt";
                $MPlayerLine .= " $mplayer_srt_settings -sub $srt_file";
            }
        }

        unless (defined $srt_file) {

            foreach my $line (@srt_files) {

                if ($line =~ /$code(\w*)\.srt/) {
                    $srt_file = "$code$1.srt";
                    $MPlayerLine .= " $mplayer_srt_settings -sub $srt_file";
                }
            }
        }
    }

    if ($connect->content =~ /url_encoded_fmt_stream_map=([^&]+)&/) {
        $streaming = $1;
        $streaming =~ s/%253A/:/gi;
        $streaming =~ s[%252F][/]gi;
        $streaming =~ s/%2526/&/g;
        $streaming =~ s/%253D/=/gi;
        $streaming =~ s/%253F/?/gi;
        $streaming =~ s/%25252C/,/gi;
        print "\n";

        if ($debug) {
            open my $fh, '>', 'streaming_debug.txt';

            print {$fh} $streaming;
            close $fh;
        }

        my $rating;

        if ($connect->content =~ /avg_rating=([^&]+)/) {
            $rating = sprintf('%.2f', $1);
        }

        unless (defined $title) {
            my $feed_url = "$feeds_main_url/videos/$code";
            my $content  = $lwp->get($feed_url)->content;

            if ($content =~ m[media:title type='plain'>([^<]+)</media:title>]) {
                $title = $1;
                $title = decode_entities($title) if $title =~ /$have_entities/o;
            }

            if ($content =~ /viewCount='(\d+)'/) {
                $views = $1;
            }

            if ($content =~ /<published>([\d-]+)/) {
                $published = $1;
            }

            if ($content =~ m[<media:description type='plain'>([^<]+)</media]) {
                $description = $1;
                $description = decode_entities($description) if $description =~ /$have_entities/o;
            }

            if ($content =~ /duration\D*='(\d+)/) {
                $duration = format_time($1);
            }

            if ($content =~ /category label='([^']+)'/) {
                $category = $1;
                $category =~ s/&amp;/&/;
            }
        }

        $published = format_date($published);

        if ($views and length $views > 2) {
            $views = reverse($views);
            $views =~ s/(\d{3})/$1./g;
            $views = reverse($views);
            $views =~ s/^\.//;
        }

        $description = 'No description available...' unless defined $description;
        print "$bred=>> " . $bgreen . $title . $reset . "\n" . '-' x 80;
        print "\n" . $description . "\n" . '-' x 80 . "\n";
        print "$bred=>> ${bgreen}View & Download$reset\n" . '-' x 80;

        my ($get) = $streaming =~ m[(https?://[^%]+)];
        print "\n* URL ";
        print STDOUT $url;
        print "\n* GET $get\n" . '-' x 80 . "\n";

        my $count = length $title;

        if ($count <= 40) {
            print "$bred\t\t=>> ";
        }
        elsif ($count >= 40 and $count <= 55) {
            print "$bred\t=>> ";
        }
        elsif ($count >= 56) {
            print "$bred  =>> ";
        }

        print "$bgreen$title$reset$bred <<=\n$reset";

        my ($author) = $connect->content =~ /&author=([^&]+)/;
        print "\n** Author    : $author\n"  if defined $author;
        print "** Category  : $category\n"  if defined $category;
        print "** Duration  : $duration\n"  if defined $duration;
        print "** Rating    : $rating\n"    if defined $rating;
        print "** Views     : $views\n"     if defined $views;
        print "** Published : $published\n" if defined $published;
        print '-' x 80 . "\n\n";
        select_resolution();
        MPlayer $title;
    }
    else {
        warn "\n$bred(x_x) Something went wrong...$reset\n\n$bred(x_x) Unable to stream: $reset$url\n\n";

        if ($video_results and not $dont_exit) {

            unless (@picks) {
                sleep 1;
                print_results();
            }
        }
        else {

            unless ($video_results or $dont_exit) {
                exit;
            }
        }
    }
}

sub pick {
    use strict;

    print "$bred=>>$reset $bgreen Please choose the quality of video (default: 1)$reset\n"
      . "\n  $bred 1$reset - 1280x720  (720p)\n  $bred 2$reset - 1920x1080 (1080p)\n  ",
      '=' x 23 . "\n" . "\n$bgreen=>> Pick format:$reset ";
    chomp(my $pick = <STDIN>);

    print '-' x 80 . "\n\n";

    if ($pick eq 2) {
        $streaming =~ s/.*https?(.+)itag=37([^%]*).+/http$1itag=37$2/;
        $resolution{'resolution'} = 1080;
        default_cache();
        set_fullscreen_mode();
    }
    else {
        $streaming =~ s/.*https?(.+)itag=22([^%]*).+/http$1itag=22$2/;
        $resolution{'resolution'} = 720;
        default_cache();
        set_fullscreen_mode();
    }
}

sub lower_quality {
    use strict;

    if (defined($_[0]) and $_[0] =~ /^\d+$/) {

        if ($streaming =~ /itag=$_[0]/) {
            $streaming =~ s/.*https?(.+)itag=$_[0]([^%]*).*/http$1itag=$_[0]$2/;
            disable_fullscreen_mode();
            lower_cache();
        }
    }
    else {

        foreach $_ (35, 34) {

            if ($streaming =~ /itag=$_/) {

                if ($debug) {

                    if ($_ == 35) {
                        print "Selecting 480p from lower_quality()\n";
                    }
                    elsif ($_ == 34) {
                        print "Selecting 360p from lower_quality()\n";
                    }
                }

                $streaming =~ s/.*https?(.+)itag=$_([^%]*).*/http$1itag=$_$2/;
                disable_fullscreen_mode();
                lower_cache();
                last;
            }
        }
    }
}

sub lower_cache {    # set a lower cache if $user_lower_cache is TRUE
    use strict;
    $MPlayerLine =~ s/-cache\s+\d+/-cache 1000/      unless $user_cache;
    $MPlayerLine =~ s/-cache-min\s+\d+/-cache-min 3/ unless $user_cache_min;
}

sub default_cache {
    use strict;

    if (not $user_lower_cache) {
        $MPlayerLine =~ s/-cache\s+\d+/-cache $cache/             unless $user_cache;
        $MPlayerLine =~ s/-cache-min\s+\d+/-cache-min $cache_min/ unless $user_cache_min;
    }
    else {
        lower_cache();
    }
}
