#!/usr/bin/perl

# Copyright (C) 2010-2011 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#-------------------------------------------------------
#  (C) 2010-2011 by Trizen
#  Created on: 02 Jun 2010
#  Latest edit on: 05 December 2011
#  Website: http://trizen.go.ro
#  Email: echo dHJpemVueEBnbWFpbC5jb20K | base64 -d
#-------------------------------------------------------
#
# [?] What is this script for?
#  - This script is useful to search and watch YouTube videos with MPlayer...
#  - Have fun!
#
# [!] The most important changes are written in the changelog!
#
# [CHANGELOG]
# - Added support to list playlists created by a specific user (usage: -up <USERNAME>)         - NEW (v2.5.4)
# - Improved parsing support for arguments, including arguments specified via STDIN.           - NEW (v2.5.4)
# - Added support to search for videos uploaded by a particular YouTube user (-author=USER)    - NEW (v2.5.4)
# - Added support to get video results starting with a predefined page (ex: -page=4)           - NEW (v2.5.4)
# - Added support for previous page and support to list youtube usernames from a file          - (v2.5.2)
# - Added few options to control cache of MPlayer and lower cache for lower video resolutions  - (v2.5.1)
# - Added colours for text (--colours) or $colours = 1, 360p support (-3), playlist support    - (v2.5.0)
# - Added support for today and all time Youtube tops (usage: -t, --tops, -a, --all-time)      - (v2.4.*)
# - Re-added the support for the next page / Added support for download (-d, --download)       - (v2.4.*)
# - Added support for Youtube CCaptions. (Depends on: 'gcap' - http://gcap.googlecode.com)     - (v2.4.*)
# - First version with Windows support. Require SMPlayer to play videos. See MPlayer Line      - (v2.4.*)
# - Code has been changed in a proportion of ~60% and optimized for speed // --480 became -4   - (v2.4.*)
# - Added mega-powers of omnibox to the STDIN :)                                               - (v2.3.*)
# - Re-added the option to list and play youtube videos from a user profile. Usage: -u [user]  - (v2.3.*)
# - Added a new option to play only the audio track of a videoclip. Usage: [words] -n          - (v2.3.*)
# - Added option for fullscreen (-f, --fullscreen). Usage: youtube-viewer [words] -f           - (v2.3.*)
# - Added one new option '-c'. It shows available categories and will let you to choose one.   - (v2.3.*)
# - Added one new option '-m'. It shows 3 pages of youtube video results. Usage: [words] -m    - (v2.3.*)
# - For "-A" option has been added 3 pages of youtube video results (50 clips)                 - (v2.3.*)
# - Added "-prefer-ipv4" to the mplayer line (videoclips starts in no time now).               - (v2.3.*)
# - Search and play videos at 480p, 720p. Ex: [words] --480, [words] -A --480                  - (v2.3.*)
# - Added support to play a video at 480p even if it's resolution is higher. Ex: [url] --480   - (v2.2.*)
# - Added a nice feature which prints some informations about the current playing video        - (v2.2.*)
# - Added support to play videos by your order. Example: after search results, insert: 3 5 2 1 - (v2.1.*)
# - Added support for next pages of video results (press <ENTER> after search results)         - (v2.1.*)
# - Added support to continue playing searched videos, usage: "youtube-viewer [words] -A"      - (v2.1.*)
# - Added support to print counted videos and support to insert a number instead of video code - (v2.1.*)
# - Added support to search YouTube Videos in script (ex: youtube-viewer avatar trailer 2009)  - (v2.0.*)
# - Added support for script to choose automat quality if it is lower than 1080p               - (v2.0.*)
# - Added support to choose the quality only between 720p and 1080p (if it is available)       - (v2.0.*)
# - Added support for YouTube video codes (ex: youtube-viewer WVTWCPoUt8w)                     - (v1.0.*)
# - Added support for 720p and 1080p YouTube Videos...                                         - (v1.0.*)

# Special thanks to:
# - Army (for bugs reports and for his great ideas)
# - dhn (for adding youtube-viewer in freshports.org)

eval 'exec perl -wS $0 ${1+"$@"}'
  if 0;    #$running_under_some_shell;

use strict;
use feature 'switch';
use autouse ('URI::Escape'    => 'uri_escape');
use autouse ('HTML::Entities' => 'decode_entities');

my $appname = 'youtube-viewer';
my $version = '2.5.5-git';

####################### MPLAYER OPTIONS #######################
my $cache                = 30000;               # default MPlayer cache
my $cache_min            = 5;                   # default MPlayer cache-min
my $user_lower_cache     = 0;                   # 1 will set a lower cache for MPlayer
my $mplayer_srt_settings = '-unicode -utf8';    # subtitle options
## MPlayer options
my $mplayer_settings = "-prefer-ipv4 -cache $cache -cache-min $cache_min";

####################### YOUTUBE OPTIONS #######################
my $start_index = 1;                            # index of the first matching result
my $results     = 20;                           # number of video results
my $order_by    = 'relevance';
my $time_p      = 'all_time';
my $region;                                     # show YouTube movies from a particular region (default: undefined)
my $from_author;                                # search videos uploaded by a particular user  (default: undefined)

####################### OTHER OPTIONS #######################
my $colours         = 0;                        # 1 for colored output of video results
my $debug           = 0;                        # 1 will run in debug mode
my $download_video  = 0;                        # 1 will run wget or LWP for downloading videos instead of streaming them
my $lwp_downloading = 0;                        # 1 will always download videos with LWP (default: wget (if is available))
my $playback        = 0;                        # 1 will stream all available video results, including videos from next pages
my $default_sub     = 'en';                     # default language for subtitles (requires gcap to get YouTube CC's)
my $users_file = "$ENV{'HOME'}/.config/youtube_usernames.txt";

# itag => resolution
my %itags = (37 => 1080,
             22 => 720,
             35 => 480,
             43 => 210,
             34 => 360,
             5  => 240);

# Unchangeable variables
my %constant = ('dash_line' => q{-} x 80,                                                  # used as a line separator
                'win32'     => $^O eq 'Win32' ? 1 : 0,                                     # true if running under Windows
                'tmp_dir'   => $ENV{'TEMP'} // $ENV{'TMP'} // $ENV{'TMPDIR'} // '/tmp',    # tmpdir is used to save srt files
               );

####################### ASCII COLOURS #######################
my $bred    = q{};
my $bgreen  = q{};
my $reset   = q{};
my $cblack  = "\e[40m";                                                        # background black
my $byellow = "\e[1;33m";                                                      # bold yellow
my $bpurle  = "\e[1;35m";                                                      # bold purple
my $bblue   = "\e[1;34m";                                                      # bold blue

unless ($constant{'win32'}) {                                                  # if not running under Windows
    $bred   = "\e[1;31m";                                                      # bold red
    $bgreen = "\e[1;32m";                                                      # bold green
    $reset  = "\e[0m";                                                         # reset color
}

####################### GLOBAL VARIABLES #######################
my $keywords = q{};       # used to store keywords for search
my $youtube_gdata_url;    # used to store the gdata URL with API query parameters
my $feeds_main_url = 'https://gdata.youtube.com/feeds/api';
my $get_video_info = 'https://www.youtube.com/get_video_info';

my (@results, @picks, %resolution, %streaming);    # other global variables

####################### REGEXP AREA #######################
my $quit_required       = qr/^(?:q|quit|exit)$/i;                                # exit if user's input is q, quit or exit
my $has_entities        = qr/&#?\w/;                                             # checks if a string contains HTML entities
my $get_youtube_code    = qr{(?:v|embed|youtu[.]be)(?:%3D|[=/])([\w\-]{11})};    # $1 will be the video code
my $valid_playlist_code = qr/^(?:PL)?([[:upper:]\d]{16})$/;                      # $1 will be the playlist code
my $contains_arguments  = qr/(?:\s|^)-+\w/;                                      # cheks if a string contains arguments
my $match_regexp        = qr{/([^/]*(?<!\\)(?:(?<!\\)\\/)*[^/]*)/};              # checks if the input looks like a regexp (//)

######################################### REGEXP: PLAYLIST ID FINDER #################################
## $1 will be the playlist code
my $get_playlist_code = qr"(?:(?:(?:playlist[?]list|view_play_list[?]p)=)|\w#p/c/)(?:PL)?([[:upper:]\d]{16})";
######################################################################################################

######################################### REGEXP: XML PARSER #########################################
# $1, $2 and sometimes $3 and $4 will be defined.
#

my $xml_parser = qr{<([^/ >?]+)(?:(?: *\w+='(?!')(.+?)')+)?/?>?(?:(?!<)(.+?)<)?}s;    # Faster!

# my $xml_parser = qr{<(?:([^ >/?]+)[^>/]*>(?!<)(.+?)<|(?<=<)(?: *([^=><]+)='(?!')(.+?)')+/>)}s;    # Slower!
#
######################################################################################################

######################################### REGEXP: URL VALIDATION #####################################
# The bellow regex will validate an HTTP url.
# If it is valid, youtube-viewer will try to get
# an youtube video code from that website using /$get_youtube_code/

my $valid_url = qr{^

        ################# This regex will validate an HTTP URL #################
                                                               # Coded by Trizen

                # Valid urls #######################################
                #      http://9.Yz                                 #
                #      http://m.example.com/test.html              #
                #      https://mail.example.com/mail/?ver=1#inbox  #
                #      http://test-test.test-test.museum?id=2      #
                ####################################################

                # Invalid urls #####################################
                #     http://-test.com                             #
                #     http://test-.com                             #
                #     http://test-.com                             #
                #     http://test..com                             #
                #     http://test.-.com                            #
                #     http://test.-test.com                        #
                ####################################################

                https?://                # http, https followed by ://
                [[:alnum:]]              # first character must be a-zA-Z0-9
                (?:(?:(?:\w*-+\w+|\w+)*  # words, dash, words OR only words
                \.(?=\w))+?              # point if followed by word char
                |                        # OR (validates http://x.yz)
                \.)                      # a single point
                \w{2,6}                  # domain (words between 2 and 6 chars)
                (?:[#/?!]                # characters after domain
                [#-)+-;=?\\~\w]*)*       # rest characters of the string
$}x;

####################### TEMPORARY OPTIONS #######################
my $user_cache;         #               ||
my $user_cache_min;     #               ||
my $dont_exit;          #               \/
my $all_time;           # DON'T change this default values
my $lwp_is_set;         # unless you know what you're doing
my $video_results;      #               /\
my $user_resolution;    #               ||
my $playlists;          #               ||
my $user_fullscreen;    #               ||

####################### PRE-CHECKS #######################
# Check if https support is available
# If is not available, switch to http mode
unless (grep -e ("$_/LWP/Protocol/https.pm"), @INC) {
    $feeds_main_url =~ s/s//;
    $get_video_info =~ s/s//;
}

# Defining $mplayer_line
my $mplayer_line;
if ($constant{'win32'}) {
    my $smplayer = $ENV{'ProgramFiles'} . '\\SMPlayer\\mplayer\\mplayer.exe';    # Windows SMPlayer path

    if (-e $smplayer) {
        $mplayer_line = qq["$smplayer" $mplayer_settings];                       # Windows MPlayer line
    }
    else {
        warn "\n\n!!! Please install SMPlayer to stream Youtube videos.\n\n";
        $mplayer_line = "mplayer $mplayer_settings";
    }
}
else {
    $mplayer_line = "mplayer $mplayer_settings";                                 # *NIX MPlayer line
}

####################### MY PATH #######################
my @path = $constant{'win32'} ? split(/;/, $ENV{'PATH'}) : split(/:/, $ENV{'PATH'});

####################### LOOKING FOR WGET #######################
my $wget_is_available;

sub locate_wget {
    if (-x '/usr/bin/wget'
        or grep(($constant{'win32'}
                 ? do { 1 if -e "$_\\wget.exe" or -e "$_\\wget" }
                 : -x "$_/wget"
                ),
                @path)
    ) {
        $wget_is_available = 1;
    }
}

####################### LOOKING FOR GCAP #######################
my $gcap = '/usr/bin/gcap';    # default gcap path
foreach my $path (@INC, @path) {
    if (-e "$path/gcap") {
        $gcap = "$path/gcap";
        last;
    }
}

####################### LWP::UserAgent #######################
my $lwp;

sub set_lwp_useragent {
    require LWP::UserAgent;
    $lwp = 'LWP::UserAgent'->new;
    $lwp->agent('Mozilla/5.0 (X11; U; Linux i686; en-US) Chrome/10.0.648.45');
    $lwp->env_proxy;
    $lwp->timeout(15);
    $lwp->show_progress(1) if $debug;
    $lwp_is_set = 1;
}

####################### GET THE NEXT ARGUMENT #######################
sub get_next_argument {
    my $i = shift();
    if (defined $ARGV[$i] and chr ord $ARGV[$i] ne q{-}) {
        return splice(@ARGV, $i, 1);
    }
    else {
        die "error: option '$ARGV[$i-1]' requires an argument";
    }
}

####################### PARSING ARGUMENTS #######################
sub parse_arguments {
    my $i = 0;
    foreach my $arg (@_) {
        defined $arg ? ++$i : next;

        # If argument starts with a dash (-)
        if (chr ord $arg eq q{-}) {
            given ($arg) {

                ## Resolutions
                when (/^-+(?:2|240p?)$/) {
                    $resolution{'resolution'} = 240;
                }
                when (/^-+(?:3|360p?)$/) {
                    $resolution{'resolution'} = 360;
                }
                when (/^-+(?:4|480p?)$/) {
                    $resolution{'resolution'} = 480;
                }
                when (/^-+(?:7|720p?)$/) {
                    $resolution{'resolution'} = 720;
                }
                when (/^-+(?:1|1080p?)$/) {
                    $resolution{'resolution'} = 1080;
                }

                ## YouTube options
                when (/^-+time(?:=(.+))?$/) {
                    $time_p = $1 // get_next_argument($i);
                }
                when (/^-+author(?:=(.+))?$/) {
                    $from_author = $1 // get_next_argument($i);
                }
                when (/^-+m(?:ore)?$/) {
                    $results = 50;
                }
                when (/^-+o(?:rder.?by)?(?:=(.+))?$/) {
                    $order_by = $1 // get_next_argument($i);
                }
                when (/^-+r(?:egion)?(?:=(.+))?$/) {
                    $region = $1 // get_next_argument($i);
                }
                when (/^-+a(?:ll.?time)?$/) {
                    $all_time = 1;
                }
                when (/^-+page(?:=(\d+))?$/) {
                    $start_index = $results * do { $1 // get_next_argument($i) }
                      - $results + 1;
                }

                ## MPlayer options
                when (/^-+(?:fs?|fullscreen)$/) {
                    set_fullscreen_mode();
                    $user_fullscreen = 1;
                }
                when (/^-+(?:FS?|no.?fullscreen)$/) {
                    disable_fullscreen_mode();
                    $user_fullscreen = 1;
                }
                when (/^-+mplayer=(.+)/) {
                    $mplayer_line .= " $1";
                }
                when (/^-+l(?:ower.?cache)?$/) {
                    $user_lower_cache = 1;
                }
                when (/^-+cache(?:=(\d+))?$/) {
                    my $cache = $1 // get_next_argument($i);
                    $mplayer_line =~ s/-cache\s+\d+/-cache $cache/;
                    $user_cache = 1;
                }
                when (/^-+cache.?min(?:=(\d+))?$/) {
                    my $cache_min = $1 // get_next_argument($i);
                    $mplayer_line =~ s/-cache-min\s+\d+/-cache-min $cache_min/;
                    $user_cache_min = 1;
                }
                when (/^-+n(?:o.?video)?$/) {
                    $constant{'win32'}
                      ? $mplayer_line =~ s/mplayer\.exe"/mplayer.exe" -novideo/
                      : $mplayer_line =~ s/mplayer /mplayer -novideo /;
                    $resolution{'resolution'} = 480 unless $user_resolution;
                }
                when (not $constant{'win32'} and /^-+(?:gnome-mplayer|G)$/) {
                    substr($mplayer_line, 0, 0, 'gnome-');
                    $mplayer_line =~ s/\B-.+//;
                }

                ## Other options
                when ($_ eq '--debug') {
                    $debug = 1;
                }
                when (/^-+(?:A|(?:play.)?all)$/) {
                    $playback = 1;
                }
                when (/^-+d(?:ownload)?$/) {
                    $download_video = 1;
                    if (not $lwp_downloading and not $wget_is_available) {
                        locate_wget();
                    }
                }
                when (/^-+(?:L|(?:lwp|LWP)-download)$/) {
                    $lwp_downloading = 1;
                }
                when (/^-+(?:sub|lang)(?:=([\w]{2,5}))?$/) {
                    $default_sub = $1 // get_next_argument($i);
                    $default_sub = lc $default_sub unless $default_sub =~ /_/;
                }
                when (/^-+(?:P|proxy)(?:=(.+))?$/) {
                    set_lwp_useragent() unless $lwp_is_set;
                    my $proxy = $1 // get_next_argument($i);
                    $proxy = 'http://' . $proxy unless $proxy =~ /^https?:/;
                    $lwp->proxy(['http', 'https'], $proxy);
                }
                when (not $constant{'win32'} and /^-+(?:C|cl|colou?rs?)$/) {
                    $colours = 1;
                }
            }
        }
        else {
            $keywords .= "$arg ";
        }
    }

    if (exists $resolution{'resolution'}) {
        $user_resolution = 1;
    }
    else {
        $resolution{'resolution'} = 0;
    }

    # Set 1080p resolution if $playback is 1
    # and not any other resolution is selected
    if ($playback and not $user_resolution) {
        $resolution{'resolution'} = 1080;
    }
    parse_sub_calling_arguments(@_);
}
parse_arguments(@ARGV);

####################### PARSING ARGUMENTS WHICH CALLS A SUBROUTINE #######################
sub parse_sub_calling_arguments {
    my $i = 0;
    foreach my $arg (@_) {
        defined $arg ? ++$i : next;

        # If argument starts with a dash (-)
        if (chr ord $arg eq q{-}) {
            given ($arg) {
                when (/^-+(?:[h?]|help|usage)$/) {
                    help();
                }
                when (/^-+v(?:ersion)?$/) {
                    version();
                }
                when (/^-+(?:T|tricks|tips)$/) {
                    tips_and_tricks();
                }
                when (/^-+(?:pl?|playlists?)$/) {
                    search_playlists();
                }
                when (/^-+c(?:ategories)?$/) {
                    categories_area();
                }
                when (/^-+(?:M|movies)$/) {
                    youtube_movies();
                }
                when (/^-+(?:[at]|all.?time|today.?(?:tops)?|tops)$/) {
                    youtube_tops();
                }
                when (/^-+u(?:sername)?(?:=(\w+))?$/) {
                    videos_from_username($1 // get_next_argument($i));
                }
                when (/^-+u(?:ser(?:name)?)?.?p(?:laylists?)?(?:=(\w+))?$/) {
                    playlists_from_username($1 // get_next_argument($i));
                }
                when (/^-+(?:U|user(?:name)?s)(?:=(.+))?$/) {
                    if (defined $1 and -r $1) {
                        $users_file = $1;
                    }
                    list_user_names();
                }
            }
        }
    }
}

####################### LOOKING FOR NON-ARGUMENTS #######################
my $non_argv = 0;
foreach my $arg (@ARGV) {
    if (not chr ord $arg eq q{-} or length $arg == 11) {
        $non_argv = 1;
        last;
    }
}

####################### GO TO insert_url() IF $non_argv is FALSE #######################
sub insert_url {
    print "\n$bred=>>$bgreen Insert an YouTube URL or search something...\n$reset> ";

    given (<STDIN>) {
        chomp;

        when (/$quit_required/o) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(grep((chr ord $_ eq q{-}), split(/\s+/, $_, 0)));
        }
        when (/$get_youtube_code/o) {
            get_youtube($1);
        }
        when (/$get_playlist_code/o) {
            list_playlist($1);
        }
        when (/$valid_playlist_code/o) {
            list_playlist($1);
        }
        when (m{^https?://} and /$valid_url/o) {
            code_from_content($_);
        }
        when ($_ eq q{}) {
            warn "\n$bred(x_x) Unable to continue...$reset\n\n";
            exit;
        }
        default {
            search($_);
        }
    }
}
insert_url() unless $non_argv;

####################### GET A VIDEO CODE FROM AN WEBSITE CONTENT #######################
sub code_from_content {
    set_lwp_useragent() unless $lwp_is_set;

    if ($lwp->get($_[0])->content =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
    else {
        search($_[0]);
    }
}

####################### TRUE IF ARGUMENT LOOKS LIKE AN YOUTUBE CODE #######################
sub is_code {
    return 1 if length $_[0] == 11 and $_[0] =~ /^[\w\-]{11}$/ and $_[0] =~ /[\d[:upper:]_\-]/;
    return 0;
}

####################### PARSING VIDEO CODES SPECIFIED AS ARGUMENTS #######################
foreach my $code (@ARGV) {
    given ($code) {
        when (\&is_code) {
            $dont_exit = 1;
            get_youtube($_);
        }
        when (/$get_playlist_code/o) {
            list_playlist($1);
        }
        when (/$valid_playlist_code/o) {
            list_playlist($1);
        }
        when (/$get_youtube_code/o) {
            $dont_exit = 1;
            get_youtube($1);
        }
        when (m{^https?://} and /$valid_url/o) {
            code_from_content($_);
        }
    }
}

####################### YOUTUBE-VIEWER USAGE #######################
sub help {
    print "\n  " . q{=} x 30 . " \U$appname\E " . q{=} x 30 . "
\t\t\t\t\t\t by Trizen (trizenx\@gmail.com)
\nUsage: $appname [options] ([code] || [url] || [keywords])
\nBase Options:
   <url>                : play an YouTube video by URL
   <code>               : play an YouTube video by code
   <keywords>           : search and list YouTube videos
   <playlist_url>       : list a playlist of YouTube videos
\nYouTube options:
   -t, --today          : shows today YouTube tops
   -a, --all-time       : shows all time YouTube tops
   -c, --categories     : shows available YouTube categories
   -m, --more           : shows more video results (50 clips)
   -p, --playlist       : search for YouTube playlists
   -M, --movies         : show YouTube movies categories
   --region=<ID>        : set a specific regionID (ex: US)
   -u  <username>       : list videos uploaded by a specific user
   -up <username>       : list playlists created by a specific user
   -author='USERNAME'   : search videos uploaded by a particular user
   -order-by='ORDER'    : order entries by: published, viewCount or rating
   -time='TIME'         : valid values are: today, this_week and this_month
   -page='PAGE_NR'      : show video results starting with page number 'n'
   -2, -3, -4, -7, -1   : plays videos at 240p, 360p, 480p, 720p or 1080p
\nMPlayer options:
   -f, --fullscreen     : plays video(s) in fullscreen mode
   -F, --no-fullscreen  : disable fullscreen mode
   -n, --novideo        : plays only the audio track of video(s)
   -l, --lower-cache    : set a lower cache for MPlayer (for slow connections)
   -mplayer='SETTINGS'  : add some extra options to the MPlayer line
   -sub='LANG'          : subtitle language (default: en) (depends on gcap)
   -cache='VALUE'       : set cache for MPlayer (default: $cache)
   -cache-min='VALUE'   : set cache-min for MPlayer (default: $cache_min)
\nOther options:
   -d, --download       : downloads YouTube video(s) with LWP
   -A, --all            : plays all video results in order
   -C, --colors         : use colors for text output
   -U, --users=file.txt : list YouTube usernames from a file
   -P, --proxy=<PROXY>  : set proxy for LWP::UserAgent
   -L, --lwp-download   : download videos with LWP (default: wget)
   -G, --gnome-mplayer  : use gnome-mplayer instead of mplayer
   -T, --tricks         : show more 'hidden' features of $appname
   -v, --version        : prints version and exits
   -h, --help           : prints help and exits
\nTips and tricks:
  1. After search results, press <ENTER> for the next page
  2. After search results, insert 'back' for the previous page
  3. View more tips and tricks by executing '$appname -T'\n\n";
    exit 0;
}

####################### YOUTUBE-VIEWER TIPS AND TRICKS #######################
sub tips_and_tricks {
    print "
                        $bred>>$bgreen Tips and tricks $bred<<$reset

\n$bred*$bgreen After search results you can insert:$reset
    <ENTER>, next   : for the next page of video results
    back            : for the previous page of video results
    reset           : reset all arguments (application restarts)
    4 5 9 1         : play videos in a specific order
    2-6, 2..6       : same thing as 2 3 4 5 6
    2,5 -f          : play 2nd and 5th video in fullscreen mode $bred*$reset
    10 -d           : download 10th video with LWP or wget $bred*$reset
    /REGEXP/        : play videos matched by a regexp  (e.g.: /part [2-6]/)
    <YOUTUBE URL>   : play an YoutTube video specified by URL
    <UNKNOWN URL>   : connect to URL and get an YouTube code from it
    <ARGUMENTS>     : apply some arguments during the run-time
                      (example: -u=USERNAME, -p, -c, test --author=USERNAME)
\n$bred*$reset Arguments will remain activated!
\n$bred*$bgreen Did you know that...$reset
    -p as a STDIN argument, will return to playlists menu
    -A option will play ALL video results, including videos from the next pages
    $appname prints to STDOUT the current playing YouTube URL
    /REGEXP/ will match case-insensitive (e.g.: 'test' matches 'TeSt')
\n$bred*$bgreen Examples:$reset\n
 ** Show videos uploaded by 'MIT' that matches 'computer science',
    starting with page number 2, in fullscreen mode and 720p resolution.
    % $appname --author=MIT computer science --page=2 -fs --720p\n
 ** Show playlists created by a specific user
    % $appname -up khanacademy\n
 ** Show latest videos (50) uploaded by a specific user and a colourful output
    % $appname -u google -m -C\n\n";
    exit 0;
}

####################### YOUTUBE-VIEWER VERSION #######################
sub version {
    print "Youtube Viewer $version\n";
    exit 0;
}

####################### LIST YOUTUBE USERNAMES FROM A FILE #######################
sub list_user_names {
    if (-r $users_file) {

        my $i = 0;
        my %usernames_table;
        print "\n";

        open my $fh, '<:crlf', $users_file;
        while (defined(my $username = <$fh>)) {
            next unless $username =~ /^\w+$/;
            chomp $username;
            ++$i;
            print do {
                q{ } if $i < 10;
            }, "$bred$i$reset - $bgreen$username$reset\n";
            $usernames_table{$i} = $username;
        }
        close $fh;

        print "\n$bred=>$bgreen Pick an username number$reset\n> ";

        given (<STDIN>) {
            chomp;

            when (/$quit_required/o or $_ eq q{}) {
                exit;
            }
            when (/$contains_arguments/o) {
                parse_arguments(grep((chr ord $_ eq q{-}), split(/\s+/, $_, 0)));
                continue;
            }
            when (exists $usernames_table{$_}) {
                videos_from_username($usernames_table{$_});
            }
            when (/^\w+$/) {
                videos_from_username($_);
            }
            when (m{/(.+?)/}) {
                my $match = qr/$1/i;
                my @found = ();
                my $found = 0;
                print "\n";
                while (my ($number, $username) = each %usernames_table) {
                    if ($username =~ /$match/o) {
                        print $bred, do { q{ } if ++$found < 10 }, "$found$reset - $bgreen$username$reset\n";
                        push(@found, $found);
                        $usernames_table{$found} = $username;
                    }
                }
                if (@found > 1) {
                    print "\n$bred=>>$bgreen Pick an username number$reset\n> ";
                    given (<STDIN>) {
                        chomp;

                        when (/$quit_required/o or $_ eq q{}) {
                            exit;
                        }
                        when (exists $usernames_table{$_}) {
                            videos_from_username($usernames_table{$_});
                        }
                        default {
                            list_user_names();
                        }
                    }
                }
                elsif (@found) {
                    videos_from_username($usernames_table{$found[0]});
                }
                continue;
            }
            default {
                list_user_names();
            }
        }
    }
}

####################### GET VIDEOS FROM A SPECIFIC USER #######################
sub videos_from_username {
    parse_url("$feeds_main_url/users/$_[0]/uploads");
}

####################### PRINT PLAYLISTS #######################
sub print_playlists {

    # PlaylistID (0), Number (1), Title (2), Description (3), Author (4), VideosCount (5)
    $colours
      ? print($cblack, $bred, $_[0][1], $reset, $cblack, q{ - }, $byellow, $_[0][2], q{ },
              $_[0][3], $reset, $cblack,  ' (',   $bpurle, 'by ', $_[0][4], $reset, $cblack,
              ') (',    $bblue, $_[0][5], $reset, $cblack, ')',   $reset,   "\n")
      : print($bred, $_[0][1], $reset, ' - ', $_[0][2], q{ }, $_[0][3], ' (by ', $_[0][4], ') (', $_[0][5], ")\n");
}

####################### GET PLAYLISTS FROM A SPECIFIC USER #######################
my $playlist_index;

sub playlists_from_username {

    my @playlists;
    $playlists = 1;
    my $username = shift();
    $playlist_index = shift() || $start_index;
    my $i = -1;

    parse_content(
                 "http://gdata.youtube.com/feeds/api/users/$username/playlists?max-results=$results&start-index=$playlist_index");

    unless (@results) {
        print "$bred(x_x) No playlist has been found...$reset\n";
        print "\n$bred=>>$bgreen Insert another username:$reset ";
        given (<STDIN>) {
            chomp;

            when (/$quit_required/o or $_ eq q{}) {
                exit;
            }
            default {
                playlists_from_username($_);
            }
        }
    }

    # PlaylistID, Number, Title, Description, Author, VideosCount
    foreach my $playlist (@results) {
        print_playlists($playlist);
    }

    print "\n$bred=>>$bgreen Pick one playlist or insert another username$reset\n> ";

    given (<STDIN>) {
        chomp;

        when (/$quit_required/o) {
            exit;
        }
        when (/$contains_arguments/o) {
            $playlists = 0;
            parse_arguments(grep((chr ord $_ eq q{-}), split(/\s+/, $_, 0)));
            $playlists = 1;
            continue;
        }
        when (/^\s*$/ or $_ eq 'next') {
            playlists_from_username($username, $playlist_index + $results);
        }
        when ($_ eq 'back' and $playlist_index > $results) {
            playlists_from_username($username, $playlist_index - $results);
        }
        when (/^\d+$/) {
            $playlists = 0;
            list_playlist($results[$_ - 1][0]);
        }
        when (/^\w+$/) {
            playlists_from_username($_, $start_index);
        }
        default {
            playlists_from_username($username);
        }
    }
}

####################### SEARCH FOR YOUTUBE PLAYLISTS #######################
sub search_playlists {
    my $url = shift();

    my $length = length $keywords;
    if ($length > 0) {
        $keywords = scalar reverse(unpack("A$length", reverse(unpack("A$length", $keywords))));
        $url //= "$feeds_main_url/playlists/snippets?q=$keywords&start-index=$start_index&max-results=$results&v=2";
        $playlists = 1;
        parse_content($url);
    }

    my $n = -1;

    foreach my $playlist (@results) {
        print_playlists($playlist);
    }

    print "\n$bred=>>$bgreen Pick one playlist or search others$reset\n> ";

    given (<STDIN>) {
        chomp;

        when (/$quit_required/o) {
            exit;
        }
        when (/$contains_arguments/o) {
            $playlists = 0;
            parse_arguments(grep((chr ord $_ eq q{-}), split(/\s+/, $_, 0)));
            $playlists = 1;
            continue;
        }
        when (/^\s*$/ or $_ eq 'next') {
            $url =~ s/(?<=[&?]start-index=)(\d+)/($1 + $results);/e;
            search_playlists($url);
        }
        when ($_ eq 'back') {
            if (do { $url =~ /[&?]start-index=(\d+)/; $1 > $results }
              ) {
                $url =~ s/(?<=[&?]start-index=)(\d+)/($1 - $results);/e;
                search_playlists($url);
            }
        }
        when (/^\d+$/) {
            $playlists = 0;
            list_playlist($results[$_ - 1][0]);
        }
        default {
            $keywords = $_;
            search_playlists();
        }
    }

}

####################### LIST A YOUTUBE PLAYLIST #######################
sub list_playlist {
    parse_url("$feeds_main_url/playlists/$_[0]");
}

####################### LIST YOUTUBE MOVIE CATEGORIES #######################
sub youtube_movies {
    print "\n";

    my $i = 0;
    my %movie_table;

    foreach my $movie_cat_name ('most_popular', 'most_recent', 'trending') {
        my $cat_name = ucfirst $movie_cat_name;
        $cat_name =~ tr/_/ /;
        print q{ }, $bred, ++$i, "$reset - $cat_name\n";
        $movie_table{$i} = $movie_cat_name;
    }

    print "\n$bred=>>$bgreen Pick one category$reset\n> ";

    given (<STDIN>) {
        chomp;

        when (/$quit_required/o or $_ eq q{}) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(grep((chr ord $_ eq q{-}), split(/\s+/, $_, 0)));
        }
        when (exists $movie_table{$_}) {
            parse_url("$feeds_main_url/charts/movies/$movie_table{$_}");
        }
    }
}

####################### LIST YOUTUBE TOP VIDEO CATEGORIES #######################
sub youtube_tops {
    my $i             = 0;
    my $today         = $all_time ? 0 : 1;
    my $standardfeeds = "$feeds_main_url/standardfeeds";
    my %tops_table;

    print "\n";

    foreach my $cat_top_name ('top_rated',   'top_favorites',  'most_viewed',    'most_popular',
                              'most_recent', 'most_discussed', 'most_responded', 'recently_featured'
      ) {
        my $top_name = ucfirst $cat_top_name;
        $top_name =~ tr/_/ /;
        print q{ }, $bred, ++$i, "$reset - $top_name\n";
        $tops_table{$i} = $cat_top_name;
    }

    print "\n$bred=>>$bgreen Pick one category$reset\n> ";

    given (<STDIN>) {
        chomp;

        when (/$quit_required/o or $_ eq q{}) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(grep((chr ord $_ eq q{-}), split(/\s+/, $_, 0)));
        }
        when (exists $tops_table{$_}) {
            my $url = $standardfeeds . q{/} . $tops_table{$_};
            if ($today and not $url =~ /recent/) {
                $url .= '?time=today';
            }
            parse_url($url);
        }
        default {
            youtube_tops();
        }
    }
}

####################### LIST YOUTUBE VIDEO CATEGORIES #######################
sub categories_area {
    set_lwp_useragent() unless $lwp_is_set;

    my $n = 0;
    my %categories_table;

    print "\n";

    foreach
      my $cat_line (split('<atom:category term=', $lwp->get('http://gdata.youtube.com/schemas/2007/categories.cat')->content, 0))
    {
        if (not $cat_line =~ /deprecated/ and $cat_line =~ /^'(.+?)'\s+label='(.+?)'/) {
            ++$n;
            my $cat_name  = $1;
            my $cat_label = $2;
            $cat_label =~ s/&amp;/&/;
            print do {
                q{ } if $n < 10;
            }, $bred, $n, $reset, ' - ', $cat_label, "\n";
            $categories_table{$n} = $cat_name;
        }
    }

    print "\n$bgreen=>> Insert a category number\n>$reset ";

    given (<STDIN>) {
        chomp;

        when (/$quit_required/o or $_ eq q{}) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(grep((chr ord $_ eq q{-}), split(/\s+/, $_, 0)));
        }
        when (exists $categories_table{$_}) {
            parse_url("$feeds_main_url/standardfeeds/recently_featured_$categories_table{$_}");
        }
        default {
            categories_area();
        }
    }
}

####################### PLAY OR DOWNLOAD AN YOUTUBE VIDEO #######################
sub play_or_download {

    my $streaming = shift;

    print "** STREAMING: $streaming\n\n" if $debug;

    ## DOWNLOADING
    if ($download_video) {
        my $title = shift @_;
        $title =~ tr{/}{|};    # replaces '/' with '|'

        if (not -e "$title.mp4") {
            if ($wget_is_available) {

                # Downloading video with wget
                system "wget -nc '${streaming}' -O \Q$title\E.mp4";
            }
            else {

                # Downloading video with LWP
                print "** Saving to: '$title.mp4'\n";
                $lwp->show_progress(1);
                $lwp->mirror($streaming, "$title.mp4");
                $lwp->show_progress(0);
            }
        }
        else {
            warn "** '$title.mp4' already exists...\n";
        }
    }

    ## STREAMING
    else {
        print "** MPlayer Line: $mplayer_line\n\n" if $debug;

        # Executing $mplayer_line with '$streaming' as an argument
        `$mplayer_line '$streaming'` unless $debug;

        # Change directory back to the main working directory
        chdir $constant{'cwd'} if exists $constant{'cwd'};
    }

    print "\n";

    disable_fullscreen_mode() unless $user_fullscreen;

    if (@picks) {
        foreach_pick();    # play the next video
    }
    elsif ($playback) {
        next_page();
    }

    if ($video_results and not $dont_exit) {
        print_results();    # back to video results
    }

    exit unless $dont_exit;
}

####################### SEARCH YOUTUBE VIDEOS #######################
search() unless $dont_exit or $playlists;

sub search {
    $keywords = shift() // $keywords;

    # Get words which doesn't begins with a dash (-);
    $keywords = join(q{ }, grep((chr ord $_ ne q{-}), split(/\s+/, $keywords, 0)));

    $keywords = uri_escape($keywords);
    $youtube_gdata_url =
        $feeds_main_url
      . '/videos?q='
      . $keywords
      . '&max-results='
      . $results
      . '&time='
      . $time_p
      . '&orderby='
      . $order_by
      . '&start-index='
      . $start_index . '&v=2';

    if (defined $from_author) {
        $youtube_gdata_url .= '&author=' . $from_author;
    }

    if (defined $region) {
        $youtube_gdata_url .= '&region=' . $region;
    }
    parse_content($youtube_gdata_url);
    print_results();
}

####################### PREPARE GDATA FEEDS URL #######################
sub parse_url {
    $youtube_gdata_url = shift() // $youtube_gdata_url;

    if ($youtube_gdata_url =~ /^$feeds_main_url/o) {

        if (not $youtube_gdata_url =~ /[?]/) {
            $youtube_gdata_url .= "?start-index=$start_index";
        }
        else {
            $youtube_gdata_url .= "&start-index=$start_index";
        }

        $youtube_gdata_url .= "&max-results=$results&v=2";

        if (defined $region) {
            $youtube_gdata_url .= "&region=$region";
        }
        parse_content($youtube_gdata_url);
        print_results();
    }
    else {
        search $youtube_gdata_url;
    }
}

####################### GET AND PARSE GDATA CONTENT #######################
sub parse_content {

    set_lwp_useragent() unless $lwp_is_set;

    undef @results;
    my $number = 0;

    foreach my $entry (split(/<entry/, $lwp->get($_[0])->content, 0)) {

        my %gdata;
        while ($entry =~ /$xml_parser/og) {
            $gdata{$1} = $3 // $2 // next;
        }

        $playlists
          ? do { next unless exists $gdata{'yt:playlistId'} }
          : do { next unless exists $gdata{'yt:videoid'} };

        ++$number;

        $playlists
          ?

          # PlaylistID, Number, Title, Description, Author, VideosCount
          push(
            @results,
            [$gdata{'yt:playlistId'},
             do {
                 $number < 10 ? " $number" : $number;
             },
             do {
                 my $title = $gdata{'title'} // 'Unknown';
                 $title =~ /$has_entities/o ? $title = decode_entities($title) : $title;
             },
             do {
                 my $summary = $gdata{'summary'} // "\cH";
                 $summary = join(q{ }, split(/\s+/, $summary, 0));
                 my $summary_limit = 32;    # characters limit
                 $summary =~ /$has_entities/o
                   ? length $summary > $summary_limit
                       ? substr(decode_entities($summary), 0, $summary_limit)
                       : decode_entities($summary)
                   : (length $summary > 32 ? substr($summary, 0, $summary_limit) : $summary);
             },
             $gdata{'name'},
             do {
                 $gdata{'gd:feedLink'} // $gdata{'yt:countHint'} // $gdata{'countHint'};
               }
            ])
          :

          # VideoID, Title, Author, Duration, Views, Date, CategoryLabel, Description, Number
          push(
            @results,
            [$gdata{'yt:videoid'},
             do {
                 my $title = $gdata{'title'} // 'Unknown';
                 $title =~ /$has_entities/o ? decode_entities($title) : $title;
             },
             $gdata{'name'},
             format_time($gdata{'yt:duration'}),
             $gdata{'yt:statistics'},
             do {
                 $gdata{'yt:uploaded'} // $gdata{'published'};
             },
             $gdata{'media:category'},
             $gdata{'media:description'},
             do {
                 $number < 10 ? " $number" : $number;
               }
            ]);
    }
    print "\n";
}

# Format seconds to HH:MM:SS
sub format_time {
    my $sec = shift();
    my $tmp_time;
    do { $tmp_time = $sec / 3600 % 24; $tmp_time > 0 ? $tmp_time > 9 ? "$tmp_time:" : "0$tmp_time:" : q{} }
      . do        { $tmp_time = $sec / 60 % 60; $tmp_time > 9 ? $tmp_time : "0$tmp_time" }
      . q{:} . do { $tmp_time = $sec % 60;      $tmp_time > 9 ? $tmp_time : "0$tmp_time" };
}

####################### PRINT RESULTS FROM @results #######################
sub print_results {

    if (@results) {
        $video_results = 1;
    }
    else {
        print "$bred(x_x) No video results!$reset\n";
        insert_url();
    }

    foreach my $video (@results) {
        $colours
          ? print($cblack, $bred, $$video[8], $reset, $cblack, q{ - }, $byellow, $$video[1],
                  $reset, $cblack, ' (',       $bpurle, 'by ',   $$video[2], $reset, $cblack,
                  ') (',  $bblue,  $$video[3], $reset,  $cblack, ')',        $reset, "\n")
          : print "$bred$$video[8]$reset - $$video[1] (by $$video[2]) ($$video[3])\n";
    }

    if ($playback) {
        @picks = 1 .. @results;
        foreach_pick();
    }

    print "\n$bred=>>$bgreen Insert a number or search something else\n$reset> ";

    given (<STDIN>) {
        chomp;

        when (/$quit_required/o) {
            exit;
        }
        when (/$contains_arguments/o) {
            parse_arguments(grep((chr ord $_ eq q{-}), split(/\s+/, $_, 0)));
            continue;
        }
        when ($_ eq 'reset') {
            undef @ARGV;
            do $0;
        }
        when (/^\s*$/ or $_ eq 'next') {
            next_page();
        }
        when ($_ eq 'back') {
            if (do { $youtube_gdata_url =~ /[&?]start-index=(\d+)/; $1 > $results }
              ) {
                previous_page();
            }
            else {
                search($_);
            }
        }
        when ($_ eq 'all') {
            parse_arguments('--1080p') unless $user_resolution;
            @picks = 1 .. scalar @results;
            foreach_pick();
        }
        when (/$get_youtube_code/o) {
            get_youtube($1);
        }
        when (/$get_playlist_code/o) {
            list_playlist($1);
        }
        when (/$valid_playlist_code/o) {
            list_playlist($_);
        }
        when (m{^https?://} and /$valid_url/o) {
            code_from_content($_);
        }
        when (chr ord $_ eq q{/} and /$match_regexp/o) {
            my $match = qr/$1/i;
            @picks = grep { $results[$_ - 1][1] =~ /$match/ } 1 .. @results;
            if (@picks) {
                foreach_pick();
            }
            else {
                warn "\n${bred}(X_X) No video matched by the regexp: $bgreen/$match/$reset\n\n";
                sleep 1;
                print_results();
            }
        }
        when (\&is_code) {
            get_youtube($_);
        }
        when (/\d/ and not /(?:\s|^)[^\d-]/) {
            s/(?:\D|^)-+\d+(?:\w+)?//g;                          # remove resolution arguments (e.g.: --360p);
            s/(\d+)(?:-|[.][.])(\d+)/join q{ }, $1 .. $2;/eg;    # '2..5' will be '2 3 4 5'
            @picks = grep { $_ > 0 and $_ <= scalar @results if /^\d+$/ } split /[[:punct:] ]+/, $_;
            @picks ? foreach_pick() : continue;
        }
        default {
            search($_);
        }
    }
}

sub foreach_pick {
    while (@picks) {
        get_youtube($results[shift(@picks) - 1]);
    }
}

####################### NEXT PAGE #######################
sub next_page {
    if ($youtube_gdata_url =~ s/(?<=[&?]start-index=)(\d+)/($1 + $results);/e) {
        parse_content $youtube_gdata_url;
        print_results();
    }
}

####################### PREVIOUS PAGE #######################
sub previous_page {
    if ($youtube_gdata_url =~ s/(?<=[&?]start-index=)(\d+)/($1 - $results);/e) {
        parse_content $youtube_gdata_url;
        print_results();
    }
}

sub set_fullscreen_mode {
    unless ($mplayer_line =~ /-fs /) {
        $constant{'win32'}
          ? $mplayer_line =~ s/mplayer\.exe"/mplayer.exe" -fs/
          : $mplayer_line =~ s/mplayer /mplayer -fs /;
    }
}

sub disable_fullscreen_mode {
    $mplayer_line =~ s/-fs //;
}

sub select_resolution {
    given ($resolution{'resolution'}) {
        when (1080) {
            if (exists $streaming{1080}) {
                default_cache();
                set_fullscreen_mode() unless $user_fullscreen;
                return $streaming{1080};
            }
            else {
                exists $streaming{720} ? default_cache() : lower_cache();
                return lower_quality();
            }
        }
        when (720) {
            if (exists $streaming{720}) {
                default_cache();
                return $streaming{720};
            }
            else {
                lower_cache();
                return lower_quality();
            }
        }
        when (480) {
            lower_cache();
            return $streaming{480} // lower_quality();
        }
        when (360) {
            lower_cache();
            return $streaming{360} // lower_quality();
        }
        when (240) {
            lower_cache();
            return $streaming{240} // lower_quality();
        }
        default {
            if (exists $streaming{1080}) {
                pick();
            }
            elsif (exists $streaming{720}) {
                default_cache();
                return $streaming{720};
            }
            else {
                lower_cache();
                return lower_quality();
            }
        }
    }
}

sub lower_quality {
    foreach my $itag (sort { $b <=> $a } values %itags) {
        if (exists($streaming{$itag})) {
            return $streaming{$itag};
        }
    }
}

sub format_itags {
    my @itags;
    foreach my $itag (@_) {
        if (exists($itags{$itag})) {
            push @itags, $itags{$itag};
        }
    }
    @itags;
}

sub get_youtube {

    # VideoID, Title, UploaderName, Duration, Views, Date, CategoryLabel, Description, Number
    my ($code, $title, $author, $duration, $views, $published, $category, $description) = ref $_[0] ? @{$_[0]} : @_;

    if (defined $description) {
        $description = decode_entities($description) if $description =~ /$has_entities/o;
    }
    else {
        $description = 'No description available...';
    }

    set_lwp_useragent() unless $lwp_is_set;

    my $content = $lwp->get("$get_video_info?&video_id=$code&el=detailpage&ps=default&eurl=&gl=US&hl=en")->content;

    my $url = "http://www.youtube.com/watch?v=$code";

    $mplayer_line =~ s/ *\Q$mplayer_srt_settings\E *-sub.*//;

    # Getting YouTube closed captions with gcap
    if (    -e $gcap
        and not $mplayer_line =~ / -novideo/
        and $content =~ /&has_cc=True&/
        and not $download_video) {

        unless (exists $constant{'cwd'}) {
            require Cwd;
            $constant{'cwd'} = Cwd::getcwd();
        }

        chdir $constant{'tmp_dir'};    # change directory to 'tmp_dir' and get the .srt file

        unless (-e "${code}_$default_sub.srt") {
            system "perl $gcap '${url}'";
        }

        my $srt_file;
        if (-e "${code}_$default_sub.srt") {
            $srt_file = "${code}_$default_sub\.srt";
            $mplayer_line .= " $mplayer_srt_settings -sub $srt_file";
        }
        else {
            opendir(my $dir_h, $constant{'tmp_dir'});
            while (defined(my $line = readdir $dir_h)) {
                next unless $line =~ /[.]srt$/;
                if ($line =~ /^$code\w*[.]srt/p) {
                    $srt_file = ${^MATCH};
                    $mplayer_line .= " $mplayer_srt_settings -sub $srt_file";
                    last;
                }
            }
            closedir $dir_h;
        }
    }

    if ($content =~ /url_encoded_fmt_stream_map=(.+?)&/) {
        my $streaming = $1;
        $streaming =~ s/%253A/:/gi;
        $streaming =~ s{%252F}{/}gi;
        $streaming =~ s/%2526/&/g;
        $streaming =~ s/%253D/=/gi;
        $streaming =~ s/%253F/?/gi;
        $streaming =~ s/%25252C/,/gi;

        undef %streaming;

        my (@streaming_urls) = grep(/^https?:/, split(/url%3D(.+?)%26/, $streaming));
        @streaming{format_itags(map(/&itag=(\d+)&/, @streaming_urls))} =
          grep((
             exists $itags{
                 do { /&itag=(\d+)&/; $1 }
               }
            ),
            @streaming_urls);

        if ($debug) {
            while (my ($key, $value) = each %streaming) {
                print "KEY = $key\nVALUE = $value\n\n";
            }
        }

        print "\n";

        my $rating = sprintf('%.2f', ($content =~ /avg_rating=([^&]+)/));

        if (not defined $title) {
            parse_content("$feeds_main_url/videos/$code?v=2");
            ($code, $title, $author, $duration, $views, $published, $category, $description) = @{$results[0]};
        }

        $category =~ s/&amp;/&/;
        $published = "$3.$2.$1" if $published =~ /^(\d\d\d\d)-(\d\d)-(\d\d)/;

        if (length $views > 3) {
            my $l = length($views) - 3;
            my $i = ($l - 1) % 3 + 1;
            my $x = substr($views, 0, $i) . q{,};
            while ($i < $l) {
                $x .= substr($views, $i, 3) . q{,};
                $i += 3;
            }
            $views = $x . substr($views, $i);
        }

        print "$bred=>> $bgreen$title$reset\n",
          "$constant{'dash_line'}\n",
          "$description\n$constant{'dash_line'}\n",
          "$bred=>> ${bgreen}View & Download$reset\n",
          "$constant{'dash_line'}";

        my ($get) = $streaming_urls[0];
        print "\n* URL ";
        print STDOUT $url;
        print "\n* GET $get\n$constant{'dash_line'}\n",
          q{ } x ((length($constant{'dash_line'}) - length($title)) / 2 - 4),    # centring video title on terminal
          "$bred=>> $bgreen$title$bred <<=\n$reset\n",
          "** Author    : $author\n",
          "** Category  : $category\n",
          "** Duration  : $duration\n",
          "** Rating    : $rating\n",
          "** Views     : $views\n",
          "** Published : $published\n",
          "$constant{'dash_line'}\n\n";

        play_or_download(select_resolution(), $title);
    }
    else {
        warn "\n$bred(x_x) Something went wrong...$reset\n\n$bred(x_x) Unable to stream: $reset$url\n\n";

        if ($video_results and not $dont_exit) {

            unless (@picks) {
                sleep 1;
                print_results();
            }
        }
        else {

            unless ($video_results or $dont_exit) {
                exit;
            }
        }
    }
}

sub pick {
    print "$bred=>> $bgreen Please choose a video resolution (default: 1)$reset\n
$bred 1$reset - 1280x720  (720p)
$bred 2$reset - 1920x1080 (1080p)\n", q{=} x 23, "\n\n$bgreen=>> Pick format:$reset ";

    given (<STDIN>) {
        chomp;

        when (/$quit_required/o) {
            exit;
        }
        when ($_ eq q{2}) {
            $resolution{'resolution'} = 1080;
            default_cache();
            set_fullscreen_mode() unless $user_fullscreen;
            return $streaming{1080};
        }
        default {
            $resolution{'resolution'} = 720;
            default_cache();
            return $streaming{720};
        }
    }
}

# Set a lower cache if $user_lower_cache is TRUE
sub lower_cache {
    $mplayer_line =~ s/-cache\s+\d+/-cache 1000/      unless $user_cache;
    $mplayer_line =~ s/-cache-min\s+\d+/-cache-min 3/ unless $user_cache_min;
}

# Set default cache for 720p and 1080p resolutions
sub default_cache {
    if (not $user_lower_cache) {
        $mplayer_line =~ s/-cache\s+\d+/-cache $cache/             unless $user_cache;
        $mplayer_line =~ s/-cache-min\s+\d+/-cache-min $cache_min/ unless $user_cache_min;
    }
    else {
        lower_cache();
    }
}
