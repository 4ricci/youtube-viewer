#!/usr/bin/perl

# Copyright (C) 2010-2012 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#-------------------------------------------------------
#  Appname: youtube-viewer
#  Created on: 02 Jun 2010
#  Latest edit on: 22 January 2012
#  Website: http://trizen.googlecode.com
#-------------------------------------------------------
#
# [?] What is this script for?
#  - This script is useful to search and watch YouTube videos with MPlayer...
#  - Have fun!
#
# [!] The most important changes are written in the changelog!
#
# [CHANGELOG]
# - Added support for configuration file, improved stability, improved debug mode              - NEW (v2.5.5)
# - Switched to XML::Fast for parsing gdata XML, in consequence, youtube-viewer is faster!     - NEW (v2.5.5)
# - Switched to Getopt::Long, added SIGINT handler and a better way to execute mplayer         - NEW (v2.5.5)
# - Added support to list playlists created by a specific user (usage: -up <USERNAME>)         - NEW (v2.5.4)
# - Improved parsing support for arguments, including arguments specified via STDIN.           - NEW (v2.5.4)
# - Added support to search for videos uploaded by a particular YouTube user (-author=USER)    - NEW (v2.5.4)
# - Added support to get video results starting with a predefined page (ex: -page=4)           - NEW (v2.5.4)
# - Added support for previous page and support to list youtube usernames from a file          - (v2.5.2)
# - Added few options to control cache of MPlayer and lower cache for lower video resolutions  - (v2.5.1)
# - Added colours for text (--use_colors), 360p support (-3), playlist support                 - (v2.5.0)
# - Added support for today and all time Youtube tops (usage: -t, --tops, -a, --all-time)      - (v2.4.*)
# - Re-added the support for the next page / Added support for download (-d, --download)       - (v2.4.*)
# - Added support for Youtube CCaptions. (Depends on: 'gcap' - http://gcap.googlecode.com)     - (v2.4.*)
# - First version with Windows support. Require SMPlayer to play videos. See MPlayer Line      - (v2.4.*)
# - Code has been changed in a proportion of ~60% and optimized for speed // --480 became -4   - (v2.4.*)
# - Added mega-powers of omnibox to the STDIN :)                                               - (v2.3.*)
# - Re-added the option to list and play youtube videos from a user profile. Usage: -u [user]  - (v2.3.*)
# - Added a new option to play only the audio track of a videoclip. Usage: [words] -n          - (v2.3.*)
# - Added option for fullscreen (-f, --fullscreen). Usage: youtube-viewer [words] -f           - (v2.3.*)
# - Added one new option '-c'. It shows available categories and will let you to choose one.   - (v2.3.*)
# - Added one new option '-m'. It shows 3 pages of youtube video results. Usage: [words] -m    - (v2.3.*)
# - For "-A" option has been added 3 pages of youtube video results (50 clips)                 - (v2.3.*)
# - Added "-prefer-ipv4" to the mplayer line (videoclips starts in no time now).               - (v2.3.*)
# - Search and play videos at 480p, 720p. Ex: [words] --480, [words] -A --480                  - (v2.3.*)
# - Added support to play a video at 480p even if it's resolution is higher. Ex: [url] --480   - (v2.2.*)
# - Added a nice feature which prints some informations about the current playing video        - (v2.2.*)
# - Added support to play videos by your order. Example: after search results, insert: 3 5 2 1 - (v2.1.*)
# - Added support for next pages of video results (press <ENTER> after search results)         - (v2.1.*)
# - Added support to continue playing searched videos, usage: "youtube-viewer [words] -A"      - (v2.1.*)
# - Added support to print counted videos and support to insert a number instead of video code - (v2.1.*)
# - Added support to search YouTube Videos in script (ex: youtube-viewer avatar trailer 2009)  - (v2.0.*)
# - Added support for script to choose automat quality if it is lower than 1080p               - (v2.0.*)
# - Added support to choose the quality only between 720p and 1080p (if it is available)       - (v2.0.*)
# - Added support for YouTube video codes (ex: youtube-viewer WVTWCPoUt8w)                     - (v1.0.*)
# - Added support for 720p and 1080p YouTube Videos...                                         - (v1.0.*)

# Special thanks to:
# - Army (for bugs reports and for his great ideas)
# - dhn (for adding youtube-viewer in freshports.org)

eval 'exec perl -S $0 ${1+"$@"}'
  if 0;    # not running under some shell

use strict;
use feature ('switch');
use autouse ('XML::Fast' => 'xml2hash');
use autouse ('URI::Escape' => 'uri_escape');
use File::Spec::Functions qw(path tmpdir curdir rel2abs);

#-----FOR DEBUG ONLY----#
# use warnings;
# use diagnostics -v;
#-----------------------#

my $appname  = 'Youtube Viewer';
my $version  = '2.5.5-git';
my $execname = 'youtube-viewer';

# Configuration dir/file
my $config_dir = (
                  exists $ENV{XDG_CONFIG_HOME}
                  ? $ENV{XDG_CONFIG_HOME}
                  : ($ENV{HOME} // $ENV{LOGDIR} // (getpwuid($<))[7] // `echo -n ~`) . '/.config'
                 ) . "/$execname";

my $config_file = "$config_dir/$execname.conf";
my $noconfig    = grep { /^-+(?:W|noconfig)$/ } @ARGV;
my $debug_mode  = grep { /^-+debug$/ } @ARGV;

# Unchangeable variables goes here
my %constant = (
                'win32' => $^O eq 'MSWin32' ? 1 : 0,
                'dash_line' => '-' x 80
               );

# Set $PATH to @path
my @path = path;

# Locating gcap
my $gcap;
foreach my $path (@path, @INC) {
    if (-e "$path/gcap") {
        $gcap = "$path/gcap";
        last;
    }
}

# Get mplayer line
sub get_mplayer {
    if ($constant{'win32'}) {
        my $smplayer = $ENV{'ProgramFiles'} . '\\SMPlayer\\mplayer\\mplayer.exe';
        if (-e $smplayer) {
            return $smplayer;    # Windows MPlayer
        }
        else {
            warn "\n\n!!! Install SMPlayer in order to stream YouTube videos.\n\n";
            return $smplayer;
        }
    }
    else {
        return 'mplayer'         # *NIX MPlayer
    }
}

# Main configuration
my %CONFIG = (

    # MPlayer options
    'cache'                => 30000,
    'cache_min'            => 5,
    'lower_cache'          => 1000,
    'lower_cache_min'      => 3,
    'mplayer'              => get_mplayer(),
    'mplayer_srt_settings' => '-unicode -utf8',
    'mplayer_arguments'    => '-prefer-ipv4 -really-quiet -cache %d -cache-min %d',

    # Youtube options
    'results'          => 20,
    'resolution'       => 1080,
    'region'           => undef,
    'query_parameters' => undef,
    'time_sort'        => 'all_time',
    'order_by'         => 'relevance',

    # URI options
    'youtube_video_url'     => 'http://www.youtube.com/watch?v=%s',
    'gdata_feeds_main_url'  => 'http://gdata.youtube.com/feeds/api',
    'get_video_info'        => 'http://www.youtube.com/get_video_info',
    'newsubscriptionvideos' => 'http://gdata.youtube.com/feeds/api/users/%s/newsubscriptionvideos',

    # Subtitle options
    'srt_language' => 'en',
    'tmp_dir'      => tmpdir(),
    'gcap'         => $gcap,

    # Others
    'use_colors'         => 0,
    'lwp_downloading'    => 0,
    'fullscreen'         => 0,
    'use_lower_cache'    => 0,
    'perl_bin'           => $^X,
    'thousand_separator' => q{,},
    'downloads_folder'   => curdir(),
    'editor'             => $ENV{'EDITOR'} // 'nano',
    'users_list'         => "$config_dir/youtube_users.txt",
);

my $stdin_help = <<'STDIN_HELP';

all             : play all results in order
next            : go to the next page
back            : go to the previous page
login           : will prompt you for login
logout          : will delete the authentication key
[keywords]      : search for youtube videos
[int number]    : play the corresponding video
3-8, 3..8       : same as 3 4 5 6 7 8
8 2 12 4 6 5 1  : play videos in your order
-argv -argv2=v  : set some arguments
e, edit-config  : edit and apply configuration
load-config     : (re)load configuration file
/my?[regex]*$/  : play videos matched by a regex (/i)
reset, reload   : restart application
q, quit, exit   : quit
STDIN_HELP

my %MPLAYER;

# MPlayer variable arguments
sub set_mplayer_arguments {
    my ($cache, $cache_min) = @_;
    $MPLAYER{mplayer_arguments} = sprintf $CONFIG{mplayer_arguments}, $cache, $cache_min;
    $MPLAYER{fullscreen} = $CONFIG{fullscreen} ? '-fs' : '';
    return 1;
}

# Save hash config to file
sub write_config_to_file {
    Config::save_hash($config_file, \%CONFIG);
    return 1;
}

# Creating config unless it exists
unless (-e $config_file) {
    require File::Path;
    File::Path::make_path($config_dir);
    write_config_to_file();
}

# itag => resolution
my %itags = (
             37 => 1080,
             22 => 720,
             35 => 480,
             43 => 210,
             34 => 360,
             5  => 240
            );

# For YouTube
my $key = 'AI39si5xZtotT-ABtXEHNYpPnfez4T9hfNTkMlWti5gVCbFOZ-wyw70RTTguH_53klpmj3G98sTJGXJF5YY61Zcu1r5XmR2w3Q';
my %lwp_header = ('X-GData-Key' => "key=$key");

#----------------------- ASCII COLOURS -----------------------#
my $bred    = q{};
my $bgreen  = q{};
my $reset   = q{};
my $cblack  = "\e[40m";      # background black
my $byellow = "\e[1;33m";    # bold yellow
my $bpurle  = "\e[1;35m";    # bold purple
my $bblue   = "\e[1;34m";    # bold blue

unless ($constant{'win32'}) {    # if not running under Windows
    $bred   = "\e[1;31m";        # set bold red
    $bgreen = "\e[1;32m";        # set bold green
    $reset  = "\e[0m";           # set reset color
}

#---------------------- GLOBAL VARIABLES ----------------------#
my $keywords = q{};              # used to store keywords for search
my $youtube_gdata_url;           # used to store the gdata URL with API query parameters
my $start_with_page = 1;

# Other global variables
my ($start_index, $download_video, $from_author, $playback, $sleep, @picks, @results, %streaming);

#------------------------ REGEXP AREA ------------------------#
my $contains_arguments   = qr/(?:\s|^)-+\w/;
my $match_regexp         = qr{/((?:\\.|[^\\/])*)/};
my $valid_playlist_code  = qr/^(?:PL)?([0-9A-Z]{16})$/;
my $get_youtube_code     = qr{\b(?:v|embed|youtu[.]be)(?:[=/]|%3D)([\w\-]{11})};
my $looks_like_gdata_url = qr{^https?://gdata[.]youtube[.]com/feeds/};

# $1 will be the playlist code
my $get_playlist_code = qr{(?:(?:(?:playlist[?]list|view_play_list[?]p)=)|\w#p/c/)(?:PL)?([A-Z0-9]{16})};

# $1 will be the Youtube username
my $get_username = qr{^https?://(?:www[.])?youtube[.]com/(?:user/)?(\w{2,})(?:[?].*)?$};

# The bellow regex will validate an HTTP url.
# If it is valid, we will try to get an youtube
# video code from that website using /$get_youtube_code/
my $valid_url = qr{^
        ################# This regex will validate an HTTP URL #################

                https?://                # http or https followed by ://
                [[:alnum:]]              # first character must be a-zA-Z0-9
                (?:(?:(?:\w*-+\w+|\w+)*  # words, dash, words OR only words
                \.(?=\w))+?              # point if followed by word char
                |                        # OR (validates http://x.yz)
                \.)                      # a single dot
                \w{2,6}                  # domain (words between 2 and 6 chars)
                (?:[#/?!]                # characters after domain
                [#-)+-;=?\\~\w]*)*       # the rest of characters of the string
$}x;

#---------------------- TEMPORARY OPTIONS ----------------------#
my $dont_exit;        #               \/
my $playlists;        # DON'T change this default values
my $lwp_is_set;       # unless you know what you're doing
my $video_results;    #               /\

#---------------------- LOOKING FOR WGET ----------------------#
my $wget_is_available;

sub locate_wget {
    if (-x '/usr/bin/wget'
        or grep { $constant{'win32'} ? -e "$_\\wget" : -x "$_/wget" } @path) {
        $wget_is_available = 1;
    }
    else {
        $wget_is_available = 0;
    }
}

#---------------------- LWP::UserAgent ----------------------#
my $lwp;

sub set_lwp_useragent {
    require LWP::UserAgent;
    $lwp = 'LWP::UserAgent'->new(
                                 'keep_alive' => 1,
                                 'env_proxy'  => 1,
                                 'timeout'    => 30
                                );
    $lwp->agent('Mozilla/5.0 (X11; U; Linux i686; en-US) Chrome/10.0.648.45');
    $lwp->show_progress(1) if $debug_mode;
    binmode *STDOUT, ":encoding(utf8)";
    $lwp_is_set = 1;
}

sub lwp_get {
    set_lwp_useragent() unless $lwp_is_set;
    return $lwp->get($_[0], %lwp_header)->content;
}

# True if looks like a YouTube code
sub is_code {
    length $_[0] == 11
      and $_[0]     =~ /^[\w\-]{11}$/
      and $_[0]     =~ /[\d[:upper:]_\-]/
      and not $_[0] =~ /^-+[a-z]+$/;
}

# Set config file to %CONFIG
sub apply_configuration {
    my $config_ref = do $config_file;
    if (ref $config_ref eq 'HASH') {
        while (my ($key, $value) = each %$config_ref) {
            $CONFIG{$key} = $value;
        }
    }
    else {
        warn "\n[!] Configuration file contains some errors!\n",
          "[*] Configuration file was automatically regenerated!\n",
          "[!] Be more careful next time!\n";
        write_config_to_file();
    }

    # Auto-login
    if (exists $CONFIG{auth}) {
        set_auth_key($CONFIG{auth});
    }
}

apply_configuration() unless $noconfig;

# Convert args (of length of 11) to Youtube URLs
my @argv;
foreach my $arg (@ARGV) {
    if (is_code($arg)) {
        push @argv, sprintf($CONFIG{youtube_video_url}, $arg);
    }
    else {
        push @argv, $arg;
    }
}
@ARGV = @argv;

# Exit unless there are more videos selected to play
$SIG{'INT'} = sub {
    @picks > 1
      ? do {
        @picks    = ();
        $playback = 0;
      }
      : do { print "\n"; main_quit() };
};

# __DIE__ handle
$SIG{__DIE__} = sub {
    if (join('', @_) =~ m{^Can't locate (.+?)\.pm\b}) {
        my $module = $1;
        $module =~ s{[/\\]+}{::}g;
        die "\nModule $module is required!\n\nTo install the module, just type in terminal:\n\tsudo cpan $module\n";
    }
    return 1;
};

# SIG handlers
foreach my $sig (qw(HUP TERM KILL)) {
    $SIG{$sig} = \&main_quit;
}

my $get_opt_required = 0;

sub require_getopt_long {
    require Getopt::Long;
    Getopt::Long::Configure('no_ignore_case');
    $get_opt_required = 1;
}

# Parsing arguments
if (@ARGV) {
    parse_arguments(@ARGV);
}

# Return value for start_index
sub get_start_index {
    return $CONFIG{results} * $start_with_page - $CONFIG{results} + 1;
}

# Returns a list of arguments (from string ref)
sub get_arguments_from_string {
    return grep { chr ord $_ eq q{-} }
      split(/\s+/, ${$_[0]});
}

# Returns a list of keywords (from string ref)
sub get_keywords_from_string {
    return grep { chr ord $_ ne q{-} }
      split(/\s+/, ${$_[0]});
}

# Returns a list of keywords (from array ref)
sub get_keywords_from_array {
    return grep { chr ord $_ ne q{-} } @{$_[0]};
}

my @goto;

sub parse_arguments {
    require_getopt_long() unless $get_opt_required;
    Getopt::Long::GetOptionsFromArray(
        \@_, \%CONFIG,

        # Main options
        'help|usage|h|?' => \&help,
        'tricks|tips|T'  => \&tricks,
        'version|V|v'    => \&version,

        # Resolutions
        '240p|2'  => sub { $CONFIG{'resolution'} = 240 },
        '360p|3'  => sub { $CONFIG{'resolution'} = 360 },
        '480p|4'  => sub { $CONFIG{'resolution'} = 480 },
        '720p|7'  => sub { $CONFIG{'resolution'} = 720 },
        '1080p|1' => sub { $CONFIG{'resolution'} = 1080 },

        # Other options
        'categories|c'        => sub { push @goto, {categories_area         => undef} },
        'movies|M'            => sub { push @goto, {youtube_movies          => undef} },
        'today|t'             => sub { push @goto, {youtube_tops            => undef} },
        'a|all-time'          => sub { push @goto, {youtube_tops            => 'all_time'} },
        'subscriptions|N:s'   => sub { push @goto, {get_new_subsc           => length $_[1] ? pop() : 'default'} },
        'login'               => sub { push @goto, {authenticate            => undef} },
        'user|u=s'            => sub { push @goto, {videos_from_username    => pop()} },
        'user-playlists|up=s' => sub { push @goto, {playlists_from_username => pop()} },
        'users|U:s'           => sub { push @goto, {list_user_names         => length $_[1] ? pop() : $CONFIG{users_list}} },

        'author=s'         => \$from_author,
        'sleep|S!'         => \$sleep,
        'all|A!'           => \$playback,
        'noconfig|W!'      => \$noconfig,
        'playlists|p!'     => \$playlists,
        'debug!'           => \$debug_mode,
        'download|d!'      => \$download_video,
        'cache-min=i'      => \$CONFIG{cache_min},
        'colors|C!'        => \$CONFIG{use_colors},
        'sub|lang=s'       => \$CONFIG{srt_language},
        'fs|f!'            => \$CONFIG{fullscreen},
        'download-dir=s'   => \$CONFIG{downloads_folder},
        'l|lower-cache!'   => \$CONFIG{use_lower_cache},
        'query-params|Q=s' => \$CONFIG{query_parameters},
        'lwp-download|L!'  => \$CONFIG{lwp_downloading},
        'order-by=s'       => \$CONFIG{order_by},
        'time=s'           => \$CONFIG{time_sort},

        'page=i'     => sub { $start_with_page  = pop() },
        'novideo|n!' => sub { $MPLAYER{novideo} = '-novideo' },
        'more|m'     => sub {
            warn "-more option is deprecated! Use '-results=50' instead\n";
            $CONFIG{results} = 50;
        },

        'quiet|q!' => sub {
            close *STDOUT;
            close *STDERR;
        },

        map { defined $CONFIG{$_} && $CONFIG{$_} =~ /^[10]$/ ? "$_!" : "$_=s" } keys %CONFIG
                                     );
    $keywords = join(q{ }, get_keywords_from_array(\@_)) if @_;

    # Start with page N
    $start_index = get_start_index();

    # Dump config
    if ($debug_mode) {
        print "=>> CONFIG:\n", Config::_dump(\%CONFIG);
    }

    # Go to selected subroutines
    if (@goto) {
        no strict 'refs';
        while (@goto) {
            my $goto = shift @goto;
            while (my ($sub, $arg) = each %$goto) {
                &$sub($arg);
            }
        }
    }
}

$start_index ||= get_start_index() || 1;

#---------------------- PARSING VIDEO CODES SPECIFIED AS ARGUMENTS ----------------------#
foreach my $code (@ARGV) {
    given ($code) {
        when (/$get_playlist_code/o) {
            list_playlist($1);
        }
        when (/$valid_playlist_code/o) {
            list_playlist($1);
        }
        when (/$get_youtube_code/o) {
            $dont_exit = 1;
            get_youtube($1);
        }
        when (/$get_username/o) {
            videos_from_username($1);
        }
        when (m{^https?://} and /$valid_url/o) {
            code_from_content($_);
        }
    }
}

sub quit_required {
    $_[0]      eq 'q'
      or $_[0] eq 'quit'
      or $_[0] eq 'exit';
}

#---------------------- GO TO insert_url() IF $non_argv is FALSE ----------------------#
sub insert_url {
    {
        print "\n$bred=>>$bgreen Insert an YouTube URL or search something...$reset\n> ";

        given (<STDIN>) {
            chomp;
            when (\&check_user_input) {
                redo;
            }
            when ($_ eq q{}) {
                warn "\n$bred(x_x) Unable to continue...$reset\n\n";
                main_quit();
            }
            default {
                $playlists ? do { $keywords = $_; search_playlists() } : search($_);
            }
        }
    }
}
insert_url() unless length $keywords;

#---------------------- GET A VIDEO CODE FROM AN WEBSITE CONTENT ----------------------#
sub code_from_content {
    set_lwp_useragent() unless $lwp_is_set;

    if ($lwp->get($_[0])->content =~ /$get_youtube_code/o) {
        get_youtube($1);
    }
    else {
        search($_[0]);
    }
}

#---------------------- YOUTUBE-VIEWER USAGE ----------------------#
sub help {
    print "\n  " . q{=} x 30 . " \U$appname\E " . q{=} x 30 . "
\t\t\t\t\t\t by Trizen (trizenx\@gmail.com)
\nUsage: $execname [options] ([code] || [url] || [keywords])
\nBase Options:
   <url>                : play an YouTube video by URL
   <code>               : play an YouTube video by code
   <keywords>           : search and list YouTube videos
   <playlist_url>       : list a playlist of YouTube videos
\nYouTube options:
   -t, --today          : shows today YouTube tops
   -a, --all-time       : shows all time YouTube tops
   -c, --categories     : shows available YouTube categories
   -p, --playlists      : search for YouTube playlists
   -M, --movies         : show YouTube movies categories
   --results=[1-50]     : how many videos to display per page
   --region=<ID>        : set a specific regionID (ex: US)
   -u  <username>       : list videos uploaded by a specific user
   -up <username>       : list playlists created by a specific user
   -author='USERNAME'   : search videos uploaded by a particular user
   -order-by='ORDER'    : order entries by: published, viewCount or rating
   -time='TIME'         : valid values are: today, this_week and this_month
   -page='PAGE_NR'      : show video results starting with PAGE_NR (ex: 2)
   -2, -3, -4, -7, -1   : plays videos at 240p, 360p, 480p, 720p or 1080p
\nMPlayer options:
   -f, --fullscreen     : plays video(s) in fullscreen mode
   -n, --novideo        : plays only the audio track of video(s)
   -l, --lower-cache    : set a lower cache for MPlayer (for slow connections)
   -mplayer=<>          : set a media player (default: $CONFIG{mplayer})
   -sub='LANG'          : subtitle language (default: en) (depends on gcap)
   -cache='VALUE'       : set cache for MPlayer (default: $CONFIG{cache})
   -cache-min='VALUE'   : set cache-min for MPlayer (default: $CONFIG{cache_min})
\nOther options:
   -A, --all            : plays all video results in order
   -C, --colors         : use colors for text output
   -d, --download       : downloads YouTube video(s) with LWP
   -N, --subscriptions  : show new subscription videos (requires authentication)
   -S, --sleep          : sleep 1 sec when playling more videos
   -U, --users=file.txt : list YouTube usernames from a file
   -L, --lwp-download   : download videos with LWP (default: wget)
   -T, --tricks         : show more 'hidden' features of $appname
   -W, --noconfig       : don't apply config values, start with default values
   -Q, --query-params   : set query parameters (ex: '&duration=long&caption')
   -login               : prompt for login
   -download-dir        : downloads directory (default: '$CONFIG{downloads_folder}')
\nMain options:
   -q, --quiet          : display no output
   -v, --version        : prints version and exits
   -h, --help           : prints help and exits

*  -no-[argv] will negate the value of argument (ex: -no-fullscreen)
** each config key is a valid argument (if is preceded by a dash (-))

Tips and tricks:
  1. After search results, press <ENTER> for the next page
  2. After search results, insert 'back' for the previous page
  3. View more 'hidden' features by executing '$execname -T'\n\n";
    main_quit();
}

#---------------------- YOUTUBE-VIEWER TIPS AND TRICKS ----------------------#
sub tricks {
    print "
                        $bred>>$bgreen Tips and tricks $bred<<$reset
\n$bred*$bgreen STDIN arguments:$reset
$stdin_help
\n$bred*$bgreen Did you know that...?$reset
    -A option will play ALL video results, including videos from the next pages;\n
    $appname prints to STDOUT the current playing YouTube URL;\n
    /REGEXP/ will match case-insensitive (e.g.: 'test' matches 'TeSt');\n
    When multiple videos are selected to play, pressing CTRL+C
        will just empty the playlist and return to video results.
\n$bred*$bgreen Configuration file$reset
    Since 2.5.5 version, $appname supports a configuration file.
    Config file is: '$config_file'
\n$bred*$bgreen Usage examples:$reset
 ** Show videos uploaded by 'MIT' that matches 'computer science',
    starting with page number 2, in fullscreen mode and 720p resolution.
    % $execname --author=MIT computer science --page=2 -fs --720p\n
 ** Show playlists created by a specific user
    % $execname -up khanacademy\n
 ** Show latest videos (50) uploaded by a specific user and a colourful output
    % $execname -results=50 -u google -C\n\n";
    main_quit();
}

# Print version
sub version {
    print "Youtube Viewer $version\n";
    main_quit();
}

# ------------------ Authentication ------------------ #

sub set_auth_key {
    my ($auth) = @_;
    $lwp_header{'Authorization'} = "GoogleLogin auth=$auth";
}

sub log_out {
    delete $lwp_header{Authorization};
}

sub authenticate {
    my ($email, $password);
    $email = defined $CONFIG{email} ? $CONFIG{email} : do {
        print "\n=>> Email: ";
        substr(<STDIN>, 0, -1);
    };
    if (defined $CONFIG{password}) {
        $password = $CONFIG{password};
    }
    else {
        if ($constant{win32}) {
            eval { require Term::ReadKey };
            if ($@) {
                print "[!] Please install Term::ReadKey if you don't want your password to be visible while typing!\n";
                print "=>> Password: ";
                chomp($password = <STDIN>);
            }
            else {
                my $key = 0;
                print "=>> Password: ";
                Term::ReadKey::ReadMode(4);
                while (ord($key = Term::ReadKey::ReadKey(0)) != 10) {
                    given (ord $key) {
                        when ([127, 8]) {
                            chop($password);
                            print "\b \b";
                        }
                        when ($_ >= 32) {
                            $password = $password . $_;
                        }
                    }
                }
                Term::ReadKey::ReadMode(0);
            }
        }
        else {
            print "=>> Password: ";
            system('stty', '-echo');
            chomp($password = <STDIN>);
            system('stty', 'echo');
        }
    }

    print "\n\n** Should I remember of you next time? :)
-> if 'yes', your authentication key will be saved to configuration\n
=>> Your answer (y/N): ";
    my $remember_me = <STDIN> =~ /^y/i ? 1 : 0;

    set_lwp_useragent() unless $lwp_is_set;
    my $resp = $lwp->post(
                          "https://www.google.com/accounts/ClientLogin",
                          [Content => 'application/x-www-form-urlencoded',
                           Email   => $email,
                           Passwd  => $password,
                           service => 'youtube',
                           source  => "$appname $version"
                          ]
                         );

    if ($resp->{_content} =~ /^Auth=(.+)/m) {
        my $auth = $1;
        $CONFIG{email} = $email;
        if ($remember_me) {
            $CONFIG{auth} = $auth;
        }
        print "\n[*] Logged!\n";
        set_auth_key($auth);
    }
    else {
        die "\nUnable to login: $resp->{_content}\n";
    }
}

sub get_new_subsc {
    my ($user) = @_;
    unless ($lwp_header{Authorization}) {
        print "[!] New subscription videos requires authentication!\n";
        authenticate();
    }
    parse_url(sprintf $CONFIG{newsubscriptionvideos}, $user);
}

#---------------------- LIST YOUTUBE USERNAMES FROM A FILE ----------------------#
sub list_user_names {

    my ($users_file) = @_;
    return unless -f $users_file;

    my $i = 0;
    my %usernames_table;
    print "\n";

    open my $fh, '<:crlf', $users_file or die $!;
    while (defined(my $username = <$fh>)) {
        next unless $username =~ /^\w+$/;
        chomp $username;
        ++$i;
        print do {
            q{ } if $i < 10;
        }, "$bred$i$reset - $bgreen$username$reset\n";
        $usernames_table{$i} = $username;
    }
    close $fh;
    {
        print "\n$bred=>$bgreen Pick an username number$reset\n> ";
        given (<STDIN>) {
            chomp;
            when (\&check_user_input) {
                redo;
            }
            when (exists $usernames_table{$_}) {
                videos_from_username($usernames_table{$_});
            }
            when (/^\w+$/) {
                videos_from_username($_);
            }
            when (/$match_regexp/o) {
                my $match = qr/$1/i;
                my ($found, @found) = 0;
                print "\n";
                while (my ($number, $username) = each %usernames_table) {
                    if ($username =~ /$match/o) {
                        print $bred, do {
                            q{ }
                              if ++$found < 10;
                        }, "$found$reset - $bgreen$username$reset\n";
                        push(@found, $found);
                        $usernames_table{$found} = $username;
                    }
                }
                if (@found > 1) {
                    print "\n$bred=>>$bgreen Pick an username number$reset\n> ";
                    given (<STDIN>) {
                        chomp;
                        when (\&quit_required or $_ eq q{}) {
                            main_quit();
                        }
                        when (exists $usernames_table{$_}) {
                            videos_from_username($usernames_table{$_});
                        }
                        default {
                            insert_url();
                        }
                    }
                }
                elsif (@found) {
                    videos_from_username($usernames_table{$found[0]});
                }
                continue;
            }
            default {
                insert_url();
            }
        }
    }
}

#---------------------- GET VIDEOS FROM A SPECIFIC USER ----------------------#
sub videos_from_username {
    parse_url("$CONFIG{gdata_feeds_main_url}/users/$_[0]/uploads");
}

#---------------------- PRINT PLAYLISTS ----------------------#
sub print_playlists {
    my ($playlist, $num) = @_;

    # Number, Title, Author, VideosCount
    $CONFIG{use_colors}
      ? print($cblack, $bred, do { ' ' if $num < 10 }, $num, $reset,
              $cblack, q{ - },  $byellow, $playlist->{title}, $reset,
              $cblack, ' (',    $bpurle,  'by ',              $playlist->{author},
              $reset,  $cblack, ') (',    $bblue,             $playlist->{count},
              $reset,  $cblack, ')',      $reset,             "\n"
             )
      : print($bred, do { ' ' if $num < 10 }, $num, $reset, ' - ', $playlist->{title},
              ' (by ', $playlist->{author}, ') (', $playlist->{count}, ")\n"
             );
}

#---------------------- GET PLAYLISTS FROM A SPECIFIC USER ----------------------#
my $playlist_index;

sub playlists_from_username {
    my ($username) = @_;
    search_playlists(
                     $CONFIG{gdata_feeds_main_url}
                       . "/users/"
                       . $username
                       . "/playlists?max-results="
                       . $CONFIG{results}
                       . "&start-index="
                       . $start_index . "&v=2",
                     'username'
                    );
}

sub search_playlists {
    return unless @_;
    my ($arg, $mode) = @_;
    $youtube_gdata_url =
        $arg =~ /$looks_like_gdata_url/o
      ? $arg
      : $CONFIG{gdata_feeds_main_url}
      . "/playlists/snippets?q="
      . $arg
      . "&start-index="
      . $start_index
      . "&max-results="
      . $CONFIG{results} . "&v=2";

    $playlists = 1;
    parse_content($youtube_gdata_url);

    my $i = 0;
    foreach my $playlist (@results) {
        print_playlists($playlist, ++$i);
    }
    playlists_waiting_input($mode);
}

#---------------------- SEARCH FOR YOUTUBE PLAYLISTS ----------------------#
sub playlists_waiting_input {

    my ($mode) = @_;
    {
        if (defined $mode and $mode eq 'playlists') {
            print "\n$bred=>>$bgreen Pick one playlist or search others$reset\n> ";
        }
        else {
            print "\n$bred=>$bgreen Pick one playlist or insert another username$reset\n> ";
        }

        given (<STDIN>) {
            chomp;
            when (\&check_user_input) {
                redo;
            }
            when (/^\s*$/ or $_ eq 'next') {
                next_page($mode);
            }
            when ('back') {
                if (
                    do {
                        $youtube_gdata_url =~ /[&?]start-index=(\d+)/;
                        $1 > $CONFIG{results};
                    }
                  ) {
                    previous_page($mode);
                }
                else {
                    continue;
                }
            }
            when (/^\d+$/) {
                list_playlist($results[$_ - 1]->{'playlistID'});
            }
            default {
                if ($mode eq 'playlists') {
                    search($_);
                }
                elsif ($mode eq 'username') {
                    playlists_from_username($_);
                }
                else {
                    die "Unknown error!\n";
                }
            }
        }
    }
}

#---------------------- LIST A YOUTUBE PLAYLIST ----------------------#
sub list_playlist {
    $playlists = 0;
    parse_url("$CONFIG{gdata_feeds_main_url}/playlists/$_[0]");
}

#---------------------- LIST YOUTUBE MOVIE CATEGORIES ----------------------#
sub youtube_movies {
    print "\n";
    my $i = 0;
    my %movie_table;
    foreach my $movie_cat_name ('most_popular', 'most_recent', 'trending') {
        my $cat_name = ucfirst $movie_cat_name;
        $cat_name =~ tr/_/ /;
        print q{ }, $bred, ++$i, "$reset - $cat_name\n";
        $movie_table{$i} = $movie_cat_name;
    }
    {
        print "\n$bred=>>$bgreen Pick one category$reset\n> ";
        given (<STDIN>) {
            chomp;
            when (\&check_user_input) {
                redo;
            }
            when (exists $movie_table{$_}) {
                parse_url("$CONFIG{gdata_feeds_main_url}/charts/movies/$movie_table{$_}");
            }
        }
    }
}

#---------------------- LIST YOUTUBE TOP VIDEO CATEGORIES ----------------------#
sub youtube_tops {
    my $i             = 0;
    my $today         = $_[0] && $_[0] eq 'all_time' ? 0 : 1;
    my $standardfeeds = "$CONFIG{gdata_feeds_main_url}/standardfeeds";
    my %tops_table;
    print "\n";
    foreach my $cat_top_name (
                              'top_rated',   'top_favorites',  'most_viewed',    'most_popular',
                              'most_recent', 'most_discussed', 'most_responded', 'recently_featured'
      ) {
        my $top_name = ucfirst $cat_top_name;
        $top_name =~ tr/_/ /;
        print q{ }, $bred, ++$i, "$reset - $top_name\n";
        $tops_table{$i} = $cat_top_name;
    }
    {
        print "\n$bred=>>$bgreen Pick one category$reset\n> ";

        given (<STDIN>) {
            chomp;
            when (\&check_user_input) {
                redo;
            }
            when (exists $tops_table{$_}) {
                my $url = $standardfeeds . q{/} . $tops_table{$_};
                if ($today
                    and not $url =~ /recent/) {
                    $url .= '?time=today';
                }
                parse_url($url);
            }
            default {
                insert_url();
            }
        }
    }
}

#---------------------- LIST YOUTUBE VIDEO CATEGORIES ----------------------#
sub categories_area {
    my $n = 0;
    my %categories_table;
    print "\n";
    foreach my $line (split /<atom:category term=/, lwp_get('http://gdata.youtube.com/schemas/2007/categories.cat')) {
        if (not $line =~ /deprecated/
            and $line =~ /^'(.+?)'\s+label='(.+?)'/) {
            ++$n;
            my $cat_name  = $1;
            my $cat_label = $2;
            $cat_label =~ s/&amp;/&/;
            print do {
                q{ }
                  if $n < 10;
            }, $bred, $n, $reset, ' - ', $cat_label, "\n";
            $categories_table{$n} = $cat_name;
        }
    }
    {
        print "\n$bred=>>$bgreen Insert a category number$reset\n> ";
        given (<STDIN>) {
            chomp;
            when (\&check_user_input) {
                redo;
            }
            when (exists $categories_table{$_}) {
                parse_url("$CONFIG{gdata_feeds_main_url}/videos?category=$categories_table{$_}");
            }
            default {
                insert_url();
            }
        }
    }
}

sub check_mplayer_arguments {
    if ($CONFIG{use_lower_cache} or not exists $streaming{720} or $CONFIG{resolution} < 720) {
        set_mplayer_arguments($CONFIG{lower_cache}, $CONFIG{lower_cache_min});
    }
    else {
        set_mplayer_arguments($CONFIG{cache}, $CONFIG{cache_min});
    }
}

#---------------------- PLAY OR DOWNLOAD AN YOUTUBE VIDEO ----------------------#
sub play_or_download {
    my $streaming = shift;

    print "** STREAMING: $streaming\n\n" if $debug_mode;

    ## DOWNLOADING
    if ($download_video) {
        my $title = shift @_;

        if (defined $CONFIG{downloads_folder}) {
            chdir $CONFIG{downloads_folder};
        }

        if (not defined $wget_is_available and not $CONFIG{lwp_downloading}) {
            locate_wget();
        }

        # Replacing reserved characters with a space
        $title =~ tr{\\/:*?"< >|}{ }s;
        if (not -e "$title.mp4") {
            if ($wget_is_available) {

                # Downloading video with wget
                system 'wget', '-nc', $streaming, '-O', "$title.mp4";
            }
            else {

                # Downloading video with LWP
                print "** Saving to: '$title.mp4'\n";
                $lwp->show_progress(1);
                $lwp->mirror($streaming, "$title.mp4");
                $lwp->show_progress(0);
            }
        }
        else {
            warn "** '$title.mp4' already exists...\n";
        }
    }

    ## STREAMING
    else {

        # Update mplayer's arguments
        check_mplayer_arguments();

        my @mplayer_line = split(' ', join(' ', $CONFIG{mplayer}, values %MPLAYER));

        if ($debug_mode) {
            print "** MPlayer Line: @mplayer_line\n\n";
        }
        else {
            system @mplayer_line, $streaming;
        }

        # Change directory back to the main working directory
        chdir $constant{'cwd'}
          if exists $constant{'cwd'};
        delete $constant{'cwd'};
    }

    print "\n";
    if (@picks) {
        if ($playback or $sleep) {
            print "${bred}[*]$bgreen Press CTRL+C to return to video results!$reset\n\n";
            sleep 1;    # enough time to press CTRL+C
        }
        foreach_pick();    # play the next video
    }
    elsif ($playback) {
        next_page();
    }
    if ($video_results
        and not $dont_exit) {
        print_results();    # back to video results
    }
    main_quit() unless $dont_exit;
    return 1;
}

#---------------------- SEARCH YOUTUBE VIDEOS ----------------------#
if (length($keywords)) {
    search() unless $dont_exit;
}

sub search {
    $keywords = shift() // $keywords;

    # Get words which doesn't begins with a dash (-);
    $keywords = join(q{ }, get_keywords_from_string(\$keywords));
    $keywords = uri_escape($keywords);

    if ($playlists) {
        search_playlists($keywords, 'playlists');
        return;
    }

    $youtube_gdata_url =
        $CONFIG{gdata_feeds_main_url}
      . '/videos?q='
      . $keywords
      . '&max-results='
      . $CONFIG{results}
      . '&time='
      . $CONFIG{time_sort}
      . '&orderby='
      . $CONFIG{order_by}
      . '&start-index='
      . $start_index . '&v=2';
    if (defined $from_author) {
        $youtube_gdata_url .= '&author=' . $from_author;
    }
    if (defined $CONFIG{region}) {
        $youtube_gdata_url .= '&region=' . $CONFIG{region};
    }
    if (defined $CONFIG{query_parameters}) {
        unless ($CONFIG{query_parameters} =~ /^&/) {
            substr($CONFIG{query_parameters}, 0, 0, '&');
        }
        $youtube_gdata_url .= $CONFIG{query_parameters};
    }
    parse_content($youtube_gdata_url);
    print_results();
}

#---------------------- PREPARE GDATA FEEDS URL ----------------------#
sub parse_url {
    ($youtube_gdata_url) = @_;
    $youtube_gdata_url .= $youtube_gdata_url =~ /[?]/ ? '&' : '?';
    $youtube_gdata_url .= "start-index=$start_index&max-results=$CONFIG{results}&v=2";
    if (defined $CONFIG{region}) {
        $youtube_gdata_url .= '&region=' . $CONFIG{region};
    }
    parse_content($youtube_gdata_url);
    print_results();
}

#---------------------- GET AND PARSE GDATA CONTENT ----------------------#
sub parse_content {

    undef @results;
    my $number = 0;
    my $hash;

    eval { $hash = xml2hash(lwp_get($_[0])) };

    if ($@) {
        if ($@ =~ /Module \S+ is required!/) {
            warn $@;
            main_quit();
        }
        else {
            warn "Error ocurred while parsing $_[0]\n$@\n";
            parse_content($_[0]);
        }
    }

    if ($playlists) {
        while (
               my $gdata =
                 ref $hash->{'feed'}{'entry'} eq 'ARRAY' ? $hash->{'feed'}{'entry'}[$number]
               : ref $hash->{'feed'}{'entry'} eq 'HASH'  ? $hash->{'feed'}{'entry'}
               : $hash->{'entry'}
          ) {
            last unless defined $gdata;

            # PlaylistID, Title, Author, VideosCount
            push @results,
              {
                'playlistID' => $gdata->{'yt:playlistId'},
                'title'      => $gdata->{'title'},
                'author'     => $gdata->{'author'}{'name'},
                'count'      => $gdata->{'yt:countHint'}
              };
            ++$number;
            last unless ref $hash->{'feed'}{'entry'} eq 'ARRAY';
        }
    }
    else {
        while (
               my $gdata =
                 ref $hash->{'feed'}{'entry'} eq 'ARRAY' ? $hash->{'feed'}{'entry'}[$number]
               : ref $hash->{'feed'}{'entry'} eq 'HASH'  ? $hash->{'feed'}{'entry'}
               : $hash->{'entry'}
          ) {
            last unless defined $gdata;

            # VideoID, Title, Author, Duration, Views, Date, CategoryLabel, Description
            push @results,
              {
                'code'        => $gdata->{'media:group'}{'yt:videoid'},
                'title'       => $gdata->{'media:group'}{'media:title'}{'#text'},
                'author'      => $gdata->{'author'}{'name'},
                'favorited'   => $gdata->{'yt:statistics'}{'-favoriteCount'},
                'duration'    => format_time(\$gdata->{'media:group'}{'yt:duration'}{'-seconds'}),
                'views'       => $gdata->{'yt:statistics'}{'-viewCount'} || 0,
                'published'   => $gdata->{'published'} // 0,
                'category'    => $gdata->{'category'}[1]{'-label'},
                'description' => $gdata->{'media:group'}{'media:description'}{'#text'}
              };
            ++$number;

            last unless ref $hash->{'feed'}{'entry'} eq 'ARRAY';
        }
    }
    if ($debug_mode) {
        open my $fh, '>', "$execname.debug" or die "Unable to open $execname.debug: $!\n";
        print {$fh} "=>> URL:\n", $_[0], "\n=>> HASH:\n", Config::_dump($hash), "\n=>> Results:\n", Config::_dump(\@results);
        close $fh;
    }
    print "\n";
}

# Format seconds to HH:MM:SS
sub format_time {
    my $tmp_time;
    do {
        $tmp_time = ${$_[0]} / 3600 % 24;
        $tmp_time > 0
          ? $tmp_time > 9
              ? "$tmp_time:"
              : "0$tmp_time:"
          : q{};
      }
      . do {
        $tmp_time = ${$_[0]} / 60 % 60;
        $tmp_time > 9 ? $tmp_time : "0$tmp_time";
      }
      . q{:} 
      . do {
        $tmp_time = ${$_[0]} % 60;
        $tmp_time > 9 ? $tmp_time : "0$tmp_time";
      };
}

sub check_user_input {
    given (shift) {
        when (\&quit_required) {
            main_quit();
        }
        when (['e', 'edit-config']) {
            system $CONFIG{editor}, $config_file;
            apply_configuration;
            return 1;
        }
        when (['load-config']) {
            apply_configuration();
            return 1;
        }
        when (['login']) {
            authenticate();
            return 1;
        }
        when (['logout']) {
            print "Logging out...\n";
            log_out();
            return 1;
        }
        when (/$contains_arguments/o) {
            parse_arguments(get_arguments_from_string(\$_));
            continue;
        }
        when (['reset', 'reload']) {
            @ARGV = ();
            do $0;
        }
        when (/$get_youtube_code/o) {
            get_youtube($1);
        }
        when (/$get_playlist_code/o) {
            list_playlist($1);
        }
        when (/$valid_playlist_code/o) {
            list_playlist($_);
        }
        when (m{^https?://} and /$valid_url/o) {
            code_from_content($_);
        }
        when (\&is_code) {
            get_youtube($_);
        }
    }
    return 0;
}

#---------------------- PRINT VIDEO RESULTS ----------------------#
sub print_results {

    if (@results) {
        $video_results = 1;
    }
    else {
        print "$bred(x_x) No video results!$reset\n";
        insert_url();
    }

    my $num = 0;
    foreach my $video (@results) {
        ++$num;
        $CONFIG{use_colors}

          # Colored output (when using --colors or -C)
          ? print $cblack, $bred, do { ' ' if $num < 10 }, $num, $reset,
          $cblack, q{ - }, $byellow, $video->{title}, $reset, $cblack,
          ' (', $bpurle, 'by ', $video->{author}, $reset, $cblack, ') (',
          $bblue, $video->{duration}, $reset, $cblack, ')', $reset, "\n"

          # Normal output
          : print $bred, do { ' ' if $num < 10 }, $num, $reset,
          q{ - }, $video->{title}, ' (by ', $video->{author},
          ') (', $video->{duration}, ")\n";
    }

    if ($playback) {
        @picks = 1 .. @results;
        foreach_pick();
    }

    {
        print "\n$bred=>>$bgreen Insert a number or search something else (? - help)$reset\n> ";

        given (<STDIN>) {
            chomp;
            when (['help', '?']) {
                print $stdin_help;
                redo;
            }
            when (\&check_user_input) {
                redo;
            }
            when (/^\s*$/ or $_ eq 'next') {
                next_page();
            }
            when ($_ eq 'back') {
                if (
                    do {
                        $youtube_gdata_url =~ /[&?]start-index=(\d+)/;
                        $1 > $CONFIG{results};
                    }
                  ) {
                    previous_page();
                }
                else {
                    continue;
                }
            }
            when ('all') {
                @picks = 1 .. scalar @results;
                foreach_pick();
            }
            when (chr ord eq q{/} and /$match_regexp/o) {
                my $match = qr/$1/i;
                @picks = grep { $results[$_ - 1]->{'title'} =~ /$match/ } 1 .. @results;
                if (@picks) {
                    foreach_pick();
                }
                else {
                    warn "\n${bred}(X_X) No video matched by the regexp: $bgreen/$match/$reset\n\n";
                    sleep 1;
                    print_results();
                }
            }
            when (/\d/ and not /(?:\s|^)[^\d-]/) {
                s/(?:\D|^)-+\d+(?:\w+)?//g;                          # remove resolution arguments (e.g.: --360p);
                s/(\d+)(?:-|[.][.])(\d+)/join q{ }, $1 .. $2;/eg;    # '2..5' or '2-5' to '2 3 4 5'
                @picks = grep { $_ > 0 and $_ <= scalar @results if /^\d+$/ } split /[\s[:punct:]]+/, $_;
                @picks
                  ? foreach_pick()
                  : continue;
            }
            default {
                search(join(q{ }, get_keywords_from_string(\$_)) or redo);
            }
        }
    }
}

sub foreach_pick {
    while (@picks) {
        get_youtube($results[shift(@picks) - 1]);
    }
}

#---------------------- NEXT PAGE ----------------------#
sub next_page {
    if ($youtube_gdata_url =~ s/(?<=[&?]start-index=)(\d+)/($1 + $CONFIG{results});/e) {
        if ($playlists) {
            search_playlists($youtube_gdata_url, @_);
        }
        else {
            parse_content($youtube_gdata_url);
            print_results();
        }
    }
}

#---------------------- PREVIOUS PAGE ----------------------#
sub previous_page {
    if ($youtube_gdata_url =~ s/(?<=[&?]start-index=)(\d+)/($1 - $CONFIG{results});/e) {
        if ($playlists) {
            search_playlists($youtube_gdata_url, @_);
        }
        else {
            parse_content($youtube_gdata_url);
            print_results();
        }
    }
}

sub lower_quality {
    foreach my $itag (sort { $b <=> $a } values %itags) {
        if (exists($streaming{$itag})) {
            return $streaming{$itag};
        }
    }
}

sub select_resolution {
    given ($CONFIG{'resolution'}) {
        when (1080) {
            return $streaming{1080} // lower_quality();
        }
        when (720) {
            return $streaming{720} // lower_quality();
        }
        when (480) {
            return $streaming{480} // lower_quality();
        }
        when (360) {
            return $streaming{360} // lower_quality();
        }
        when (240) {
            return $streaming{240} // lower_quality();
        }
        default {
            return lower_quality();
        }
    }
}

sub format_itags {
    my @itags;
    foreach my $itag (@_) {
        if (exists($itags{$itag})) {
            push @itags, $itags{$itag};
        }
    }
    @itags;
}

# Getting YouTube closed captions with gcap
sub get_closed_caption {
    my ($code) = @_;

    unless (exists $constant{'cwd'}) {
        $constant{'cwd'} = rel2abs curdir;
    }

    # Change dir to $TMP and get the SRT file
    chdir $CONFIG{'tmp_dir'};
    unless (-e "${code}_$CONFIG{srt_language}.srt") {
        system $CONFIG{perl_bin}, $CONFIG{gcap}, $code;
    }

    my $srt_file = '';
    if (-e "${code}_$CONFIG{srt_language}.srt") {
        $srt_file = "$CONFIG{mplayer_srt_settings} -sub ${code}_$CONFIG{srt_language}\.srt";
    }
    else {
        opendir(my $dir_h, $CONFIG{'tmp_dir'}) or return '';
        while (defined(my $line = readdir $dir_h)) {
            next unless substr($line, -4) eq '.srt';
            if ($line =~ /^($code\w*[.]srt)/) {
                $srt_file = "$CONFIG{mplayer_srt_settings} -sub $1";
                last;
            }
        }
        closedir $dir_h;
    }
    return $srt_file;
}

sub set_thousands {
    return 0 unless $_[0];
    return $_[0] unless length $_[0] > 3;
    my ($views) = @_;
    if (index($views, $CONFIG{thousand_separator}) < 0) {
        my $l = length($views) - 3;
        my $i = ($l - 1) % 3 + 1;
        my $x = substr($views, 0, $i) . $CONFIG{thousand_separator};
        while ($i < $l) {
            $x .= substr($views, $i, 3) . $CONFIG{thousand_separator};
            $i += 3;
        }
        return $x . substr($views, $i);
    }
}

sub get_youtube {
    my $info = shift();

    if (ref $info ne 'HASH') {
        parse_content("$CONFIG{gdata_feeds_main_url}/videos/$info?v=2");
        $info = $results[0];
        unless (ref $info eq 'HASH') {
            die "\n** Something is REALLY wrong... Unable to continue!\n
Tips:
    1. Install LWP::Protocol::https and HTTP::Request
    2. (Edit/delete) the configuration file
    3. Run in -debug mode and send '${execname}.debug' to developer\n";
        }
    }

    my $code    = $info->{code};
    my $content = lwp_get("$CONFIG{get_video_info}?&video_id=$code&el=detailpage&ps=default&eurl=&gl=US&hl=en");
    my $url     = sprintf($CONFIG{youtube_video_url}, $code);

    $MPLAYER{arguments} = '';
    if (    not $download_video
        and -e $CONFIG{gcap}
        and not exists $MPLAYER{novideo}
        and $content =~ /&has_cc=True&/) {
        $MPLAYER{arguments} = get_closed_caption($code);
    }

    if ($content =~ /url_encoded_fmt_stream_map=(.+?)&/) {
        my $streaming = $1;
        $streaming =~ s/%253A/:/gi;
        $streaming =~ s{%252F}{/}gi;
        $streaming =~ s/%2526/&/g;
        $streaming =~ s/%253D/=/gi;
        $streaming =~ s/%253F/?/gi;
        $streaming =~ s/%25252C/,/gi;

        undef %streaming;
        my (@streaming_urls) =
          grep (/^https?:/, split(/url%3D(.+?)%26/, $streaming));
        @streaming{format_itags(map { /&itag=(\d+)&/ } @streaming_urls)} = grep {
            exists $itags{
                do { /&itag=(\d+)&/; $1 }
              }
        } @streaming_urls;

        if ($debug_mode) {
            while (my ($key, $value) = each %streaming) {
                print "KEY = $key\nVALUE = $value\n\n";
            }
        }
        my $rating = sprintf('%.2f', ($content =~ /avg_rating=([^&]+)/));
        if (!defined $info->{description}) {
            $info->{description} = 'No description available...';
        }
        $info->{category} =~ s/&amp;/&/;
        $info->{published} = "$3.$2.$1" if $info->{published} =~ /^(\d\d\d\d)-(\d\d)-(\d\d)/;

        print "\n$bred=>> $bgreen$info->{title}$reset\n",
          "$constant{'dash_line'}\n",
          "$info->{description}\n$constant{'dash_line'}\n",
          "$bred=>> ${bgreen}View & Download$reset\n",
          "$constant{'dash_line'}\n* URL ";

        print STDOUT $url;

        print "\n* GET $streaming_urls[0]\n$constant{'dash_line'}\n",
          q{ } x ((length($constant{'dash_line'}) - length($info->{title})) / 2 - 4),    # centring video title on terminal
          "$bred=>> $bgreen$info->{title}$bred <<=$reset\n\n",
          "** Author    : $info->{author}\n",
          "** Category  : $info->{category}\n",
          "** Duration  : $info->{duration}\n",
          "** Rating    : $rating\n",
          "** Favorited : " . set_thousands($info->{favorited}) . "\n",
          "** Views     : " . set_thousands($info->{views}) . "\n",
          do { $info->{published} ? "** Published : $info->{published}\n" : '' },
          "$constant{'dash_line'}\n";

        # Select one resolution and play video
        play_or_download(select_resolution(), $info->{title});

    }
    else {

        # This happens when video has been deleted or forbidden
        warn "\n$bred(x_x) Something went wrong...$reset\n\n", "$bred(x_x) Unable to stream: $reset$url\n\n";
        if ($video_results and not $dont_exit) {
            unless (@picks) {
                sleep 1;
                print_results();
            }
        }
        else {
            unless ($video_results or $dont_exit) {
                main_quit();
            }
        }
    }
}

sub main_quit {
    write_config_to_file() unless $noconfig;
    exit;
}

main_quit();

package Config;

sub _dump {
    require Data::Dumper;
    return Data::Dumper::Dumper(shift);
}

sub _sort_items {
    my ($data) = @_;
    my ($items) = $data =~ /\{(.+?)\s*\};?\s*\z/s;
    $items .= ',';
    $data = 'my $config = {'
      . join(
             "\n",
             (
              sort { lc $a cmp lc $b }
                split(/\n/, $items, 0)
             )
            ) . "\n};\n";

    $data =~ s{=>\s*'(\d+)',\s*$}  {=> $1,}gm;
    $data =~ s{(.+?)\s*=>\s*(.+)}{
        sprintf '%s%*s', $1, 45 - length($1) + length($2), ' => ' . $2;
    }egm;
    return $data;
}

sub save_hash {
    my ($file, $config) = @_;
    return unless ref $config eq 'HASH';
    open(my $fh, '>', $file) or return;
    print {$fh} _sort_items(_dump($config));
    close $fh;
    return 1;
}

1;
